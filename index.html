<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>üöö Truck Data Manager</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #2c3e50;
            padding: 10px;
            min-height: 100vh;
            font-size: 14px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 15px 10px;
            background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        h1 {
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 5px;
            color: white;
        }

        .subtitle {
            font-size: 0.85em;
            opacity: 0.9;
            color: white;
        }

        .tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab-button {
            padding: 12px 16px;
            background: #5a7fa7;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            min-height: 44px;
            flex: 1 1 auto;
            min-width: 80px;
        }

        .tab-button:active {
            transform: scale(0.95);
        }

        .tab-button.active {
            background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%);
            box-shadow: 0 4px 8px rgba(255, 140, 66, 0.4);
        }

        .tab-content {
            display: none;
            background: #f8f9fa;
            padding: 15px 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 8px 12px;
            background: linear-gradient(135deg, #5a7fa7 0%, #4a6f97 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            min-height: 44px;
            white-space: nowrap;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-primary {
            background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .filters-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            margin-bottom: 10px;
            overflow: hidden;
        }

        .filters-toggle {
            width: 100%;
            padding: 12px 15px;
            background: linear-gradient(135deg, #5a7fa7 0%, #4a6f97 100%);
            border: none;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .filters-toggle:hover {
            background: linear-gradient(135deg, #4a6f97 0%, #3a5f87 100%);
        }

        .filters-toggle:active {
            transform: scale(0.98);
        }

        .filters-toggle-icon {
            transition: transform 0.3s ease;
            font-size: 1.2em;
        }

        .filters-toggle-icon.open {
            transform: rotate(180deg);
        }

        .filters {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            padding: 15px;
            background: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .filters.show {
            max-height: 500px;
            padding: 15px;
        }

        @media (min-width: 769px) {
            .filters {
                grid-template-columns: auto 1fr auto;
                align-items: start;
                gap: 20px;
            }
            
            .filters.show {
                max-height: 300px;
            }
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .filter-section > label {
            font-weight: 700;
            color: #1e3c72;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }

        .visibility-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
        }

        @media (min-width: 769px) {
            .visibility-grid {
                grid-template-columns: 1fr;
                gap: 6px;
            }
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .filter-item:hover {
            background: #e9ecef;
        }

        .filter-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #5a7fa7;
        }

        .filter-item label {
            cursor: pointer;
            font-weight: 500;
            color: #2c3e50;
            font-size: 0.85em;
            user-select: none;
            flex: 1;
        }

        .filter-dropdowns {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .filter-item select,
        .filter-item input[type="text"],
        .filter-item input[type="number"] {
            padding: 10px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
            width: 100%;
            min-height: 44px;
            background: white;
            transition: border-color 0.2s ease;
        }

        .filter-item select:focus,
        .filter-item input[type="text"]:focus,
        .filter-item input[type="number"]:focus {
            outline: none;
            border-color: #5a7fa7;
            box-shadow: 0 0 0 3px rgba(90, 127, 167, 0.1);
        }

        .search-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .search-section input {
            padding: 10px 12px 10px 38px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
            width: 100%;
            min-height: 44px;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%235a7fa7' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z'/%3E%3C/svg%3E") no-repeat 12px center;
            transition: border-color 0.2s ease;
        }

        .search-section input:focus {
            outline: none;
            border-color: #5a7fa7;
            box-shadow: 0 0 0 3px rgba(90, 127, 167, 0.1);
        }

        .advanced-filter {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .advanced-filter select,
        .advanced-filter input {
            flex: 1 1 100%;
            min-width: 0;
            min-height: 44px;
        }

        .progress-container {
            display: none;
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-container.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        .progress-status {
            margin-top: 8px;
            color: #2c3e50;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
        }

        .table-container {
            overflow-x: auto;
            background: white;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 500px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 500px;
            background: white;
        }

        th, td {
            padding: 6px 4px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
            font-size: 10px;
            white-space: nowrap;
            position: relative;
        }

        th {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            font-size: 9px;
        }

        th:active {
            background: linear-gradient(135deg, #2a5298 0%, #3a62a8 100%);
        }

        th .sort-indicator {
            margin-left: 4px;
            font-size: 0.8em;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:nth-child(odd) {
            background: white;
        }

        .row-green {
            background: #d4edda !important;
        }

        .row-yellow {
            background: #fff3cd !important;
        }

        .row-red {
            background: #f8d7da !important;
        }
        
        .row-blue {
            background: #e8d5f0 !important;
        }
        
        .row-dismissed {
            background: #d9534f !important;
            color: white;
        }

        .row-gray {
            background: #e8d5f0 !important;
            opacity: 0.9;
        }

        .row-lightblue {
            background: #d4e9ff !important;
        }
        
        .row-purple {
            background: #d4c5f9 !important;
        }

        .status-bar {
            background: white;
            padding: 8px;
            border-radius: 6px;
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1 1 auto;
            min-width: 100px;
            justify-content: center;
        }

        .status-badge {
            padding: 6px 10px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.8em;
            white-space: nowrap;
        }

        .badge-green {
            background: #27ae60;
            color: white;
        }

        .badge-yellow {
            background: #f39c12;
            color: white;
        }

        .badge-red {
            background: #e74c3c;
            color: white;
        }

        .badge-blue {
            background: #3498db;
            color: white;
        }

        .badge-total {
            background: #5a7fa7;
            color: white;
        }

        .pagination {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            flex-wrap: wrap;
        }

        .pagination button {
            padding: 8px 12px;
            background: #5a7fa7;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            min-height: 44px;
            font-size: 0.85em;
        }

        .pagination button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .pagination button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .pagination select {
            padding: 8px;
            border: 2px solid #5a7fa7;
            border-radius: 4px;
            min-height: 44px;
            font-size: 0.85em;
        }

        .pagination span {
            font-weight: bold;
            text-align: center;
            flex: 1 1 100%;
            font-size: 0.85em;
        }

        .chart-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        /* Make trend charts larger and centered */
        #trends .chart-section {
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 30px;
        }
        
        #trends .chart-section canvas {
            min-height: 450px !important;
        }

        @media (min-width: 1400px) {
            .chart-section {
                padding: 20px;
            }
            
            #trends .chart-section {
                padding: 30px;
            }
        }

        .chart-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .chart-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chart-control-group label {
            font-weight: bold;
            color: #1e3c72;
            font-size: 0.9em;
        }

        .chart-controls select,
        .chart-controls input {
            padding: 10px;
            border: 2px solid #5a7fa7;
            border-radius: 4px;
            background: white;
            color: #2c3e50;
            font-size: 0.9em;
            min-height: 44px;
        }

        .chart-canvas-container {
            max-width: 100%;
            margin: 20px auto;
            overflow-x: auto;
        }

        .dataset-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .dataset-section h3 {
            color: #1e3c72;
            margin-bottom: 10px;
            border-bottom: 2px solid #ff8c42;
            padding-bottom: 5px;
            font-size: 1.1em;
        }

        .totals-bar {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 10px 8px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 8px;
        }

        .total-item {
            font-size: 0.85em;
            text-align: center;
            flex: 1 1 auto;
            min-width: 130px;
        }

        .settings-panel {
            background: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-section h3 {
            color: #1e3c72;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #ff8c42;
            padding-bottom: 8px;
        }

        .sheet-input-group {
            margin-bottom: 15px;
        }

        .sheet-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.9em;
        }

        .sheet-input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #5a7fa7;
            border-radius: 4px;
            font-size: 0.85em;
            min-height: 44px;
        }

        .auto-refresh-indicator {
            display: inline-block;
            padding: 8px 12px;
            background: #27ae60;
            color: white;
            border-radius: 6px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .chart-type-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .chart-type-btn {
            padding: 10px 14px;
            background: #5a7fa7;
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1 1 auto;
            min-height: 44px;
        }

        .chart-type-btn.active {
            background: #ff8c42;
        }

        .chart-type-btn:active {
            transform: scale(0.95);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .summary-card {
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .summary-card.overpaid {
            background: #ffe6e6;
            border: 2px solid #e74c3c;
        }

        .summary-card.underpaid {
            background: #fff4e6;
            border: 2px solid #ff8c42;
        }

        .summary-card.total {
            background: #e6f2ff;
            border: 2px solid #5a7fa7;
        }

        .summary-value {
            font-size: 1.5em;
            font-weight: bold;
            margin: 10px 0;
        }

        .summary-label {
            font-size: 0.9em;
            color: #666;
        }

        .discrepancy-table {
            font-size: 9px;
            width: 100%;
            border-collapse: collapse;
        }

        .discrepancy-table th {
            background: #1e3c72;
            color: white;
            padding: 5px 4px;
            font-size: 8px;
            text-align: left;
        }

        .discrepancy-table td {
            padding: 4px;
            border-bottom: 1px solid #ddd;
            font-size: 9px;
        }

        .discrepancy-table tr:hover {
            background: #f0f0f0;
        }

        .amount-negative {
            color: #e74c3c;
            font-weight: bold;
        }

        .amount-positive {
            color: #3498db;
            font-weight: bold;
        }

        .money-header {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            padding: 20px 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
        }

        .money-header h2 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .money-emoji {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .money-card {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 3px solid #27ae60;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .money-card h3 {
            color: #155724;
            font-size: 1.2em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .money-total {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 1em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            overflow-y: auto;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #1e3c72;
        }

        .modal-header h2 {
            color: #1e3c72;
            margin: 0;
            font-size: 1.2em;
        }

        .close {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close:active {
            color: #000;
        }

        /* Mobile-specific improvements */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                font-size: 11px;
            }

            h1 {
                font-size: 1.2em;
            }

            .tab-button {
                padding: 8px 10px;
                font-size: 0.75em;
                min-width: 65px;
            }

            .btn {
                font-size: 0.75em;
                padding: 8px 10px;
            }

            th, td {
                font-size: 9px;
                padding: 5px 3px;
            }

            th {
                font-size: 8px;
            }

            .filters {
                padding: 12px;
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .visibility-grid {
                grid-template-columns: 1fr 1fr;
            }

            .filter-section > label {
                font-size: 0.7em;
            }

            .filter-item label {
                font-size: 0.8em;
            }

            .status-item {
                min-width: 90px;
            }

            .status-badge {
                font-size: 0.7em;
                padding: 5px 8px;
            }

            .total-item {
                font-size: 0.75em;
                min-width: 110px;
            }

            .table-container {
                max-height: 600px;
            }

            .chart-canvas-container {
                overflow-x: auto;
            }

            .dataset-section h3 {
                font-size: 1em;
            }

            .dataset-section p {
                font-size: 0.85em;
            }

            .discrepancy-table {
                font-size: 8px;
            }

            .discrepancy-table th {
                font-size: 7px;
                padding: 4px 3px;
            }

            .discrepancy-table td {
                font-size: 8px;
                padding: 3px;
            }
        }

        @media (max-width: 480px) {
            body {
                font-size: 10px;
            }

            h1 {
                font-size: 1.1em;
            }

            .tab-button {
                font-size: 0.7em;
                padding: 7px 8px;
            }

            th, td {
                font-size: 8px;
                padding: 4px 2px;
            }

            th {
                font-size: 7px;
            }

            .status-badge {
                font-size: 0.65em;
                padding: 4px 6px;
            }

            .total-item {
                font-size: 0.7em;
            }

            .money-emoji {
                font-size: 1.8em;
            }

            .money-header h2 {
                font-size: 1.1em;
            }

            .discrepancy-table {
                font-size: 7px;
            }

            .discrepancy-table th {
                font-size: 6px;
                padding: 3px 2px;
            }

            .discrepancy-table td {
                font-size: 7px;
                padding: 2px;
            }
        }

        .email-group {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #5a7fa7;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .email-group h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .copy-section {
            margin-bottom: 15px;
        }

        .copy-section label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .copy-section textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
            resize: vertical;
            min-height: 80px;
        }

        .copy-btn {
            background: linear-gradient(135deg, #5a7fa7 0%, #4a6f97 100%);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 5px;
            transition: all 0.3s;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .copy-btn.copied {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        /* Data Converter Tool */
        .converter-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .converter-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .converter-section textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85em;
            margin-bottom: 10px;
        }

        .converter-section input[type="date"] {
            padding: 10px;
            border: 2px solid #5a7fa7;
            border-radius: 6px;
            font-size: 0.9em;
            margin-bottom: 10px;
            width: 100%;
            max-width: 200px;
        }

        .converter-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöö Truck Data Manager</h1>
            <p class="subtitle">Manage Your Idling Summons Data</p>
        </header>

        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('at')">üöõ AT</button>
            <button class="tab-button" onclick="switchTab('at-nyc')">üèôÔ∏è AT NYC</button>
            <button class="tab-button" onclick="switchTab('mbt')">üöö MBT</button>
            <button class="tab-button" onclick="switchTab('new-money')">üí∞ NEW MONEY</button>
            <button class="tab-button" onclick="switchTab('discrepancies')">‚ö†Ô∏è DISC</button>
            <button class="tab-button" onclick="switchTab('time-analysis')">üìÖ CALENDAR</button>
            <button class="tab-button" onclick="switchTab('trends')">üìà TRENDS</button>
            <button class="tab-button" onclick="switchTab('changes')">üîÑ CHANGES</button>
            <button class="tab-button" onclick="switchTab('fun-facts')">üéâ FACTS</button>
            <button class="tab-button" onclick="switchTab('insights')">üöÄ INSIGHTS</button>
            <button class="tab-button" onclick="switchTab('charts')">üìä CHARTS</button>
            <button class="tab-button" onclick="switchTab('settings')">‚öôÔ∏è SET</button>
        </div>

        <!-- AT Tab -->
        <div id="at" class="tab-content active">
            <div class="controls">
                <button class="btn btn-primary" onclick="loadAllData()">üìÑ Load All</button>
                <button class="btn" onclick="refreshData('at')">üîÑ Refresh</button>
                <button class="btn btn-danger" onclick="clearData('at')">üóëÔ∏è Clear</button>
                <button class="btn" onclick="clearCacheAndReload()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">üíæ Clear Cache & Reload</button>
                <button class="btn" onclick="diagnoseCSVColumns()" style="background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);">üîç Check CSV Columns</button>
                <div id="at-timestamps" style="display: inline-block; padding: 0 15px; font-size: 0.7em; color: #666; white-space: nowrap;"></div>
                <div class="filter-item" style="margin-left: auto;">
                    <input type="checkbox" id="at-show-extra" onchange="toggleExtraColumns('at')">
                    <label for="at-show-extra">Extra Data</label>
                </div>
            </div>

            <div class="progress-container" id="at-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="at-progress-fill" style="width: 0%">0%</div>
                </div>
                <div class="progress-status" id="at-progress-status">Initializing...</div>
            </div>

            <div class="filters-container">
                <button class="filters-toggle" onclick="toggleFilters('at')">
                    <span>üîç Filters</span>
                    <span class="filters-toggle-icon" id="at-filters-icon">‚ñº</span>
                </button>
                <div class="filters" id="at-filters">
                    <div class="filter-section">
                        <label>Visibility</label>
                        <div class="visibility-grid">
                            <div class="filter-item">
                                <input type="checkbox" id="at-filter-paid" checked onchange="debouncedApplyFilters('at')">
                                <label for="at-filter-paid">Paid</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-filter-requested" checked onchange="debouncedApplyFilters('at')">
                                <label for="at-filter-requested">Requested</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-filter-disqualified" checked onchange="debouncedApplyFilters('at')">
                                <label for="at-filter-disqualified">Disqualified</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-filter-unpaid" checked onchange="debouncedApplyFilters('at')">
                                <label for="at-filter-unpaid">Unpaid</label>
                            </div>
                        </div>
                    </div>

                    <div class="filter-section">
                        <label>Quick Filters</label>
                        <div class="filter-dropdowns">
                            <select id="at-filter-payment-status" onchange="debouncedApplyFilters('at')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Payment Status</option>
                            </select>
                            <select id="at-filter-company" onchange="debouncedApplyFilters('at')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Companies</option>
                            </select>
                        </div>
                    </div>

                    <div class="filter-section search-section">
                        <label>Search</label>
                        <input type="text" id="at-filter-search" placeholder="Search all columns..." onkeyup="debouncedApplyFilters('at')">
                    </div>
                </div>
            </div>

            <div class="status-bar" id="at-status"></div>

            <div class="table-container" id="at-table-container">
                <table id="at-table">
                    <thead id="at-thead"></thead>
                    <tbody id="at-tbody"></tbody>
                </table>
            </div>

            <div class="pagination" id="at-pagination">
                <span id="at-page-info">Page 1</span>
                <button onclick="changePage('at', -1)">Previous</button>
                <button onclick="changePage('at', 1)">Next</button>
                <select id="at-page-size" onchange="changePageSize('at')">
                    <option value="50">50 per page</option>
                    <option value="100">100 per page</option>
                    <option value="all" selected>Show All</option>
                </select>
            </div>

            <div class="totals-bar" id="at-totals"></div>
        </div>

        <!-- AT NYC Tab -->
        <div id="at-nyc" class="tab-content">
            <div class="controls">
                <button class="btn btn-primary" onclick="loadAllData()">üìÑ Load All</button>
                <button class="btn" onclick="refreshData('at-nyc')">üîÑ Refresh</button>
                <button class="btn btn-danger" onclick="clearData('at-nyc')">üóëÔ∏è Clear</button>
                <div id="at-nyc-timestamps" style="display: inline-block; padding: 0 15px; font-size: 0.7em; color: #666; white-space: nowrap;"></div>
                <div class="filter-item" style="margin-left: auto;">
                    <input type="checkbox" id="at-nyc-show-extra" onchange="toggleExtraColumns('at-nyc')">
                    <label for="at-nyc-show-extra">Extra Data</label>
                </div>
            </div>

            <div class="progress-container" id="at-nyc-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="at-nyc-progress-fill" style="width: 0%">0%</div>
                </div>
                <div class="progress-status" id="at-nyc-progress-status">Initializing...</div>
            </div>

            <div class="filters-container">
                <button class="filters-toggle" onclick="toggleFilters('at-nyc')">
                    <span>üîç Filters</span>
                    <span class="filters-toggle-icon" id="at-nyc-filters-icon">‚ñº</span>
                </button>
                <div class="filters" id="at-nyc-filters">
                    <div class="filter-section">
                        <label>Visibility</label>
                        <div class="visibility-grid">
                            <div class="filter-item">
                                <input type="checkbox" id="at-nyc-filter-paid" checked onchange="debouncedApplyFilters('at-nyc')">
                                <label for="at-nyc-filter-paid">Paid</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-nyc-filter-requested" checked onchange="debouncedApplyFilters('at-nyc')">
                                <label for="at-nyc-filter-requested">Requested</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-nyc-filter-disqualified" checked onchange="debouncedApplyFilters('at-nyc')">
                                <label for="at-nyc-filter-disqualified">Disqualified</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="at-nyc-filter-unpaid" checked onchange="debouncedApplyFilters('at-nyc')">
                                <label for="at-nyc-filter-unpaid">Unpaid</label>
                            </div>
                        </div>
                    </div>

                    <div class="filter-section">
                        <label>Quick Filters</label>
                        <div class="filter-dropdowns">
                            <select id="at-nyc-filter-payment-status" onchange="debouncedApplyFilters('at-nyc')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Payment Status</option>
                            </select>
                            <select id="at-nyc-filter-company" onchange="debouncedApplyFilters('at-nyc')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Companies</option>
                            </select>
                        </div>
                    </div>

                    <div class="filter-section search-section">
                        <label>Search</label>
                        <input type="text" id="at-nyc-filter-search" placeholder="Search all columns..." onkeyup="debouncedApplyFilters('at-nyc')">
                    </div>
                </div>
            </div>

            <div class="status-bar" id="at-nyc-status"></div>

            <div class="table-container" id="at-nyc-table-container">
                <table id="at-nyc-table">
                    <thead id="at-nyc-thead"></thead>
                    <tbody id="at-nyc-tbody"></tbody>
                </table>
            </div>

            <div class="pagination" id="at-nyc-pagination">
                <span id="at-nyc-page-info">Page 1</span>
                <button onclick="changePage('at-nyc', -1)">Previous</button>
                <button onclick="changePage('at-nyc', 1)">Next</button>
                <select id="at-nyc-page-size" onchange="changePageSize('at-nyc')">
                    <option value="50">50 per page</option>
                    <option value="100">100 per page</option>
                    <option value="all" selected>Show All</option>
                </select>
            </div>

            <div class="totals-bar" id="at-nyc-totals"></div>
        </div>

        <!-- MBT Tab -->
        <div id="mbt" class="tab-content">
            <div class="controls">
                <button class="btn btn-primary" onclick="loadAllData()">üìÑ Load All</button>
                <button class="btn" onclick="refreshData('mbt')">üîÑ Refresh</button>
                <button class="btn btn-danger" onclick="clearData('mbt')">üóëÔ∏è Clear</button>
                <div id="mbt-timestamps" style="display: inline-block; padding: 0 15px; font-size: 0.7em; color: #666; white-space: nowrap;"></div>
                <div class="filter-item" style="margin-left: auto;">
                    <input type="checkbox" id="mbt-show-extra" onchange="toggleExtraColumns('mbt')">
                    <label for="mbt-show-extra">Extra Data</label>
                </div>
            </div>

            <div class="progress-container" id="mbt-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="mbt-progress-fill" style="width: 0%">0%</div>
                </div>
                <div class="progress-status" id="mbt-progress-status">Initializing...</div>
            </div>

            <div class="filters-container">
                <button class="filters-toggle" onclick="toggleFilters('mbt')">
                    <span>üîç Filters</span>
                    <span class="filters-toggle-icon" id="mbt-filters-icon">‚ñº</span>
                </button>
                <div class="filters" id="mbt-filters">
                    <div class="filter-section">
                        <label>Visibility</label>
                        <div class="visibility-grid">
                            <div class="filter-item">
                                <input type="checkbox" id="mbt-filter-paid" checked onchange="debouncedApplyFilters('mbt')">
                                <label for="mbt-filter-paid">Paid</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="mbt-filter-requested" checked onchange="debouncedApplyFilters('mbt')">
                                <label for="mbt-filter-requested">Requested</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="mbt-filter-disqualified" checked onchange="debouncedApplyFilters('mbt')">
                                <label for="mbt-filter-disqualified">Disqualified</label>
                            </div>
                            <div class="filter-item">
                                <input type="checkbox" id="mbt-filter-unpaid" checked onchange="debouncedApplyFilters('mbt')">
                                <label for="mbt-filter-unpaid">Unpaid</label>
                            </div>
                        </div>
                    </div>

                    <div class="filter-section">
                        <label>Quick Filters</label>
                        <div class="filter-dropdowns">
                            <select id="mbt-filter-payment-status" onchange="debouncedApplyFilters('mbt')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Payment Status</option>
                            </select>
                            <select id="mbt-filter-company" onchange="debouncedApplyFilters('mbt')" style="padding: 10px 12px; border: 2px solid #dee2e6; border-radius: 6px; font-size: 0.9em; min-height: 44px; background: white;">
                                <option value="">All Companies</option>
                            </select>
                        </div>
                    </div>

                    <div class="filter-section search-section">
                        <label>Search</label>
                        <input type="text" id="mbt-filter-search" placeholder="Search all columns..." onkeyup="debouncedApplyFilters('mbt')">
                    </div>
                </div>
            </div>

            <div class="status-bar" id="mbt-status"></div>

            <div class="table-container" id="mbt-table-container">
                <table id="mbt-table">
                    <thead id="mbt-thead"></thead>
                    <tbody id="mbt-tbody"></tbody>
                </table>
            </div>

            <div class="pagination" id="mbt-pagination">
                <span id="mbt-page-info">Page 1</span>
                <button onclick="changePage('mbt', -1)">Previous</button>
                <button onclick="changePage('mbt', 1)">Next</button>
                <select id="mbt-page-size" onchange="changePageSize('mbt')">
                    <option value="50">50 per page</option>
                    <option value="100">100 per page</option>
                    <option value="all" selected>Show All</option>
                </select>
            </div>

            <div class="totals-bar" id="mbt-totals"></div>
        </div>

        <!-- NEW MONEY Tab -->
        <div id="new-money" class="tab-content">
            <div class="money-header">
                <div class="money-emoji">üí∞üíµüí∏</div>
                <h2>New Money Waiting to Collect</h2>
                <p style="font-size: 0.95em; opacity: 0.95;">Summonses marked "Paid in Full" but not yet collected from NYC</p>
            </div>

            <div class="controls">
                <button class="btn btn-success" onclick="refreshNewMoney()">üîÑ Refresh New Money</button>
            </div>

            <div class="money-card">
                <h3>üíö AT Dataset</h3>
                <button class="btn btn-success" onclick="showEmailExportModal('at')" style="margin-bottom: 10px;">üìß Export for Email (Groups of 8)</button>
                <div class="table-container">
                    <table id="new-money-at-table">
                        <thead id="new-money-at-thead"></thead>
                        <tbody id="new-money-at-tbody"></tbody>
                    </table>
                </div>
                <div class="money-total" id="new-money-at-totals"></div>
            </div>

            <div class="money-card">
                <h3>üíô AT NYC Dataset</h3>
                <button class="btn btn-success" onclick="showEmailExportModal('at-nyc')" style="margin-bottom: 10px;">üìß Export for Email (Groups of 8)</button>
                <div class="table-container">
                    <table id="new-money-at-nyc-table">
                        <thead id="new-money-at-nyc-thead"></thead>
                        <tbody id="new-money-at-nyc-tbody"></tbody>
                    </table>
                </div>
                <div class="money-total" id="new-money-at-nyc-totals"></div>
            </div>

            <div class="money-card">
                <h3>üíõ MBT Dataset</h3>
                <button class="btn btn-success" onclick="showEmailExportModal('mbt')" style="margin-bottom: 10px;">üìß Export for Email (Groups of 8)</button>
                <div class="table-container">
                    <table id="new-money-mbt-table">
                        <thead id="new-money-mbt-thead"></thead>
                        <tbody id="new-money-mbt-tbody"></tbody>
                    </table>
                </div>
                <div class="money-total" id="new-money-mbt-totals"></div>
            </div>

            <!-- Requested but Not Yet Paid Section -->
            <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 2em; margin-bottom: 10px;">‚è≥üìãüïê</div>
                    <h2 style="color: white; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">Requested but Not Yet Paid</h2>
                    <p style="color: white; opacity: 0.95; font-size: 0.95em; margin-top: 5px;">Payment requests submitted but not yet received</p>
                </div>

                <!-- Overall Total -->
                <div id="pending-overall-total"></div>

                <div class="money-card">
                    <h3>üíö AT Dataset</h3>
                    <div class="table-container">
                        <table id="pending-at-table">
                            <thead id="pending-at-thead"></thead>
                            <tbody id="pending-at-tbody"></tbody>
                        </table>
                    </div>
                    <div class="money-total" id="pending-at-totals"></div>
                </div>

                <div class="money-card">
                    <h3>üíô AT NYC Dataset</h3>
                    <div class="table-container">
                        <table id="pending-at-nyc-table">
                            <thead id="pending-at-nyc-thead"></thead>
                            <tbody id="pending-at-nyc-tbody"></tbody>
                        </table>
                    </div>
                    <div class="money-total" id="pending-at-nyc-totals"></div>
                </div>

                <div class="money-card">
                    <h3>üíõ MBT Dataset</h3>
                    <div class="table-container">
                        <table id="pending-mbt-table">
                            <thead id="pending-mbt-thead"></thead>
                            <tbody id="pending-mbt-tbody"></tbody>
                        </table>
                    </div>
                    <div class="money-total" id="pending-mbt-totals"></div>
                </div>
            </div>

            <!-- Data Converter Tool -->
            <div class="converter-section">
                <h3>üîß OATH Data Converter</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">
                    Paste raw OATH data (format: "Office of Administrative Trials and HearingsBP00861922Z87.50...")
                    and convert it to a table format.
                </p>
                
                <label for="raw-data-input" style="font-weight: bold; display: block; margin-bottom: 5px;">Raw Data Input:</label>
                <textarea id="raw-data-input" rows="6" placeholder="Paste raw OATH data here..."></textarea>
                
                <div style="margin-bottom: 10px;">
                    <label for="payment-date-input" style="font-weight: bold; display: block; margin-bottom: 5px;">Payment Date:</label>
                    <input type="date" id="payment-date-input">
                </div>

                <div class="converter-buttons">
                    <button class="btn btn-primary" onclick="convertOATHData()">üîÑ Convert Data</button>
                    <button class="btn btn-success" onclick="copyConvertedData()">üìã Copy Result</button>
                    <button class="btn" onclick="clearConverter()">üóëÔ∏è Clear</button>
                </div>

                <div id="converted-output" style="margin-top: 15px; display: none;">
                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">Converted Output:</label>
                    <textarea id="converted-data-output" rows="8" readonly style="background-color: #f0f0f0;"></textarea>
                </div>
            </div>
        </div>

        <!-- DISCREPANCIES Tab -->
        <div id="discrepancies" class="tab-content">
            <div class="controls">
                <button class="btn btn-primary" onclick="generateDiscrepancies()">üîç Generate Reports</button>
            </div>

            <div class="dataset-section">
                <h3>Payment Amount Mismatches</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">Invoices where the amount you received doesn't match 25% of what NYC was paid.</p>
                <div style="margin-bottom: 10px;">
                    <button class="btn btn-success" onclick="exportMismatchesPDF()">üìÑ Export PDF Report</button>
                </div>
                <div id="discrepancies-mismatches"></div>
            </div>

            <div class="dataset-section">
                <h3>Paid But Not "Paid in Full"</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">Summonses with a Paid Amount above zero but Hearing Status is not "Paid in Full".</p>
                <div id="discrepancies-paid-not-full"></div>
            </div>

            <div class="dataset-section">
                <h3>Orphaned Payments</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">Payments in your "Paid" sheet that don't have a corresponding entry in the master dataset.</p>
                <div id="discrepancies-orphaned"></div>
            </div>

            <div class="dataset-section">
                <h3>‚úÖ Properly Paid Summonses</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">All summonses where payment matches exactly 25% of what NYC received - these are correct!</p>
                <div style="margin-bottom: 10px;">
                    <button class="btn btn-success" onclick="generateProperlyPaidReport()">üìä Generate Report</button>
                    <button class="btn" onclick="exportProperlyPaidPDF()" id="export-properly-paid-btn" style="display: none;">üìÑ Export PDF</button>
                </div>
                <div id="properly-paid-section"></div>
            </div>
        </div>

        <!-- TIME ANALYSIS Tab -->
        <div id="time-analysis" class="tab-content">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <h2 style="margin-bottom: 10px; font-size: 1.8em;">‚è∞ Time Analysis - ROI by Day & Week</h2>
                <p style="font-size: 1em; opacity: 0.95;">Track your filming sessions and calculate true hourly rate</p>
            </div>

            <!-- Controls -->
            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">View:</label>
                        <button id="view-daily-btn" class="btn btn-primary" onclick="switchTimeView('daily')" style="margin-right: 5px;">Daily</button>
                        <button id="view-weekly-btn" class="btn" onclick="switchTimeView('weekly')">Weekly</button>
                    </div>
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Dataset:</label>
                        <select id="time-dataset" onchange="generateTimeAnalysis()">
                            <option value="all">All Datasets</option>
                            <option value="at">AT Only</option>
                            <option value="at-nyc">AT NYC Only</option>
                            <option value="mbt">MBT Only</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Year:</label>
                        <select id="time-year" onchange="generateTimeAnalysis()"></select>
                    </div>
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Month:</label>
                        <select id="time-month" onchange="generateTimeAnalysis()"></select>
                    </div>
                    <button class="btn btn-primary" onclick="generateTimeAnalysis()" style="margin-left: auto;">üîÑ Refresh</button>
                </div>
            </div>

            <!-- Daily View -->
            <div id="daily-view" style="display: block;">
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <button class="btn" onclick="previousMonth()">‚Üê Previous</button>
                        <h3 id="calendar-title" style="color: #1e3c72; margin: 0;"></h3>
                        <button class="btn" onclick="nextMonth()">Next ‚Üí</button>
                    </div>
                    <div id="calendar-grid" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px;"></div>
                </div>

                <div id="day-detail" style="display: none;">
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); border-left: 4px solid #667eea;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 id="day-detail-title" style="color: #1e3c72; margin: 0;"></h3>
                            <button class="btn" onclick="closeDayDetail()">‚úï Close</button>
                        </div>
                        <div id="day-detail-content"></div>
                    </div>
                </div>
            </div>

            <!-- Weekly View -->
            <div id="weekly-view" style="display: none;">
                <div id="week-calendar-selector" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <button class="btn" onclick="previousWeek()">‚Üê Previous Month</button>
                        <h4 style="color: #1e3c72; margin: 0;">üìÖ Select a Week</h4>
                        <button class="btn" onclick="nextWeek()">Next Month ‚Üí</button>
                    </div>
                    <div id="week-selector-calendar"></div>
                </div>

                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);">
                    <h3 id="week-title" style="color: #1e3c72; margin: 0 0 20px 0; text-align: center;"></h3>
                    
                    <div id="week-payment-tracking" style="margin-bottom: 20px;"></div>
                    <div id="week-summary"></div>
                </div>
            </div>
        </div>

        <!-- DISTANCE Tab -->
        <div id="distance" class="tab-content">
            <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <h2 style="margin-bottom: 10px; font-size: 1.8em;">üö∂ Distance Tracker</h2>
                <p style="font-size: 1em; opacity: 0.95;">Track your walking distance by day, week, and month</p>
            </div>

            <!-- Quick Stats Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 20px;">
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Work Miles This Month</div>
                    <div id="distance-month-total" style="font-size: 1.8em; font-weight: bold;">0.00</div>
                    <div style="font-size: 0.75em; opacity: 0.8;">during shifts</div>
                </div>
                <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Avg Per Shift</div>
                    <div id="distance-avg-workday" style="font-size: 1.8em; font-weight: bold;">0.00</div>
                    <div style="font-size: 0.75em; opacity: 0.8;">miles/shift</div>
                </div>
                <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Total Shifts</div>
                    <div id="distance-work-split" style="font-size: 1.8em; font-weight: bold;">0</div>
                    <div style="font-size: 0.75em; opacity: 0.8;">this month</div>
                </div>
                <div style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Best Shift</div>
                    <div id="distance-best-day" style="font-size: 1.8em; font-weight: bold;">--</div>
                    <div style="font-size: 0.75em; opacity: 0.8;">miles</div>
                </div>
            </div>

            <!-- Controls -->
            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Dataset:</label>
                        <select id="distance-dataset" onchange="generateDistanceCalendar()">
                            <option value="all">All Datasets</option>
                            <option value="at">AT Only</option>
                            <option value="at-nyc">AT NYC Only</option>
                            <option value="mbt">MBT Only</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Year:</label>
                        <select id="distance-year" onchange="generateDistanceCalendar()"></select>
                    </div>
                    <div>
                        <label style="font-size: 0.85em; color: #666; margin-right: 5px;">Month:</label>
                        <select id="distance-month" onchange="generateDistanceCalendar()"></select>
                    </div>
                    <button class="btn btn-primary" onclick="generateDistanceCalendar()" style="margin-left: auto;">üîÑ Refresh</button>
                </div>
            </div>

            <!-- Calendar Container -->
            <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px;">
                <div id="distance-calendar"></div>
            </div>

            <!-- Day Detail Modal -->
            <div id="distance-day-detail" style="display: none; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="color: #2c3e50; margin: 0;">Day Detail</h3>
                    <button class="btn" onclick="closeDistanceDayDetail()">‚úï Close</button>
                </div>
                <div id="distance-day-detail-content"></div>
            </div>

            <!-- Insights Panel -->
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px;">
                <h3 style="margin-top: 0; margin-bottom: 15px;">üí° Distance Insights</h3>
                <div id="distance-insights"></div>
            </div>
        </div>

        <!-- TRENDS Tab -->
        <div id="trends" class="tab-content">
            <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                <h3 style="color: #1e3c72; margin-bottom: 12px;">üìà Trends Over Time</h3>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Track how your summons data changes over time with interactive trend analysis.</p>
                
                <div class="controls">
                    <button class="btn btn-primary" onclick="generateAllTrends()">üîÑ Generate All Trends</button>
                    <button class="btn btn-success" onclick="reloadWalkingDataAndTrends()">üö∂ Reload Walking Data</button>
                    <div class="filter-item">
                        <select id="trends-dataset" onchange="generateAllTrends()">
                            <option value="all">All Datasets</option>
                            <option value="at">AT Only</option>
                            <option value="at-nyc">AT NYC Only</option>
                            <option value="mbt">MBT Only</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <select id="trends-grouping" onchange="generateAllTrends()">
                            <option value="month">By Month</option>
                            <option value="quarter">By Quarter</option>
                            <option value="year">By Year</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Summons Volume Over Time -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üìä Summons Volume Over Time</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Total number of summonses issued per time period</p>
                <div class="chart-canvas-container">
                    <canvas id="trend-volume-chart"></canvas>
                </div>
            </div>

            <!-- Payment Status Trend -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üí∞ Payment Collection Trend</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Track how payments, requests, and disqualifications change over time</p>
                <div class="chart-canvas-container">
                    <canvas id="trend-payment-chart"></canvas>
                </div>
            </div>

            <!-- Revenue Over Time -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üíµ Revenue Over Time</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Your 25% share and potential remaining revenue from balance due</p>
                <div class="chart-canvas-container">
                    <canvas id="trend-revenue-chart"></canvas>
                </div>
            </div>

            <!-- Disqualification Rate -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">‚ùå Disqualification Rate Over Time</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Percentage of cases disqualified per period</p>
                <div class="chart-canvas-container">
                    <canvas id="trend-disqualification-chart"></canvas>
                </div>
            </div>

            <!-- Time of Day Analysis -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">‚è∞ Time of Day Analysis</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Number of summonses by hour of day</p>
                <div class="chart-canvas-container">
                    <canvas id="time-of-day-chart"></canvas>
                </div>
            </div>

            <!-- Top Companies Trend -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üè¢ Top Companies Activity Over Time</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Track summons volume for top 5 companies</p>
                <div class="chart-canvas-container">
                    <canvas id="trend-companies-chart"></canvas>
                </div>
            </div>

            <!-- Top 10 Weeks Analysis -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üìÖ Top 10 Weeks (Sunday-Saturday)</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Busiest weeks for violations</p>
                <div id="trend-top-weeks"></div>
            </div>

            <!-- Top 10 Days Analysis -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üìÜ Top 10 Days</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Single busiest days for violations</p>
                <div id="trend-top-days"></div>
            </div>

            <!-- Top 10 Hours Analysis -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">‚è∞ Top 10 Hours</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Most common violation times</p>
                <div id="trend-top-hours"></div>
            </div>

            <!-- Top 25 Companies Analysis -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üèÜ Top 25 Companies</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Companies with most submissions and their payment totals</p>
                <div id="trend-top-25-companies"></div>
            
            <!-- Walking Distance Over Time -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üö∂ Walking Distance Over Time</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Total miles walked during work shifts by period</p>
                <div class="chart-canvas-container">
                    <canvas id="walking-distance-chart"></canvas>
                </div>
            </div>

            <!-- Walking Efficiency Trend -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">‚ö° Walking Efficiency Trend</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">Miles per summons over time</p>
                <div class="chart-canvas-container">
                    <canvas id="walking-efficiency-chart"></canvas>
                </div>
            </div>

            <!-- Weather Impact -->
            <div class="chart-section">
                <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üå°Ô∏è Weather Impact on Performance</h4>
                <p style="color: #666; font-size: 0.85em; margin-bottom: 12px;">How temperature affects productivity</p>
                <div class="chart-canvas-container">
                    <canvas id="weather-impact-chart"></canvas>
                </div>
            </div>
        </div>
        </div>

        <!-- CHANGES Tab -->
        <div id="changes" class="tab-content">
            <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                <h3 style="color: #1e3c72; margin-bottom: 12px;">üîÑ Data Change Tracking</h3>
                <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Track what changes between data refreshes - new summonses, status updates, and payment changes.</p>
                
                <div class="controls">
                    <button class="btn btn-primary" onclick="viewAllChanges()">üìã View All Changes</button>
                    <button class="btn" onclick="filterChangesByType('status')">Status Changes</button>
                    <button class="btn" onclick="filterChangesByType('payment')">Payment Changes</button>
                    <button class="btn" onclick="filterChangesByType('new')">New Summonses</button>
                    <button class="btn btn-danger" onclick="clearChangeHistory()">üóëÔ∏è Clear History</button>
                </div>
            </div>

            <!-- Summary Cards -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 20px;">
                <div style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); padding: 15px; border-radius: 6px; text-align: center; color: white;">
                    <div style="font-size: 0.8em; opacity: 0.9;">Total Changes</div>
                    <div style="font-size: 1.8em; font-weight: bold; margin: 8px 0;" id="changes-total">0</div>
                </div>
                <div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); padding: 15px; border-radius: 6px; text-align: center; color: white;">
                    <div style="font-size: 0.8em; opacity: 0.9;">Status Changes</div>
                    <div style="font-size: 1.8em; font-weight: bold; margin: 8px 0;" id="changes-status">0</div>
                </div>
                <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); padding: 15px; border-radius: 6px; text-align: center; color: white;">
                    <div style="font-size: 0.8em; opacity: 0.9;">Payment Updates</div>
                    <div style="font-size: 1.8em; font-weight: bold; margin: 8px 0;" id="changes-payment">0</div>
                </div>
                <div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); padding: 15px; border-radius: 6px; text-align: center; color: white;">
                    <div style="font-size: 0.8em; opacity: 0.9;">New Summonses</div>
                    <div style="font-size: 1.8em; font-weight: bold; margin: 8px 0;" id="changes-new">0</div>
                </div>
            </div>

            <!-- Last Refresh Info -->
            <div style="background: #e8f4f8; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #3498db;">
                <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 0.85em;">
                    <div><strong>Last Refresh:</strong> <span id="last-refresh-time">Never</span></div>
                    <div><strong>Changes Detected:</strong> <span id="last-refresh-changes">0</span></div>
                </div>
            </div>

            <!-- Changes Timeline -->
            <div style="background: white; padding: 15px; border-radius: 6px;">
                <h4 style="color: #1e3c72; margin-bottom: 15px; font-size: 1em;">üìÖ Change History Timeline</h4>
                <div id="changes-timeline" style="max-height: 600px; overflow-y: auto;">
                    <p style="text-align: center; color: #666; padding: 40px;">No changes tracked yet. Refresh your data to start tracking changes.</p>
                </div>
            


                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h4 style="color: #1e3c72; margin: 0 0 8px 0;">üö∂ Total Distance Covered</h4>
                    <p id="walking-insight-total" style="color: #666; font-size: 0.95em;">Calculating...</p>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h4 style="color: #1e3c72; margin: 0 0 8px 0;">‚ö° Walking Efficiency</h4>
                    <p id="walking-insight-efficiency" style="color: #666; font-size: 0.95em;">Your average distance per summons.</p>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h4 style="color: #1e3c72; margin: 0 0 8px 0;">üìÖ Best Day of the Week</h4>
                    <p id="best-day-week" style="color: #666; font-size: 0.95em;">Analyzing which day performs best...</p>
                </div>

                <h4 style="color: #1e3c72; margin: 0 0 8px 0;">‚è±Ô∏è Total Hours Worked</h4>
                    <p id="hours-worked-insight" style="color: #666; font-size: 0.95em;">Calculating based on 2.5hr break detection...</p>
                </div>
        </div>
        </div>

        <!-- FUN FACTS Tab -->
        <div id="fun-facts" class="tab-content">
            <div class="controls">
                <button class="btn btn-primary" onclick="generateFunFacts()">üéâ Generate Fun Facts</button>
            </div>
            <div id="fun-facts-container" style="display: grid; grid-template-columns: 1fr; gap: 15px; margin-top: 20px;"></div>
        </div>

        <!-- INSIGHTS Tab -->
        <div id="insights" class="tab-content">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <h2 style="margin-bottom: 10px; font-size: 1.8em;">üöÄ Advanced Analytics & Insights</h2>
                <p style="font-size: 1em; opacity: 0.95;">Powerful tools to maximize your revenue and optimize your workflow</p>
            </div>

            <!-- Dataset Filters -->
            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <h4 style="color: #667eea; margin-bottom: 12px; font-size: 1em;">üìä Select Datasets to Analyze</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                    <div class="filter-item" style="background: #f8f9fa; padding: 10px; border-radius: 6px;">
                        <input type="checkbox" id="insights-filter-at-before" checked onchange="updateInsightsDatasetInfo()">
                        <label for="insights-filter-at-before" style="font-weight: 600;">üü¢ AT (Before 10/1/24)</label>
                    </div>
                    <div class="filter-item" style="background: #f8f9fa; padding: 10px; border-radius: 6px;">
                        <input type="checkbox" id="insights-filter-at-after" checked onchange="updateInsightsDatasetInfo()">
                        <label for="insights-filter-at-after" style="font-weight: 600;">üü¢ AT (After 10/1/24)</label>
                    </div>
                    <div class="filter-item" style="background: #f8f9fa; padding: 10px; border-radius: 6px;">
                        <input type="checkbox" id="insights-filter-mbt" checked onchange="updateInsightsDatasetInfo()">
                        <label for="insights-filter-mbt" style="font-weight: 600;">üîµ MBT</label>
                    </div>
                    <div class="filter-item" style="background: #f8f9fa; padding: 10px; border-radius: 6px;">
                        <input type="checkbox" id="insights-filter-at-nyc" checked onchange="updateInsightsDatasetInfo()">
                        <label for="insights-filter-at-nyc" style="font-weight: 600;">üü° AT NYC</label>
                    </div>
                </div>
                <div id="insights-dataset-info" style="margin-top: 10px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 0.9em; color: #666; text-align: center;">
                    Loading dataset information...
                </div>
            </div>

            <!-- AI Analysis Box -->
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                <h3 style="color: white; margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">ü§ñ</span>
                    <span>Ask Claude AI</span>
                </h3>
                <p style="color: rgba(255,255,255,0.9); margin: 0 0 15px 0; font-size: 0.9em;">Ask questions about your data and get AI-powered insights</p>
                
                <div style="background: white; padding: 15px; border-radius: 6px;">
                    <textarea id="ai-question" placeholder="Example: What are my busiest days? Which companies owe me the most money? What's my payment success rate?" style="width: 100%; min-height: 80px; padding: 12px; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.95em; font-family: inherit; resize: vertical;"></textarea>
                    
                    <div style="margin-top: 12px; display: flex; gap: 10px; align-items: center;">
                        <button class="btn btn-primary" onclick="askClaudeAI()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: 10px 20px;">
                            üí¨ Ask Claude
                        </button>
                        <button class="btn" onclick="clearAIResponse()" style="padding: 10px 20px;">
                            üóëÔ∏è Clear
                        </button>
                        <span id="ai-loading" style="display: none; color: #667eea; font-size: 0.9em;">
                            <span style="animation: pulse 1.5s ease-in-out infinite;">ü§î Thinking...</span>
                        </span>
                    </div>
                </div>
                
                <div id="ai-response" style="display: none; background: white; padding: 20px; border-radius: 6px; margin-top: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 2px solid #e0e0e0;">
                        <span style="font-size: 1.3em;">ü§ñ</span>
                        <strong style="color: #667eea; font-size: 1.1em;">Claude's Analysis</strong>
                    </div>
                    <div id="ai-response-content" style="color: #333; line-height: 1.6; white-space: pre-wrap;"></div>
                </div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="generateAllInsights()">üöÄ Generate All Insights</button>
                <button class="btn btn-success" onclick="exportInsightsReport()">üì• Export Report</button>
            </div>

            <!-- 1. Top Priority Cases -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üí∞</span>
                    <span>1. Average $ per Summons</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Total amount paid or requested divided by total number of summonses</p>
                <div id="insight-payment-predictor"></div>
            </div>

            <!-- 2. Company Intelligence Dashboard -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üè¢</span>
                    <span>2. Company Intelligence Dashboard</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Deep profiles of each company with reliability scores and recommendations</p>
                <div id="insight-company-intelligence"></div>
            </div>

            <!-- 3. Walking Efficiency Analysis -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üö∂</span>
                    <span>3. Walking Efficiency Analysis</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Understand your walking patterns and optimize your routes for maximum revenue per mile</p>
                <div id="insight-walking-efficiency"></div>
            </div>

            <!-- 4. Cash Flow Forecaster -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üìä</span>
                    <span>4. Cash Flow Forecaster</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Predict when money will hit your account based on pending requests</p>
                <div id="insight-cash-flow"></div>
            </div>

            <!-- 5. Disqualification Detective -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üîç</span>
                    <span>5. Disqualification Detective</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Find patterns in your losses to reduce disqualification rate</p>
                <div id="insight-disqualification"></div>
            </div>

            <!-- 6. Geographic Heat Map -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üó∫Ô∏è</span>
                    <span>6. Geographic Heat Map</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Where to hunt: violation density and payment rates by location</p>
                <div id="insight-geographic"></div>
            </div>

            <!-- 7. Violation Type Analysis -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üè∑Ô∏è</span>
                    <span>7. Violation Type Analysis</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Breakdown of violation codes with success rates and revenue</p>
                <div id="violation-type-breakdown"></div>
            </div>

            <!-- 8. Seasonal Demand Planner -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üìÖ</span>
                    <span>8. Seasonal Demand Planner</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Predict violation volume by month and season</p>
                <div id="insight-seasonal"></div>
            </div>

            <!-- 9. Revenue Maximization Opportunities -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">üí∞</span>
                    <span>9. Revenue Maximization Opportunities</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Identify and quantify your biggest revenue opportunities to maximize earnings</p>
                <div id="insight-behavior-change"></div>
            </div>

            <!-- 10. ROI Time Tracker -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">‚è±Ô∏è</span>
                    <span>10. ROI & Performance Metrics</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Revenue per case type and profitability analysis</p>
                <div id="insight-roi"></div>
            </div>

            <!-- 11. Con Edison Deep Dive -->
            <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <h3 style="color: #667eea; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.5em;">‚ö°</span>
                    <span>11. Con Edison Complete Analysis</span>
                </h3>
                <p style="color: #666; margin-bottom: 15px;">Comprehensive data on your largest customer - all Con Ed variations grouped</p>
                <div id="insight-coned"></div>
            </div>
        </div>

        <!-- CHARTS Tab -->
        <div id="charts" class="tab-content">
            <div class="chart-section">
                <h3 style="margin-bottom: 15px; color: #1e3c72;">üìä Data Visualizations</h3>
                
                <!-- Quick Insights -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">‚ö° Quick Insights</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px;">
                        <button class="btn btn-primary" onclick="showPaymentStatusChart()" style="font-size: 0.75em; padding: 8px;">Payment Status</button>
                        <button class="btn btn-primary" onclick="showCompanyChart()" style="font-size: 0.75em; padding: 8px;">Top Companies</button>
                        <button class="btn btn-primary" onclick="showBoroughChart()" style="font-size: 0.75em; padding: 8px;">By Borough</button>
                        <button class="btn btn-primary" onclick="showMonthlyTrend()" style="font-size: 0.75em; padding: 8px;">Monthly Trend</button>
                        <button class="btn btn-primary" onclick="showHearingResults()" style="font-size: 0.75em; padding: 8px;">Hearing Results</button>
                        <button class="btn btn-primary" onclick="showRevenueAnalysis()" style="font-size: 0.75em; padding: 8px;">Revenue Analysis</button>
                    </div>
                </div>

                <!-- Custom Chart Builder -->
                <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 2px solid #5a7fa7;">
                    <h4 style="color: #1e3c72; margin-bottom: 12px; font-size: 1em;">üé® Custom Chart Builder</h4>
                    
                    <div class="chart-type-buttons">
                        <button class="chart-type-btn active" onclick="setChartType('pie')">Pie</button>
                        <button class="chart-type-btn" onclick="setChartType('bar')">Bar</button>
                        <button class="chart-type-btn" onclick="setChartType('line')">Line</button>
                        <button class="chart-type-btn" onclick="setChartType('doughnut')">Doughnut</button>
                        <button class="chart-type-btn" onclick="setChartType('horizontalBar')">H-Bar</button>
                    </div>

                    <div class="chart-controls">
                        <div class="chart-control-group">
                            <label>üìÅ Data Source</label>
                            <select id="chart-tab-selector">
                                <option value="all">All Datasets Combined</option>
                                <option value="at">AT Only</option>
                                <option value="at-nyc">AT NYC Only</option>
                                <option value="mbt">MBT Only</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üìä Measure</label>
                            <select id="chart-measure">
                                <option value="count">Count of Records</option>
                                <option value="sum-paid">Sum of Paid Amount</option>
                                <option value="avg-paid">Average Paid Amount</option>
                                <option value="sum-balance">Sum of Balance Due</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üè∑Ô∏è Group By</label>
                            <select id="chart-field-selector">
                                <option value="Payment Status">Payment Status</option>
                                <option value="Status">Status</option>
                                <option value="Hearing Status">Hearing Status</option>
                                <option value="Hearing Result">Hearing Result</option>
                                <option value="Company Name">Company Name</option>
                                <option value="Issuing Agency">Issuing Agency</option>
                                <option value="Violation Location (Borough)">Borough</option>
                                <option value="month">Month (from Violation Date)</option>
                                <option value="year">Year (from Violation Date)</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üéØ Filter by Status</label>
                            <select id="chart-status-filter">
                                <option value="">All Statuses</option>
                                <option value="paid">Paid Only</option>
                                <option value="requested">Requested Only</option>
                                <option value="disqualified">Disqualified Only</option>
                                <option value="unpaid">Unpaid Only</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üìÖ Date Range</label>
                            <select id="chart-date-range">
                                <option value="all">All Time</option>
                                <option value="ytd">Year to Date</option>
                                <option value="last-12">Last 12 Months</option>
                                <option value="last-6">Last 6 Months</option>
                                <option value="last-3">Last 3 Months</option>
                                <option value="this-year">This Year</option>
                                <option value="last-year">Last Year</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üî¢ Max Items</label>
                            <select id="chart-max-items">
                                <option value="5">Top 5</option>
                                <option value="10" selected>Top 10</option>
                                <option value="15">Top 15</option>
                                <option value="20">Top 20</option>
                                <option value="all">Show All</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üìà Sort By</label>
                            <select id="chart-sort">
                                <option value="value-desc">Value (High to Low)</option>
                                <option value="value-asc">Value (Low to High)</option>
                                <option value="label-asc">Label (A to Z)</option>
                                <option value="label-desc">Label (Z to A)</option>
                            </select>
                        </div>

                        <div class="chart-control-group">
                            <label>üé® Color Scheme</label>
                            <select id="chart-color-scheme">
                                <option value="default">Default Rainbow</option>
                                <option value="blue">Blue Gradient</option>
                                <option value="green">Green Gradient</option>
                                <option value="red">Red Gradient</option>
                                <option value="purple">Purple Gradient</option>
                                <option value="status">Status Colors</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 15px;">
                        <button class="btn btn-primary" onclick="updateGlobalChart()">üé® Generate Chart</button>
                        <button class="btn btn-success" onclick="exportChartImage()">üíæ Save as Image</button>
                        <button class="btn" onclick="exportChartDataCSV()">üìÑ Export Data (CSV)</button>
                    </div>
                </div>

                <!-- Chart Display Area -->
                <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <div id="chart-title" style="text-align: center; font-size: 1.1em; font-weight: bold; color: #1e3c72; margin-bottom: 15px;">
                        Select options and click Generate Chart
                    </div>
                    <div class="chart-canvas-container">
                        <canvas id="global-chart"></canvas>
                    </div>
                </div>

                <!-- Statistics Panel -->
                <div id="chart-stats" style="background: #f8f9fa; padding: 15px; border-radius: 6px; display: none;"></div>

                <!-- Data Table -->
                <div id="chart-data-table" style="background: white; padding: 15px; border-radius: 6px; margin-top: 20px; display: none;">
                    <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">üìã Chart Data</h4>
                    <div style="overflow-x: auto;">
                        <table id="chart-table" style="width: 100%; font-size: 0.85em;">
                            <thead id="chart-table-head"></thead>
                            <tbody id="chart-table-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- SETTINGS Tab -->
        <div id="settings" class="tab-content">
            <div class="settings-panel">
                <div style="background: #fff3cd; border-left: 4px solid #f39c12; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                    <h4 style="color: #856404; margin-top: 0;">‚ö†Ô∏è Important: After Adding Columns to Google Sheets</h4>
                    <p style="color: #856404; margin: 0; font-size: 0.9em;">If you add new columns to your Google Sheets (like "Disqualification Reason"), you MUST republish the sheet:</p>
                    <ol style="color: #856404; margin: 10px 0 0 20px; font-size: 0.9em;">
                        <li>In Google Sheets: <strong>File ‚Üí Share ‚Üí Publish to web</strong></li>
                        <li>Click <strong>"Published content & settings"</strong></li>
                        <li>Click <strong>"Stop publishing"</strong> then <strong>"Publish"</strong> again</li>
                        <li>Copy the new CSV URL and paste it below</li>
                        <li>Click <strong>"Load All Data"</strong> to refresh</li>
                    </ol>
                </div>
                
                <div class="settings-section">
                    <h3>üìä Google Sheets Configuration</h3>
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9em;">Enter the URLs of your Google Sheets. Make sure each sheet is published to the web (File ‚Üí Share ‚Üí Publish to web ‚Üí CSV format).</p>
                    
                    <h4 style="margin: 15px 0 10px 0; color: #1e3c72;">AT Dataset</h4>
                    <div class="sheet-input-group">
                        <label>Master Data:</label>
                        <input type="text" id="sheet-at-master" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Paid from NYC:</label>
                        <input type="text" id="sheet-at-paid" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Payment Requests:</label>
                        <input type="text" id="sheet-at-requests" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>

                    <h4 style="margin: 15px 0 10px 0; color: #1e3c72;">AT NYC Dataset</h4>
                    <div class="sheet-input-group">
                        <label>Master Data:</label>
                        <input type="text" id="sheet-at-nyc-master" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Paid from NYC:</label>
                        <input type="text" id="sheet-at-nyc-paid" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Payment Requests:</label>
                        <input type="text" id="sheet-at-nyc-requests" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>

                    <h4 style="margin: 15px 0 10px 0; color: #1e3c72;">MBT Dataset</h4>
                    <div class="sheet-input-group">
                        <label>Master Data:</label>
                        <input type="text" id="sheet-mbt-master" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Paid from NYC:</label>
                        <input type="text" id="sheet-mbt-paid" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>
                    <div class="sheet-input-group">
                        <label>Payment Requests:</label>
                        <input type="text" id="sheet-mbt-requests" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>

                    <h4 style="margin: 15px 0 10px 0; color: #1e3c72;">üö∂ Walking Distance Data</h4>
                    <div class="sheet-input-group">
                        <label>Walking Data CSV:</label>
                        <input type="text" id="sheet-walking" placeholder="https://docs.google.com/..." onchange="saveSheetURLs()">
                    </div>

                    <button class="btn btn-success" onclick="loadAllData()">Load All Data</button>
                </div>
            </div>
        </div>
    </div>

    <div id="emailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìß Export Summons for Email</h2>
                <span class="close" onclick="closeEmailModal()">&times;</span>
            </div>
            <div id="emailModalBody">
                <!-- Email groups will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <script>
        // Global data storage
        const appData = {
            'at': { master: [], paid: [], requests: [], merged: [], filtered: [], currentPage: 1, pageSize: 'all', showExtra: false, lastRefreshSheets: null, lastRefreshNYC: null },
            'at-nyc': { master: [], paid: [], requests: [], merged: [], filtered: [], currentPage: 1, pageSize: 'all', showExtra: false, lastRefreshSheets: null, lastRefreshNYC: null },
            'mbt': { master: [], paid: [], requests: [], merged: [], filtered: [], currentPage: 1, pageSize: 'all', showExtra: false, lastRefreshSheets: null, lastRefreshNYC: null }
        };

        const sheetURLs = {
            'at': { 
                master: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ1o9qMz_zElO_r9I5ViHfeBmRQCv46NiecZoLDAOG76oojqjMnkd2Sy1MWZFYDYyE5RJ7OpFZXQ9Vb/pub?output=csv', 
                paid: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTwItpq2AsDCUfw9cEkRGe3E9JqXmIKQXztaXJSXiM4M6u1kwTzfszMAw3CgKXCa8tteoidy0MyMMoh/pub?output=csv', 
                requests: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS6Z2wJLGR3zBW0dSUxReBhrgzu0iKOpUURySRtnjL5R-7JJp_F8UCyqBO9kcJoJAmertKe7yQwuX31/pub?output=csv' 
            },
            'at-nyc': { 
                master: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRncTRjr3qqbr3n0iFhLr7kJ-1pwpVg9t1NJtR2RQFHsuq2QAQcyo75WgyQ1MVqZcY5gfDw2zy8jM67/pub?output=csv', 
                paid: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSKFvWDobRvxkaLQUZoVFh-YLag37CTTubJMRYS7KpS_Xv4a7ts3bhvdlU1s_mKiQY5FWKpaW7SjD2H/pub?output=csv', 
                requests: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT7mgKpDJmK_BbcK98IZUqUm2S5zk97nLdxndeVKAtOF5gjMzgjIGrSfm18fj5lFWEGgfJMJh8ZvmEC/pub?output=csv' 
            },
            'mbt': { 
                master: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQEdHNxEgIJnRElve2T6iUA-racSM-4Y871MGa6ruZ_Id8pGaENVZOAHRwOqNeypl7unfnSlHVgKnjK/pub?output=csv', 
                paid: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRBmD38Ggf3XOiDTgkmAjW0zOQfmTJyQTSxHFdj4GtgugY1L0ZO4gkgWvOcBT8OlgQ5TJSOL27_qM86/pub?output=csv', 
                requests: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTZtnehNQnyC0Zd794OvuYJtUVQFMou3IWUdnOQY491BNisPe3aIYvYHjsxJkTbtb_Eo9TW0H8u-Wzn/pub?output=csv' 
            },
            'walking': 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQDis10AgeTsR0vw5w27IMwiac1pDBAdIQ8MG8MpFwb4zL6HUodLowuB3BY6sQ-pyxH0s4SKceVIQWo/pub?output=csv'
        };

        let currentSortColumn = {};
        let currentSortDirection = {};
        let globalChart = null;
        let currentChartType = 'pie';
        let autoRefreshInterval = null;
        let filterDebounceTimers = {};
        let changeHistory = [];
        let currentChangeFilter = 'all';
        let mismatchesData = {}; // Store mismatches for PDF export

        const extraNYCFields = [
            'Violation Time', 'Issuing Agency', 'Respondent First Name', 'Respondent Last Name',
            'Balance Due', 'Violation Location (Borough)', 'Violation Location (House #)',
            'Violation Location (Street Name)', 'Hearing Result', 'Total Violation Amount', 'Charge Code'
        ];
        
        const defaultColumns = [
            'Complaint Number', 'Summons Number', 'Violation Date', 'Company Name',
            'Place of Occurrence', 'Status', 'Date Submitted', 'Hearing Date',
            'Paid Amount', 'Paid To Me', 'Payment Status', 'Payment Received',
            'Hearing Status', 'Hearing Result', 'Charge Code', 'Walking Distance', 'Disqualification Reason'
        ];

        const nycFieldMapping = {
            'ticket_number': 'Ticket Number',
            'violation_date': 'Violation Date',
            'respondent_last_name': 'Respondent Last Name',
            'paid_amount': 'Paid Amount',
            'hearing_status': 'Hearing Status',
            'hearing_date': 'Hearing Date',
            'violation_time': 'Violation Time',
            'issuing_agency': 'Issuing Agency',
            'respondent_first_name': 'Respondent First Name',
            'balance_due': 'Balance Due',
            'violation_location_borough': 'Violation Location (Borough)',
            'violation_location_house': 'Violation Location (House #)',
            'violation_location_street_name': 'Violation Location (Street Name)',
            'hearing_result': 'Hearing Result',
            'total_violation_amount': 'Total Violation Amount'
        };

        const companyNameMapping = {
            'A&L CESSPOOL SERVICE CORP': 'AL CESSPOOL SERVICE',
            'A.B.R. PLUMBING': 'ABR PLUMBING',
            'AB ONE': 'AB ONE',
            'ABBEY LOCKSMITHS': 'ABBEY LOCKSMITHS',
            'ABBEY LOCKSMITHS INC.': 'ABBEY LOCKSMITHS',
            'ABR PLUMBING': 'ABR PLUMBING',
            'ACV ENVIRONMENTAL SERVICES INC': 'ACV ENVIRONMENTAL SERVICES',
            'ADVANCE': 'ADVANCE',
            'ADVANCED ELECTRONIC SOLUTIONS INC': 'ADVANCED ELECTRONIC SOLUTIONS',
            'ADVANCED ELECTRONIC SOLUTIONS INC.': 'ADVANCED ELECTRONIC SOLUTIONS',
            'AGILITY CABLE': 'AGILITY CABLE',
            'AGILITY CABLE INC': 'AGILITY CABLE',
            'AINSWORTH': 'AINSWORTH',
            'AINSWORTH INC': 'AINSWORTH',
            'ALL CITY METAL': 'ALL CITY METAL',
            'ALL CITY METAL INC': 'ALL CITY METAL',
            'ALLNET TECHNOLOGY SOLUTION CORP': 'ALLNET TECHNOLOGY SOLUTION',
            'ALLNET TECHNOLOGY SOLUTION CORP.': 'ALLNET TECHNOLOGY SOLUTION',
            'AMAZON LOGISTICS INC': 'AMAZON LOGISTICS',
            'AMAZON LOGISTICS INC.': 'AMAZON LOGISTICS',
            'AMERICOLD': 'AMERICOLD',
            'AMERICOLD INC': 'AMERICOLD',
            'BALDOR EXPRESS TRANSPORTATION CO': 'BALDOR EXPRESS TRANSPORTATION',
            'BALDOR EXPRESS TRANSPORTATION CO LLC': 'BALDOR EXPRESS TRANSPORTATION',
            'BARN RENTALS': 'BARN RENTALS',
            'BELLA BUS CORP': 'BELLA BUS',
            'BELLA BUS CORP.': 'BELLA BUS',
            'BLUETRITON BRANDS INC': 'BLUETRITON BRANDS',
            'BLUETRITON BRANDS INC.': 'BLUETRITON BRANDS',
            'BROADWAY PARTY RENTALS': 'BROADWAY PARTY RENTALS',
            'BUCKMILLER AUTOMATIC SPRINKLER CORP': 'BUCKMILLER AUTOMATIC SPRINKLER',
            'C & J XPRESS CORP': 'C J XPRESS',
            'C & J XPRESS CORP.': 'C J XPRESS',
            'C.C. RENTAL': 'CC RENTAL',
            'CC RENTAL': 'CC RENTAL',
            'COURIER CAR RENTAL': 'CC RENTAL',
            'COURIER CAR RENTAL INC': 'CC RENTAL',
            'COURIER CAR RENTAL INC.': 'CC RENTAL',
            'CDM TRUCKING CORP': 'CDM TRUCKING',
            'CENTURY ELEVATOR': 'CENTURY ELEVATOR',
            'CHAMPION ELEVATOR': 'CHAMPION ELEVATOR',
            'CHARTER COMMUNICATIONS LLC': 'CHARTER COMMUNICATIONS',
            'CITIWAVE TRADING INC': 'CITIWAVE TRADING',
            'CITIWAVE TRADING INC.': 'CITIWAVE TRADING',
            'CLANCY MOVING SYSTEMS INC': 'CLANCY MOVING SYSTEMS',
            'CLEAN AIR GROUP': 'CLEAN AIR GROUP',
            'CLEAN AIR GROUP INC': 'CLEAN AIR GROUP',
            
            // FIXED: All Con Edison variations now map to one name
            'CONSOLIDATED EDISON COMPANY OF NEW YORK INC': 'CON EDISON',
            'CONSOLIDATED EDISON COMPANY OF NEW YORK INC.': 'CON EDISON',
            'CONSOLIDATED EDISON COMPANY OF NEW YORK, INC.': 'CON EDISON',
            'CONSOLIDATED EDISON COMPANY OF NY INC': 'CON EDISON',
            'CONSOLIDATED EDISON COMPANY OF NY INC.': 'CON EDISON',
            'CONSOLIDATED EDISON': 'CON EDISON',
            'CON EDISON': 'CON EDISON',
            'CON ED': 'CON EDISON',
            'CONED': 'CON EDISON',
            
            'CORNERSTONE CONTRACTING INC': 'CORNERSTONE CONTRACTING',
            'CORNERSTONE CONTRACTING, INC': 'CORNERSTONE CONTRACTING',
            'CORPORATE COFFEE SYSTEMS': 'CORPORATE COFFEE SYSTEMS',
            'CREATIVE GRAIN': 'CREATIVE GRAIN',
            'CREATIVE GRAIN LLC': 'CREATIVE GRAIN',
            'CROSS FIRE & SECURITY': 'CROSS FIRE SECURITY',
            'CROSS FIRE & SECURITY CO INC.': 'CROSS FIRE SECURITY',
            'CYM TRANSPORTATION INC': 'CYM TRANSPORTATION',
            'CYM TRANSPORTATION INC.': 'CYM TRANSPORTATION',
            'DATA-STRUCTION INC': 'DATA-STRUCTION',
            'DATA-STRUCTION INC.': 'DATA-STRUCTION',
            'DEPENDABLE GLASS & MIRROR': 'DEPENDABLE GLASS MIRROR',
            'DONNELLY MECHANICAL': 'DONNELLY MECHANICAL',
            'DONNELLY MECHANICAL CORP': 'DONNELLY MECHANICAL',
            'DONNELLY MECHANICAL INC': 'DONNELLY MECHANICAL',
            'DRAIN KLEEN SEWER SERVICE INC': 'DRAIN KLEEN SEWER SERVICE',
            'EAN HOLDINGS LLC': 'EAN HOLDINGS',
            'EAN HOLDINGS, LLC': 'EAN HOLDINGS',
            'EDGE AUTO INC': 'EDGE AUTO',
            'EDGE AUTO INC.': 'EDGE AUTO',
            'EDGE AUTO RENTAL': 'EDGE AUTO RENTAL',
            'ELDORADO': 'ELDORADO',
            'FEDERAL EXPRESS CORP': 'FEDERAL EXPRESS',
            'FEDERAL EXPRESS CORPORATION': 'FEDERAL EXPRESS',
            'FEDEX': 'FEDEX',
            'FEDEX GROUND PACKAGE SYSTEM INC': 'FEDEX GROUND PACKAGE SYSTEM',
            'FEDEX GROUND PACKAGE SYSTEM INC.': 'FEDEX GROUND PACKAGE SYSTEM',
            'FIRE RESPONSE INC': 'FIRE RESPONSE',
            'FIRE RESPONSE INC.': 'FIRE RESPONSE',
            'FIRSTLINE LOCKSMITH': 'FIRSTLINE LOCKSMITH',
            'FIRSTLINE LOCKSMITH LLC': 'FIRSTLINE LOCKSMITH',
            'GC PLUMBING & HEATING': 'GC PLUMBING HEATING',
            'GO NEW YORK TOURS': 'GO NEW YORK TOURS',
            'GO NEW YORK TOURS INC': 'GO NEW YORK TOURS',
            'GRAND PRIX TRADING CORP': 'GRAND PRIX TRADING',
            'GTSD TRANSPORT LLC': 'GTSD TRANSPORT',
            'HADDAD\'S INC': 'HADDAD\'S',
            'HARVARD MAINTENANCE INC': 'HARVARD MAINTENANCE',
            'HERCULES': 'HERCULES',
            'HERCULES CORP.': 'HERCULES',
            'HIGHBURY CONCRETE': 'HIGHBURY CONCRETE',
            'HJV ENTERPRISE': 'HJV ENTERPRISE',
            'HJV ENTERPRISE INC': 'HJV ENTERPRISE',
            'HUB TRUCK RENTAL': 'HUB TRUCK RENTAL',
            'HUB TRUCK RENTAL CORP': 'HUB TRUCK RENTAL',
            'HUB TRUCK RENTAL INC': 'HUB TRUCK RENTAL',
            'HUGH O\'KANE ELECTRIC CO INC': 'HUGH O\'KANE ELECTRIC',
            'HUGH O\'KANE ELECTRIC CO. INC.': 'HUGH O\'KANE ELECTRIC',
            'INDUSTRIAL COOLING INC': 'INDUSTRIAL COOLING',
            'INDUSTRIAL COOLING, INC': 'INDUSTRIAL COOLING',
            'INDUSTRIAL SOLUTIONS OF NY INC': 'INDUSTRIAL SOLUTIONS OF NY',
            'INDUSTRIAL SOLUTIONS OF NY, INC': 'INDUSTRIAL SOLUTIONS OF NY',
            'INTEGRITY SCAFFOLD SERVICE GROUP': 'INTEGRITY SCAFFOLD SERVICE GROUP',
            'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES': 'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES',
            'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES INC': 'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES',
            'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES, INC': 'IRON MOUNTAIN INFORMATION MANAGEMENT SERVICES',
            'JDP MECHANICAL': 'JDP MECHANICAL',
            'JDP MECHANICAL INC': 'JDP MECHANICAL',
            'JEROME ALUMINUM PRODUCTS': 'JEROME ALUMINUM PRODUCTS',
            'JEROME ALUMINUM PRODUCTS CORPORATION': 'JEROME ALUMINUM PRODUCTS',
            'JOVIN DEMO': 'JOVIN DEMO',
            'JOVIN DEMO INCORPORATED': 'JOVIN DEMO',
            'JTC PAINTING & DECORATING CORP': 'JTC PAINTING DECORATING',
            'JTC PAINTING DECORATING CORP': 'JTC PAINTING DECORATING',
            'KONE': 'KONE',
            'KONE INC': 'KONE',
            'KONE INC.': 'KONE',
            'KP MEC INC': 'KP MEC',
            'LEARDON BOILER WORKS INC': 'LEARDON BOILER WORKS',
            'LEYVA TRANSPORTATION CORP': 'LEYVA TRANSPORTATION',
            'LEYVA TRANSPORTATION CORP.': 'LEYVA TRANSPORTATION',
            'LIDO STONE WORKS': 'LIDO STONE WORKS',
            'LIDO STONE WORKS LLC': 'LIDO STONE WORKS',
            'MAK-STAR LLC': 'MAK-STAR',
            'MAQUETTE FINE ART SERVICES': 'MAQUETTE FINE ART SERVICES',
            'MAQUETTE FINE ART SERVICES LLC': 'MAQUETTE FINE ART SERVICES',
            'MARCELL TRANSPORT LLC': 'MARCELL TRANSPORT',
            'MERCHANTS AUTOMOTIVE GROUP INC': 'MERCHANTS AUTOMOTIVE GROUP',
            'MERCHANTS AUTOMOTIVE GROUP INC.': 'MERCHANTS AUTOMOTIVE GROUP',
            'MJJ SERVICE INC': 'MJJ SERVICE',
            'MJJ SERVICE, INC.': 'MJJ SERVICE',
            'MTLR CORP': 'MTLR',
            'NEPTUNE MACHINE': 'NEPTUNE MACHINE',
            'NEPTUNE MACHINE INC': 'NEPTUNE MACHINE',
            'NOUVEAU ELEVATOR': 'NOUVEAU ELEVATOR',
            'PENSKE LEASING & RENTAL CO': 'PENSKE LEASING RENTAL',
            'PENSKE LEASING & RENTAL CO.': 'PENSKE LEASING RENTAL',
            'PENSKE TRUCK LEASING CORPORATION': 'PENSKE TRUCK LEASING',
            'PIECE OF CAKE MOVING + STORAGE': 'PIECE OF CAKE MOVING + STORAGE',
            'PIECE OF CAKE MOVING + STORAGE LLC': 'PIECE OF CAKE MOVING + STORAGE',
            'PINK PINK TRADING INC': 'PINK PINK TRADING',
            'PRECISION PIPELINE SOLUTIONS': 'PRECISION PIPELINE SOLUTIONS',
            'PRECISION PIPELINE SOLUTIONS, LLC': 'PRECISION PIPELINE SOLUTIONS',
            'PRESTIGIOUS MAINTENANCE': 'PRESTIGIOUS MAINTENANCE',
            'PRESTIGIOUS MAINTENANCE INC': 'PRESTIGIOUS MAINTENANCE',
            'PRIDE & SERVICE ELEVATOR': 'PRIDE SERVICE ELEVATOR',
            'PRIDE & SERVICE ELEVATOR CO INC': 'PRIDE SERVICE ELEVATOR',
            'PRIDE TRANSPORTATION SERVICES INC': 'PRIDE TRANSPORTATION SERVICES',
            'PRO AIR MECHANICAL': 'PRO AIR MECHANICAL',
            'PRO AIR MECHANICAL CORP': 'PRO AIR MECHANICAL',
            'RAEL FIRE PROTECTION': 'RAEL FIRE PROTECTION',
            'RIVIERA PRODUCE': 'RIVIERA PRODUCE',
            'RIVIERA PRODUCE CORP': 'RIVIERA PRODUCE',
            'RX ELECTRIC': 'RX ELECTRIC',
            'RYDER TRUCK RENTAL INC': 'RYDER TRUCK RENTAL',
            'RYDER TRUCK RENTAL INC.': 'RYDER TRUCK RENTAL',
            'RYDER TRUCK RENTAL LTD': 'RYDER TRUCK RENTAL',
            'SAFWAY ATLANTIC': 'SAFWAY ATLANTIC',
            'SAFWAY ATLANTIC LLC': 'SAFWAY ATLANTIC',
            'SALEM TRUCK LEASING INC': 'SALEM TRUCK LEASING',
            'SALEM TRUCK LEASING INC.': 'SALEM TRUCK LEASING',
            'SCHINDLER ELEVATOR': 'SCHINDLER ELEVATOR',
            'SECURITY PRO NY INC': 'SECURITY PRO NY',
            'SECURITY PRO NY INC.': 'SECURITY PRO NY',
            'SOVEREIGN SERVICE': 'SOVEREIGN SERVICE',
            'SOVEREIGN SERVICE CORP': 'SOVEREIGN SERVICE',
            'STAGE CALL CORPORATION': 'STAGE CALL',
            'SUNBELT RENTALS': 'SUNBELT RENTALS',
            'SUNBELT RENTALS INC': 'SUNBELT RENTALS',
            'SUPERIOR PLUMBING HEATING MECHANICAL': 'SUPERIOR PLUMBING HEATING MECHANICAL',
            'SUPERIOR PLUMBING, HEATING & MECHANICAL LLC': 'SUPERIOR PLUMBING HEATING MECHANICAL',
            'SYSTEMS 2000 PLUMBING SERVICE': 'SYSTEMS 2000 PLUMBING SERVICE',
            'SYSTEMS 2000 PLUMBING SERVICE INC': 'SYSTEMS 2000 PLUMBING SERVICE',
            'TAEIL ENTERPRISE INC': 'TAEIL ENTERPRISE',
            'TAEIL ENTERPRISE LLC': 'TAEIL ENTERPRISE',
            'TEAM ELECTRIC': 'TEAM ELECTRIC',
            'TEAM ELECTRIC INC': 'TEAM ELECTRIC',
            'TOUCH UP CLEANING': 'TOUCH UP CLEANING',
            'TRI-STAR PLUMBING & HEATING': 'TRI-STAR PLUMBING HEATING',
            'U-HAUL CO OF NEW YORK AND VERMONT': 'U-HAUL CO OF NEW YORK AND VERMONT',
            'U-HAUL CO OF NEW YORK AND VERMONT INC': 'U-HAUL CO OF NEW YORK AND VERMONT',
            'U-HAUL CO. OF NEW YORK AND VERMONT INC.': 'U-HAUL CO OF NEW YORK AND VERMONT',
            'U-HAUL CO. OF NEW YORK AND VERMONT, INC.': 'U-HAUL CO OF NEW YORK AND VERMONT',
            'U.T.F. TRUCKING INC.': 'UTF TRUCKING',
            'UHAUL': 'UHAUL',
            'UNITED VAN LINES': 'UNITED VAN LINES',
            'UNITED VAN LINES LLC': 'UNITED VAN LINES',
            'UPRIGHT INSTALLATIONS': 'UPRIGHT INSTALLATIONS',
            'UPRIGHT INSTALLATIONS INC': 'UPRIGHT INSTALLATIONS',
            'UTF TRUCKING': 'UTF TRUCKING',
            'VALLE TRANSPORTATION SERVICE': 'VALLE TRANSPORTATION SERVICE',
            'VALLE TRANSPORTATION SERVICE LLC': 'VALLE TRANSPORTATION SERVICE',
            'VERIZON BUSINESS NETWORK SERVICES LLC': 'VERIZON BUSINESS NETWORK SERVICES',
            'VIXXO': 'VIXXO'
        };
        
        // Normalize company names to group variations together
        function normalizeCompanyName(companyName) {
            if (!companyName) return 'Unknown';
            
            const normalized = companyName.toUpperCase().trim();
            
            // Check if there's a mapping for this company
            if (companyNameMapping[normalized]) {
                return companyNameMapping[normalized];
            }
            
            // Return the normalized (uppercase) version for consistency
            return normalized;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            // Convert to string if it's a Date object
            if (dateStr instanceof Date) {
                dateStr = dateStr.toISOString();
            }
            // Ensure it's a string
            dateStr = String(dateStr);
            return dateStr.replace(/T\d{2}:\d{2}:\d{2}\.\d{3}/, '');
        }

        function toggleExtraColumns(tab) {
            appData[tab].showExtra = document.getElementById(`${tab}-show-extra`).checked;
            renderTable(tab);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function debouncedApplyFilters(tab) {
            if (filterDebounceTimers[tab]) {
                clearTimeout(filterDebounceTimers[tab]);
            }
            filterDebounceTimers[tab] = setTimeout(() => {
                applyFilters(tab);
            }, 300);
        }

        function getColumns(tab) {
            const filteredData = appData[tab].filtered;
            if (filteredData.length === 0) return [];

            const allColumnsSet = new Set();
            filteredData.forEach(row => {
                Object.keys(row).forEach(col => {
                    if (!col.startsWith('_')) {
                        allColumnsSet.add(col);
                    }
                });
            });
            let allColumns = Array.from(allColumnsSet);
            
            let columns = [];
            
            if (!appData[tab].showExtra) {
                // Always include columns from defaultColumns that exist in data
                columns = defaultColumns.filter(col => allColumns.includes(col));
                // Always include Disqualification Reason even if empty in data
                if (!columns.includes('Disqualification Reason')) {
                    columns.push('Disqualification Reason');
                }
            } else {
                columns = defaultColumns.filter(col => allColumns.includes(col));
                // Always include Disqualification Reason even if empty in data
                if (!columns.includes('Disqualification Reason')) {
                    columns.push('Disqualification Reason');
                }
                extraNYCFields.forEach(field => {
                    if (!columns.includes(field)) {
                        columns.push(field);
                    }
                });
            }

            return columns;
        }

        window.onload = function() {
            loadSheetURLs();
            loadFromStorage();
            loadChangeHistory();
            startAutoRefresh();
            
            // Ensure tables render after page is fully loaded
            setTimeout(() => {
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    if (appData[tab].merged.length > 0) {
                        console.log(`Rendering ${tab} table with ${appData[tab].merged.length} rows`);
                        renderTable(tab);
                    }
                });
                
                // Also render all tabs here since data should be loaded from storage by now
                console.log('=== RENDERING ALL TABS AFTER PAGE LOAD ===');
                if (appData['at'] && appData['at'].merged && appData['at'].merged.length > 0) {
                    renderNewMoney();
                    renderPendingPayments();
                    renderChangesView();
                    updateInsightsDatasetInfo();
                    populateWalkingInsights();
                    populateViolationTypes();
                    populateBestDayOfWeek();
                    console.log('=== ALL TABS RENDERED AFTER PAGE LOAD ===');
                } else {
                    console.log('No data loaded yet, skipping tab rendering');
                }
            }, 500); // Increased timeout to ensure data is loaded
        };

        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            autoRefreshInterval = setInterval(() => {
                loadAllData(true);
            }, 300000);
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            
            const tabElement = document.getElementById(tabName);
            if (tabElement) tabElement.classList.add('active');
            
            // Find and activate clicked button
            document.querySelectorAll('.tab-button').forEach(btn => {
                if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(tabName)) {
                    btn.classList.add('active');
                }
            });

            if (tabName === 'new-money') {
                // Render New Money when switching to this tab
                renderNewMoney();
                renderPendingPayments();
            } else if (tabName === 'changes') {
                // Render Changes when switching to this tab
                renderChangesView();
            } else if (tabName === 'insights') {
                // Render Insights when switching to this tab
                updateInsightsDatasetInfo();
                populateWalkingInsights();
                populateViolationTypes();
                populateBestDayOfWeek();
            } else if (tabName === 'time-analysis') {
                // Time analysis needs to be re-rendered when switching to it
                // because it depends on current month/year selection
                initializeTimeAnalysis();
                generateTimeAnalysis();
            } else if (tabName === 'distance') {
                // Render distance calendar when switching to this tab
                generateDistanceCalendar();
            }
        }

        function toggleFilters(tab) {
            const filtersDiv = document.getElementById(`${tab}-filters`);
            const icon = document.getElementById(`${tab}-filters-icon`);
            
            if (filtersDiv.classList.contains('show')) {
                filtersDiv.classList.remove('show');
                icon.classList.remove('open');
            } else {
                filtersDiv.classList.add('show');
                icon.classList.add('open');
            }
        }

        function convertToCSVUrl(url) {
            if (!url) return '';
            if (url.includes('pub?output=csv') || url.includes('export?format=csv')) {
                return url;
            }
            const match = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
            if (match) {
                const sheetId = match[1];
                return `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
            }
            return url;
        }

        async function fetchWithCORS(url) {
            try {
                const response = await fetch(url);
                if (response.ok) {
                    return await response.text();
                }
            } catch (error) {
                console.log('Direct fetch failed, trying CORS proxy...');
            }

            const corsProxies = [
                `https://corsproxy.io/?${encodeURIComponent(url)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
            ];

            for (const proxyUrl of corsProxies) {
                try {
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                        return await response.text();
                    }
                } catch (error) {
                    console.log('Proxy failed:', error.message);
                }
            }

            throw new Error('Failed to fetch from Google Sheets');
        }

        function saveSheetURLs() {
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                sheetURLs[tab].master = document.getElementById(`sheet-${tab}-master`).value;
                sheetURLs[tab].paid = document.getElementById(`sheet-${tab}-paid`).value;
                sheetURLs[tab].requests = document.getElementById(`sheet-${tab}-requests`).value;
            });
            sheetURLs.walking = document.getElementById('sheet-walking').value;
            localStorage.setItem('sheetURLs', JSON.stringify(sheetURLs));
        }

        function loadSheetURLs() {
            const saved = localStorage.getItem('sheetURLs');
            if (saved) {
                const loaded = JSON.parse(saved);
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    if (loaded[tab]) {
                        sheetURLs[tab] = loaded[tab];
                        if (sheetURLs[tab].master) document.getElementById(`sheet-${tab}-master`).value = sheetURLs[tab].master;
                        if (sheetURLs[tab].paid) document.getElementById(`sheet-${tab}-paid`).value = sheetURLs[tab].paid;
                        if (sheetURLs[tab].requests) document.getElementById(`sheet-${tab}-requests`).value = sheetURLs[tab].requests;
                    }
                });
                if (loaded.walking) {
                    sheetURLs.walking = loaded.walking;
                    document.getElementById('sheet-walking').value = sheetURLs.walking;
                }
            }
        }

        // ===== CHANGE TRACKING FUNCTIONS =====
        function detectChanges(oldData) {
            const timestamp = new Date().toISOString();
            const changes = [];

            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                const oldRecords = oldData[tab] || [];
                const newRecords = appData[tab].merged;

                // Create maps for faster lookup
                const oldMap = {};
                oldRecords.forEach(row => {
                    const summonsNum = (row['Summons Number'] || '').trim();
                    if (summonsNum) oldMap[summonsNum] = row;
                });

                const newMap = {};
                newRecords.forEach(row => {
                    const summonsNum = (row['Summons Number'] || '').trim();
                    if (summonsNum) newMap[summonsNum] = row;
                });

                // Detect new summonses
                Object.keys(newMap).forEach(summonsNum => {
                    if (!oldMap[summonsNum]) {
                        changes.push({
                            timestamp: timestamp,
                            dataset: tab.toUpperCase(),
                            type: 'new',
                            summonsNumber: summonsNum,
                            companyName: newMap[summonsNum]['Company Name'] || 'Unknown',
                            description: 'New summons added',
                            details: {
                                violationDate: newMap[summonsNum]['Violation Date'],
                                status: newMap[summonsNum]['Status']
                            }
                        });
                    }
                });

                // Detect changes in existing summonses
                Object.keys(oldMap).forEach(summonsNum => {
                    if (newMap[summonsNum]) {
                        const oldRow = oldMap[summonsNum];
                        const newRow = newMap[summonsNum];

                        // Check for Status changes
                        const oldStatus = (oldRow['Status'] || '').trim();
                        const newStatus = (newRow['Status'] || '').trim();
                        if (oldStatus !== newStatus && newStatus) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'status',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Status changed',
                                details: {
                                    from: oldStatus || 'None',
                                    to: newStatus
                                }
                            });
                        }

                        // Check for Payment Status changes
                        const oldPaymentStatus = (oldRow['Payment Status'] || '').trim();
                        const newPaymentStatus = (newRow['Payment Status'] || '').trim();
                        if (oldPaymentStatus !== newPaymentStatus) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'status',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Payment status changed',
                                details: {
                                    from: oldPaymentStatus || 'Unpaid',
                                    to: newPaymentStatus || 'Unpaid'
                                }
                            });
                        }

                        // Check for Hearing Status changes
                        const oldHearingStatus = (oldRow['Hearing Status'] || '').trim();
                        const newHearingStatus = (newRow['Hearing Status'] || '').trim();
                        if (oldHearingStatus !== newHearingStatus && newHearingStatus) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'status',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Hearing status changed',
                                details: {
                                    from: oldHearingStatus || 'None',
                                    to: newHearingStatus
                                }
                            });
                        }

                        // Check for Hearing Result changes
                        const oldHearingResult = (oldRow['Hearing Result'] || '').trim();
                        const newHearingResult = (newRow['Hearing Result'] || '').trim();
                        if (oldHearingResult !== newHearingResult && newHearingResult) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'status',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Hearing result changed',
                                details: {
                                    from: oldHearingResult || 'None',
                                    to: newHearingResult
                                }
                            });
                        }

                        // Check for Paid Amount changes
                        const oldPaidAmount = parseFloat((oldRow['Paid Amount'] || '0').replace(/[$,]/g, ''));
                        const newPaidAmount = parseFloat((newRow['Paid Amount'] || '0').replace(/[$,]/g, ''));
                        if (!isNaN(oldPaidAmount) && !isNaN(newPaidAmount) && oldPaidAmount !== newPaidAmount) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'payment',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Paid amount changed',
                                details: {
                                    from: `$${oldPaidAmount.toFixed(2)}`,
                                    to: `$${newPaidAmount.toFixed(2)}`,
                                    difference: `${newPaidAmount > oldPaidAmount ? '+' : ''}$${(newPaidAmount - oldPaidAmount).toFixed(2)}`
                                }
                            });
                        }

                        // Check for Balance Due changes
                        const oldBalanceDue = parseFloat((oldRow['Balance Due'] || '0').replace(/[$,]/g, ''));
                        const newBalanceDue = parseFloat((newRow['Balance Due'] || '0').replace(/[$,]/g, ''));
                        if (!isNaN(oldBalanceDue) && !isNaN(newBalanceDue) && oldBalanceDue !== newBalanceDue) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'payment',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Balance due changed',
                                details: {
                                    from: `$${oldBalanceDue.toFixed(2)}`,
                                    to: `$${newBalanceDue.toFixed(2)}`,
                                    difference: `${newBalanceDue > oldBalanceDue ? '+' : ''}$${(newBalanceDue - oldBalanceDue).toFixed(2)}`
                                }
                            });
                        }

                        // Check for "Paid To Me" changes
                        const oldPaidToMe = parseFloat((oldRow['Paid To Me'] || '0').replace(/[$,]/g, ''));
                        const newPaidToMe = parseFloat((newRow['Paid To Me'] || '0').replace(/[$,]/g, ''));
                        if (!isNaN(newPaidToMe) && newPaidToMe > 0 && oldPaidToMe !== newPaidToMe) {
                            changes.push({
                                timestamp: timestamp,
                                dataset: tab.toUpperCase(),
                                type: 'payment',
                                summonsNumber: summonsNum,
                                companyName: newRow['Company Name'] || 'Unknown',
                                description: 'Payment received changed',
                                details: {
                                    from: `$${oldPaidToMe.toFixed(2)}`,
                                    to: `$${newPaidToMe.toFixed(2)}`,
                                    difference: `${newPaidToMe > oldPaidToMe ? '+' : ''}$${(newPaidToMe - oldPaidToMe).toFixed(2)}`
                                }
                            });
                        }
                    }
                });
            });

            // If there are 500+ changes, it's probably a data loading issue - skip logging
            if (changes.length >= 500) {
                console.log(`Skipping change tracking: ${changes.length} changes detected (likely data loading issue)`);
                return;
            }

            // Add changes to history
            if (changes.length > 0) {
                changeHistory.push({
                    refreshTime: timestamp,
                    changeCount: changes.length,
                    changes: changes
                });

                // Keep only last 50 refresh sessions
                if (changeHistory.length > 50) {
                    changeHistory = changeHistory.slice(-50);
                }

                saveChangeHistory();
                renderChangesView();
            }
        }

        function renderChangesView() {
            // Update summary cards
            let totalChanges = 0;
            let statusChanges = 0;
            let paymentChanges = 0;
            let newSummonses = 0;

            changeHistory.forEach(session => {
                session.changes.forEach(change => {
                    totalChanges++;
                    if (change.type === 'status') statusChanges++;
                    if (change.type === 'payment') paymentChanges++;
                    if (change.type === 'new') newSummonses++;
                });
            });

            document.getElementById('changes-total').textContent = totalChanges;
            document.getElementById('changes-status').textContent = statusChanges;
            document.getElementById('changes-payment').textContent = paymentChanges;
            document.getElementById('changes-new').textContent = newSummonses;

            // Update last refresh info
            if (changeHistory.length > 0) {
                const lastSession = changeHistory[changeHistory.length - 1];
                const refreshDate = new Date(lastSession.refreshTime);
                document.getElementById('last-refresh-time').textContent = refreshDate.toLocaleString();
                document.getElementById('last-refresh-changes').textContent = lastSession.changeCount;
            }

            // Render timeline
            renderChangesTimeline();
        }

        function renderChangesTimeline() {
            const timeline = document.getElementById('changes-timeline');
            
            if (changeHistory.length === 0) {
                timeline.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No changes tracked yet. Refresh your data to start tracking changes.</p>';
                return;
            }

            let html = '';

            // Filter changes based on current filter
            const filteredHistory = changeHistory.map(session => {
                if (currentChangeFilter === 'all') {
                    return session;
                }
                return {
                    ...session,
                    changes: session.changes.filter(change => change.type === currentChangeFilter)
                };
            }).filter(session => session.changes.length > 0);

            // Reverse to show most recent first
            filteredHistory.reverse().forEach((session, sessionIndex) => {
                const sessionDate = new Date(session.refreshTime);
                const isRecent = sessionIndex === 0;

                // Group changes by summons number and timestamp
                const groupedChanges = {};
                session.changes.forEach(change => {
                    const key = `${change.summonsNumber}_${change.timestamp}`;
                    if (!groupedChanges[key]) {
                        groupedChanges[key] = {
                            summonsNumber: change.summonsNumber,
                            companyName: change.companyName,
                            dataset: change.dataset,
                            timestamp: change.timestamp,
                            changes: []
                        };
                    }
                    groupedChanges[key].changes.push(change);
                });

                html += `
                    <div style="border-left: 3px solid ${isRecent ? '#27ae60' : '#3498db'}; padding-left: 15px; margin-bottom: 25px; position: relative;">
                        <div style="position: absolute; left: -8px; top: 0; width: 13px; height: 13px; border-radius: 50%; background: ${isRecent ? '#27ae60' : '#3498db'}; border: 3px solid white;"></div>
                        <div style="background: ${isRecent ? '#d4edda' : '#e8f4f8'}; padding: 10px; border-radius: 4px; margin-bottom: 12px;">
                            <div style="font-weight: bold; color: #1e3c72; font-size: 0.9em;">
                                üìÖ ${sessionDate.toLocaleString()}
                            </div>
                            <div style="color: #666; font-size: 0.85em; margin-top: 4px;">
                                ${Object.keys(groupedChanges).length} summons${Object.keys(groupedChanges).length !== 1 ? 'es' : ''} with changes
                            </div>
                        </div>
                `;

                Object.values(groupedChanges).forEach(group => {
                    // Determine the primary type and color
                    const hasNew = group.changes.some(c => c.type === 'new');
                    const hasStatus = group.changes.some(c => c.type === 'status');
                    const hasPayment = group.changes.some(c => c.type === 'payment');
                    
                    const typeIcons = {
                        'new': '‚ú®',
                        'status': 'üîÑ',
                        'payment': 'üíµ'
                    };
                    const typeColors = {
                        'new': '#9b59b6',
                        'status': '#3498db',
                        'payment': '#f39c12'
                    };
                    
                    // Pick primary type/color based on priority
                    let primaryType = 'status';
                    if (hasNew) primaryType = 'new';
                    else if (hasPayment) primaryType = 'payment';
                    
                    const typeIcon = typeIcons[primaryType];
                    const typeColor = typeColors[primaryType];

                    html += `
                        <div style="background: white; padding: 12px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid ${typeColor}; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <div style="display: flex; gap: 10px; align-items: start;">
                                <div style="font-size: 1.3em; line-height: 1;">${typeIcon}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: #2c3e50; font-size: 0.85em; margin-bottom: 4px;">
                                        ${group.changes.length > 1 ? 'Multiple changes' : group.changes[0].description}
                                    </div>
                                    <div style="font-size: 0.8em; color: #666; margin-bottom: 6px;">
                                        <strong>Summons:</strong> ${group.summonsNumber} | 
                                        <strong>Company:</strong> ${group.companyName} | 
                                        <strong>Dataset:</strong> ${group.dataset}
                                    </div>
                    `;

                    // If multiple changes, show all details
                    if (group.changes.length > 1) {
                        html += '<div style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 3px; font-size: 0.8em;">';
                        group.changes.forEach((change, idx) => {
                            if (idx > 0) html += '<div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #dee2e6;"></div>';
                            html += `<div><strong>${change.description}:</strong> `;
                            
                            if (change.details) {
                                if (change.details.from !== undefined && change.details.to !== undefined) {
                                    html += `<span style="color: #e74c3c;">${change.details.from}</span>`;
                                    html += ` ‚Üí `;
                                    html += `<span style="color: #27ae60; font-weight: bold;">${change.details.to}</span>`;
                                    if (change.details.difference) {
                                        html += ` <span style="color: #666;">(${change.details.difference})</span>`;
                                    }
                                } else if (change.details.violationDate) {
                                    html += `${change.details.violationDate}`;
                                    if (change.details.status) html += ` | Status: ${change.details.status}`;
                                }
                            }
                            html += '</div>';
                        });
                        html += '</div>';
                    } else {
                        // Single change - show details inline
                        const change = group.changes[0];
                        if (change.details) {
                            if (change.details.from !== undefined && change.details.to !== undefined) {
                                html += `
                                    <div style="font-size: 0.8em; padding: 6px; background: #f8f9fa; border-radius: 3px;">
                                        <span style="color: #e74c3c;">${change.details.from}</span>
                                        <span style="margin: 0 6px;">‚Üí</span>
                                        <span style="color: #27ae60; font-weight: bold;">${change.details.to}</span>
                                `;
                                if (change.details.difference) {
                                    html += ` <span style="margin-left: 8px; color: #666;">(${change.details.difference})</span>`;
                                }
                                html += `</div>`;
                            } else if (change.details.violationDate) {
                                html += `
                                    <div style="font-size: 0.8em; color: #666;">
                                        <strong>Violation Date:</strong> ${change.details.violationDate}
                                        ${change.details.status ? ` | <strong>Status:</strong> ${change.details.status}` : ''}
                                    </div>
                                `;
                            }
                        }
                    }

                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `</div>`;
            });

            timeline.innerHTML = html;
        }

        function viewAllChanges() {
            currentChangeFilter = 'all';
            renderChangesTimeline();
        }

        function filterChangesByType(type) {
            currentChangeFilter = type;
            renderChangesTimeline();
        }

        function clearChangeHistory() {
            if (!confirm('Are you sure you want to clear all change history? This cannot be undone.')) {
                return;
            }
            changeHistory = [];
            saveChangeHistory();
            renderChangesView();
        }

        function saveChangeHistory() {
            try {
                localStorage.setItem('truckChanges', JSON.stringify(changeHistory));
            } catch (e) {
                console.error('Error saving change history:', e);
            }
        }

        function loadChangeHistory() {
            try {
                const saved = localStorage.getItem('truckChanges');
                if (saved) {
                    changeHistory = JSON.parse(saved);
                    renderChangesView();
                }
            } catch (e) {
                console.error('Error loading change history:', e);
            }
        }

        async function loadAllData(silent = false) {
            if (!silent) updateProgress('at', 0, 'Loading data from Google Sheets...');
            
            // Store snapshot of old data for change detection
            const oldData = {};
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                oldData[tab] = appData[tab].merged.map(row => ({...row}));
            });
            
            // Track which tabs successfully loaded
            const loadedTabs = [];
            let hasErrors = false;
            
            for (const tab of ['at', 'at-nyc', 'mbt']) {
                try {
                    // Create temporary storage for this tab's data
                    const tempData = {
                        master: [],
                        paid: [],
                        requests: []
                    };
                    
                    // Load all three sheets for this tab
                    if (sheetURLs[tab].master) {
                        if (!silent) updateProgress(tab, 20, `Loading ${tab} master data...`);
                        tempData.master = await fetchCSVFromSheet(convertToCSVUrl(sheetURLs[tab].master));
                        
                        // SHOW USER THE ACTUAL COLUMNS
                        if (tempData.master.length > 0) {
                            const columns = Object.keys(tempData.master[0]);
                            console.log(`\n========== ${tab.toUpperCase()} MASTER COLUMNS ==========`);
                            console.log('Columns found:', columns);
                            console.log('Column count:', columns.length);
                            console.log('Has "Disqualification Reason"?', columns.includes('Disqualification Reason'));
                            
                            // Check for similar column names
                            const similar = columns.filter(col => 
                                col.toLowerCase().includes('disq') || 
                                col.toLowerCase().includes('reason')
                            );
                            if (similar.length > 0) {
                                console.log('Similar columns found:', similar);
                            }
                            console.log('==============================================\n');
                        }
                    }
                    if (sheetURLs[tab].paid) {
                        if (!silent) updateProgress(tab, 40, `Loading ${tab} paid data...`);
                        tempData.paid = await fetchCSVFromSheet(convertToCSVUrl(sheetURLs[tab].paid));
                    }
                    if (sheetURLs[tab].requests) {
                        if (!silent) updateProgress(tab, 60, `Loading ${tab} requests data...`);
                        tempData.requests = await fetchCSVFromSheet(convertToCSVUrl(sheetURLs[tab].requests));
                    }
                    
                    // Only update appData if all sheets loaded successfully
                    appData[tab].master = tempData.master;
                    appData[tab].paid = tempData.paid;
                    appData[tab].requests = tempData.requests;
                    appData[tab].lastRefreshSheets = new Date().toISOString();
                    
                    if (!silent) updateProgress(tab, 70, `Merging ${tab} data...`);
                    mergeData(tab);
                    
                    if (!silent) updateProgress(tab, 80, `Enriching ${tab} from NYC...`);
                    await enrichFromNYC(tab, true);
                    
                    if (!silent) updateProgress(tab, 90, `Applying filters for ${tab}...`);
                    applyFilters(tab);
                    populateFilterDropdowns(tab);
                    
                    loadedTabs.push(tab);
                    if (!silent) updateProgress(tab, 100, `${tab} loaded successfully!`);
                    
                } catch (error) {
                    console.error(`Error loading ${tab}:`, error);
                    hasErrors = true;
                    if (!silent) {
                        alert(`Error loading ${tab}: ${error.message}\n\nThis tab's data may be incomplete. Other tabs will continue loading.`);
                    }
                    // Don't break - continue loading other tabs
                }
            }

            // Detect and log changes only for successfully loaded tabs
            if (loadedTabs.length > 0) {
                detectChanges(oldData);
            }

            // Load walking data for all dates with summons
            try {
                if (!silent) updateProgress('at', 90, 'Loading walking data...');
                const allDates = new Set();
                loadedTabs.forEach(tab => {
                    appData[tab].merged.forEach(row => {
                        const date = row['Violation Date'];
                        if (date) {
                            // Normalize date to YYYY-MM-DD format
                            const normalized = normalizeDate(date);
                            if (normalized) {
                                allDates.add(normalized);
                            }
                        }
                    });
                });
                console.log('Attempting to load walking data for', allDates.size, 'unique dates');
                if (allDates.size > 0) {
                    await loadWalkingDataForDates(Array.from(allDates));
                    console.log('Walking data loading complete');
                    
                    // Re-merge data to populate Walking Distance in merged rows
                    loadedTabs.forEach(tab => {
                        if (appData[tab].master.length > 0) {
                            mergeData(tab);
                        }
                    });
                    console.log('Data re-merged with walking distances');
                } else {
                    console.log('No dates found to load walking data for');
                }
            } catch (error) {
                console.error('Error loading walking data:', error);
                // Don't show alert - just log the error
            }

            saveToStorage();
            
            // Refresh calendars if user is currently viewing them
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                if (activeTab.id === 'time-analysis') {
                    console.log('Refreshing time analysis calendar after data load');
                    generateTimeAnalysis();
                } else if (activeTab.id === 'distance') {
                    console.log('Refreshing distance calendar after data load');
                    generateDistanceCalendar();
                }
            }
            
            // RENDER ALL TABS AT ONCE after data is fully loaded
            console.log('=== RENDERING ALL TABS AFTER DATA LOAD ===');
            renderNewMoney();
            renderPendingPayments();
            renderChangesView();
            updateInsightsDatasetInfo();
            populateWalkingInsights();
            populateViolationTypes();
            populateBestDayOfWeek();
            console.log('=== ALL TABS RENDERED ===');
            
            if (!silent) {
                updateProgress('at', 100, 'Data loaded successfully!');
                if (hasErrors) {
                    alert(`Data loading completed with some errors. ${loadedTabs.length} of 3 datasets loaded successfully.`);
                } else {
                    alert('All data loaded from Google Sheets!');
                }
            }
        }

        async function fetchCSVFromSheet(url) {
            const text = await fetchWithCORS(url);
            const parsed = parseCSV(text);
            return parsed;
        }

        function parseCSV(text) {
            const rows = [];
            let currentRow = [];
            let currentCell = '';
            let insideQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                if (char === '"') {
                    if (insideQuotes && nextChar === '"') {
                        currentCell += '"';
                        i++;
                    } else {
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    currentRow.push(currentCell.trim());
                    currentCell = '';
                } else if ((char === '\n' || char === '\r') && !insideQuotes) {
                    if (char === '\r' && nextChar === '\n') {
                        i++;
                    }
                    if (currentCell || currentRow.length > 0) {
                        currentRow.push(currentCell.trim());
                        if (currentRow.some(cell => cell.length > 0)) {
                            rows.push(currentRow);
                        }
                        currentRow = [];
                        currentCell = '';
                    }
                } else {
                    currentCell += char;
                }
            }
            
            if (currentCell || currentRow.length > 0) {
                currentRow.push(currentCell.trim());
                if (currentRow.some(cell => cell.length > 0)) {
                    rows.push(currentRow);
                }
            }
            
            if (rows.length === 0) return [];
            
            const headers = rows[0].map(h => h.trim());
            
            // DEBUG: Log all headers to see if Disqualification Reason is present
            console.log('CSV Headers found:', headers);
            console.log('Has Disqualification Reason?', headers.includes('Disqualification Reason'));
            
            const data = [];
            
            for (let i = 1; i < rows.length; i++) {
                const row = {};
                const values = rows[i];
                
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });
                
                // DEBUG: Log first 3 rows to see Disqualification Reason values
                if (i <= 3 && row['Disqualification Reason']) {
                    console.log(`Row ${i} Disqualification Reason:`, row['Disqualification Reason']);
                }
                
                const hasData = Object.values(row).some(val => val.length > 0);
                if (hasData) {
                    data.push(row);
                }
            }
            
            console.log('Parsed', data.length, 'data rows');
            
            return data;
        }

        function mergeData(tab) {
            console.log('=== mergeData called for', tab, '===');
            console.log('walkingDataCache has', Object.keys(walkingDataCache).length, 'dates');
            console.log('Sample cache dates:', Object.keys(walkingDataCache).slice(0, 10));
            
            const master = appData[tab].master;
            const paid = appData[tab].paid;
            const requests = appData[tab].requests;
            const existingMerged = appData[tab].merged || []; // Preserve existing merged data
            let debugMergeCount = 0;
            
            console.log(`${tab}: Preserving ${existingMerged.length} existing merged rows`);
            
            // Check if existing merged has NYC enrichment by finding first row WITH a summons number
            if (existingMerged.length > 0) {
                const sampleWithSummons = existingMerged.find(r => (r['Summons Number'] || '').trim());
                if (sampleWithSummons) {
                    console.log(`${tab}: Existing merged has Violation Date?`, !!sampleWithSummons['Violation Date']);
                    console.log(`${tab}: Existing merged has Hearing Status?`, !!sampleWithSummons['Hearing Status']);
                } else {
                    console.log(`${tab}: No rows with Summons Number found in existing merged`);
                }
            }
            
            // DEBUG: Check if master data has Disqualification Reason
            if (master.length > 0) {
                const firstRow = master[0];
                console.log('Master data columns:', Object.keys(firstRow));
                console.log('Has Disqualification Reason in master?', 'Disqualification Reason' in firstRow);
                if (firstRow['Disqualification Reason']) {
                    console.log('First row Disqualification Reason value:', firstRow['Disqualification Reason']);
                }
            }

            if (master.length === 0) {
                appData[tab].merged = [];
                return;
            }
            
            // Create a map of existing merged data by summons number to preserve NYC enrichment
            const existingMergedMap = {};
            existingMerged.forEach(row => {
                const summonsNum = (row['Summons Number'] || '').trim();
                if (summonsNum) {
                    existingMergedMap[summonsNum] = row;
                }
            });
            console.log(`${tab}: Created existingMergedMap with ${Object.keys(existingMergedMap).length} entries`);

            const paidMap = {};
            paid.forEach(row => {
                const summonsNum = row['Summons #'] || row['Summons Number'];
                if (summonsNum) paidMap[summonsNum.trim()] = row;
            });

            const requestsMap = {};
            requests.forEach(row => {
                const summonsNum = row['Complaint Number'] || row['Summons Number'];
                if (summonsNum) requestsMap[summonsNum.trim()] = row;
            });

            const merged = master.map(row => {
                const summonsNum = (row['Summons Number'] || '').trim();
                
                // Start with existing merged row if it exists (preserves NYC enrichment)
                // Otherwise start with master row
                const newRow = summonsNum && existingMergedMap[summonsNum] 
                    ? { ...existingMergedMap[summonsNum] } 
                    : { ...row };
                
                // Update ONLY master sheet fields (don't overwrite NYC enrichment)
                // Master fields are the ones that come from the Google Sheets master data
                const masterFields = ['Complaint Number', 'Created On', 'Company Name', 'Place of Occurrence', 
                                     'Status', 'Date Submitted', 'Summons Number', 'Hearing Date', 'Disqualification Reason'];
                masterFields.forEach(field => {
                    if (row[field] !== undefined) {
                        newRow[field] = row[field];
                    }
                });
                
                // Normalize company name for consistent grouping
                if (newRow['Company Name']) {
                    newRow['Company Name'] = normalizeCompanyName(newRow['Company Name']);
                }

                // Initialize fields if they don't exist (but don't overwrite if they do)
                if (!newRow['Paid Amount']) newRow['Paid Amount'] = '';
                if (!newRow['Hearing Status']) newRow['Hearing Status'] = '';

                // Check if status is "Submitted" - set initially but can be overridden
                const status = (row['Status'] || '').toLowerCase();
                const isSubmitted = status === 'submitted';
                
                if (isSubmitted) {
                    newRow['_rowType'] = 'submitted';
                }

                if (summonsNum && paidMap[summonsNum]) {
                    // Only override submitted if it's not submitted
                    if (!isSubmitted) {
                        newRow['_rowType'] = 'paid';
                    }
                    
                    const paidRow = paidMap[summonsNum];
                    Object.keys(paidRow).forEach(key => {
                        if (key !== 'Summons #' && key !== 'Summons Number') {
                            newRow[key] = paidRow[key];
                        }
                    });
                    
                    newRow['Payment Status'] = 'PAID TO ME';
                } else if (summonsNum && requestsMap[summonsNum]) {
                    // Only override submitted if it's not submitted
                    if (!isSubmitted) {
                        newRow['_rowType'] = 'requested';
                    }
                    
                    Object.keys(requestsMap[summonsNum]).forEach(key => {
                        if (key !== 'Complaint Number' && key !== 'Summons Number') {
                            newRow[key] = requestsMap[summonsNum][key];
                        }
                    });
                    newRow['Payment Status'] = 'REQUESTED';
                }
                
                // Check for dismissed or disqualified status - dismissed takes priority
                const hearingResult = (row['Hearing Result'] || newRow['Hearing Result'] || '').toLowerCase();
                if (hearingResult.includes('dismissed')) {
                    newRow['_rowType'] = 'dismissed';
                } else if (status.includes('disqualified')) {
                    newRow['_rowType'] = 'disqualified';
                }
                
                // Add walking distance and temperature for this date
                // IMPORTANT: Use Violation Date from NYC enrichment (already in newRow), fallback to Date Submitted
                const dateStr = newRow['Violation Date'] || newRow['Date Submitted'];
                const date = normalizeDate(dateStr);
                
                // Debug first 3 rows - show ALL fields
                if (debugMergeCount < 3) {
                    console.log('DEBUG ROW', debugMergeCount, 'Fields:', Object.keys(newRow).length, 'fields');
                    console.log('  Violation Date:', newRow['Violation Date']);
                    console.log('  Date Submitted:', newRow['Date Submitted']);
                    console.log('  Hearing Status:', newRow['Hearing Status']);
                    console.log('  Disqualification Reason:', newRow['Disqualification Reason']);
                    console.log('  Using:', dateStr, '-> normalized:', date);
                    debugMergeCount++;
                }
                
                if (date) {
                    const totalMiles = getTotalWalkingDistanceForDate(date);
                    const avgTemp = getAverageTemperatureForDate(date);
                    
                    if (debugMergeCount <= 3 && (totalMiles > 0 || avgTemp !== null)) {
                        console.log('  -> Found data for', date, 'Miles:', totalMiles, 'Temp:', avgTemp);
                    }
                    
                    newRow['Walking Distance'] = totalMiles > 0 ? totalMiles.toFixed(2) + ' mi' : '';
                    newRow['Temperature'] = avgTemp !== null ? avgTemp : '';
                } else {
                    newRow['Walking Distance'] = '';
                    newRow['Temperature'] = '';
                }

                return newRow;
            });

            appData[tab].merged = merged;
            
            // Summary
            const withWalkingDist = merged.filter(r => r['Walking Distance'] && r['Walking Distance'] !== '').length;
            const withTemp = merged.filter(r => r['Temperature'] && r['Temperature'] !== '').length;
            const withDisqReason = merged.filter(r => r['Disqualification Reason'] && r['Disqualification Reason'] !== '').length;
            const withViolationDate = merged.filter(r => r['Violation Date'] && r['Violation Date'] !== '').length;
            const withHearingStatus = merged.filter(r => r['Hearing Status'] && r['Hearing Status'] !== '').length;
            console.log('=== mergeData complete for', tab, '===');
            console.log('  Total rows:', merged.length);
            console.log('  Rows with Walking Distance:', withWalkingDist);
            console.log('  Rows with Temperature:', withTemp);
            console.log('  Rows with Disqualification Reason:', withDisqReason);
            console.log('  Rows with Violation Date:', withViolationDate);
            console.log('  Rows with Hearing Status:', withHearingStatus);
        }

        async function enrichFromNYC(tab, silent = false) {
            const data = appData[tab].merged;
            if (data.length === 0) return;

            try {
                const summonsNumbers = data.map(row => row['Summons Number']).filter(num => num && num.trim() !== '');
                if (summonsNumbers.length === 0) return;

                const batchSize = 50;
                const enrichedDataMap = {};
                let successfulBatches = 0;
                let failedBatches = 0;

                for (let i = 0; i < summonsNumbers.length; i += batchSize) {
                    try {
                        const batch = summonsNumbers.slice(i, i + batchSize);
                        const ticketNumbers = batch.map(num => `'${num}'`).join(',');
                        const url = `https://data.cityofnewyork.us/resource/jz4z-kudi.json?$where=ticket_number IN (${ticketNumbers})&$limit=1000`;

                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`NYC API returned ${response.status}`);
                        }
                        const nycData = await response.json();
                        
                        // Log first item to see what fields we're getting
                        if (nycData.length > 0 && i === 0) {
                            console.log(`NYC API returned ${nycData.length} results for first batch`);
                            console.log('Sample NYC record:', nycData[0]);
                            console.log('NYC fields:', Object.keys(nycData[0]));
                        }

                        nycData.forEach(item => {
                            enrichedDataMap[item.ticket_number] = item;
                        });
                        
                        successfulBatches++;
                    } catch (batchError) {
                        console.error(`Error fetching batch ${i}-${i+batchSize}:`, batchError);
                        failedBatches++;
                        // Continue with next batch even if this one fails
                    }
                }
                
                console.log(`NYC enrichment for ${tab}: ${successfulBatches} successful, ${failedBatches} failed batches`);

                // Only update merged data if we got at least some results
                if (Object.keys(enrichedDataMap).length > 0) {
                    let firstEnrichmentLogged = false;
                    appData[tab].merged = data.map(row => {
                        const summonsNum = (row['Summons Number'] || '').trim();
                        if (summonsNum && enrichedDataMap[summonsNum]) {
                            const nycRow = enrichedDataMap[summonsNum];
                            const enrichedRow = { ...row };
                            
                            // Save original Hearing Status before enrichment
                            const originalHearingStatus = row['Hearing Status'];
                            
                            let preservedHearingStatus = false;
                            let fieldsAdded = [];
                            
                            Object.keys(nycFieldMapping).forEach(apiField => {
                                const displayName = nycFieldMapping[apiField];
                                if (nycRow[apiField] !== undefined && nycRow[apiField] !== null) {
                                    // Don't overwrite Hearing Status if it's already "Paid in Full" in our data
                                    // Our Google Sheets data is more accurate for payment status
                                    if (displayName === 'Hearing Status' && 
                                        originalHearingStatus && 
                                        originalHearingStatus.toLowerCase() === 'paid in full') {
                                        // Keep the original value, don't overwrite
                                        preservedHearingStatus = true;
                                        console.log(`Preserving "Paid in Full" for ${summonsNum}, NYC has: "${nycRow[apiField]}"`);
                                        return;
                                    }
                                    enrichedRow[displayName] = nycRow[apiField];
                                    fieldsAdded.push(displayName);
                                }
                            });
                            
                            // Log first enrichment to see what fields are added
                            if (firstEnrichmentLogged === false) {
                                console.log(`First enrichment for ${tab}:`);
                                console.log(`  Summons: ${summonsNum}`);
                                console.log(`  Fields added:`, fieldsAdded);
                                console.log(`  Violation Date value:`, enrichedRow['Violation Date']);
                                console.log(`  Hearing Status value:`, enrichedRow['Hearing Status']);
                                firstEnrichmentLogged = true;
                            }
                            
                            // Add charge_1_code
                            if (nycRow.charge_1_code) {
                                enrichedRow['Charge Code'] = nycRow.charge_1_code;
                            }

                            // Re-check dismissed/disqualified status after enrichment since Hearing Result may have changed
                            const hearingResult = (enrichedRow['Hearing Result'] || '').toLowerCase();
                            const status = (enrichedRow['Status'] || '').toLowerCase();
                            if (hearingResult.includes('dismissed')) {
                                enrichedRow['_rowType'] = 'dismissed';
                            } else if (status.includes('disqualified')) {
                                enrichedRow['_rowType'] = 'disqualified';
                            }

                            return enrichedRow;
                        }
                        return row;
                    });

                    appData[tab].lastRefreshNYC = new Date().toISOString();
                    saveToStorage();
                } else {
                    console.warn(`No NYC data retrieved for ${tab}, skipping enrichment`);
                }
            } catch (error) {
                console.error(`Enrichment error for ${tab}:`, error);
                // Don't update appData if enrichment completely failed
            }
        }

        function refreshData(tab) {
            loadAllData();
        }

        function clearData(tab) {
            if (!confirm(`Clear all data for ${tab.toUpperCase()}?`)) return;
            appData[tab] = { master: [], paid: [], requests: [], merged: [], filtered: [], currentPage: 1, pageSize: 'all' };
            saveToStorage();
            applyFilters(tab);
        }

        function populateFilterDropdowns(tab) {
            const data = appData[tab].merged;
            
            const paymentStatuses = new Set();
            const companies = new Set();
            
            data.forEach(row => {
                if (row['Payment Status']) paymentStatuses.add(row['Payment Status']);
                if (row['Company Name']) companies.add(row['Company Name']);
            });

            const paymentSelect = document.getElementById(`${tab}-filter-payment-status`);
            paymentSelect.innerHTML = '<option value="">All Payment Status</option>';
            [...paymentStatuses].sort().forEach(status => {
                paymentSelect.innerHTML += `<option value="${status}">${status}</option>`;
            });

            const companySelect = document.getElementById(`${tab}-filter-company`);
            companySelect.innerHTML = '<option value="">All Companies</option>';
            [...companies].sort().forEach(company => {
                companySelect.innerHTML += `<option value="${company}">${company}</option>`;
            });
        }

        function applyFilters(tab) {
            const data = appData[tab].merged;
            
            // Defensive checks - if filter elements don't exist yet, use defaults
            const paidCheckbox = document.getElementById(`${tab}-filter-paid`);
            const requestedCheckbox = document.getElementById(`${tab}-filter-requested`);
            const disqualifiedCheckbox = document.getElementById(`${tab}-filter-disqualified`);
            const unpaidCheckbox = document.getElementById(`${tab}-filter-unpaid`);
            
            const showPaid = paidCheckbox ? paidCheckbox.checked : true;
            const showRequested = requestedCheckbox ? requestedCheckbox.checked : true;
            const showDisqualified = disqualifiedCheckbox ? disqualifiedCheckbox.checked : true;
            const showUnpaid = unpaidCheckbox ? unpaidCheckbox.checked : true;
            
            const paymentStatusFilter = document.getElementById(`${tab}-filter-payment-status`)?.value || '';
            const companyFilter = document.getElementById(`${tab}-filter-company`)?.value || '';
            const searchText = (document.getElementById(`${tab}-filter-search`)?.value || '').toLowerCase();

            const filteredData = data.filter(row => {
                if (row['_rowType'] === 'paid' && !showPaid) return false;
                if (row['_rowType'] === 'requested' && !showRequested) return false;
                if ((row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') && !showDisqualified) return false;
                
                const paymentStatus = (row['Payment Status'] || '').trim();
                if (!showUnpaid && !paymentStatus && row['_rowType'] !== 'submitted') return false;

                if (paymentStatusFilter && row['Payment Status'] !== paymentStatusFilter) return false;
                if (companyFilter && row['Company Name'] !== companyFilter) return false;

                if (searchText) {
                    const rowText = Object.values(row).join(' ').toLowerCase();
                    if (!rowText.includes(searchText)) return false;
                }
                
                return true;
            });

            appData[tab].filtered = filteredData;
            appData[tab].currentPage = 1;
            renderTable(tab);
        }

        function renderTable(tab) {
            const filteredData = appData[tab].filtered;
            const thead = document.getElementById(`${tab}-thead`);
            const tbody = document.getElementById(`${tab}-tbody`);
            
            // If DOM elements don't exist yet, skip rendering
            if (!thead || !tbody) {
                console.log(`Skipping render for ${tab} - DOM not ready`);
                return;
            }

            if (filteredData.length === 0) {
                thead.innerHTML = '';
                tbody.innerHTML = '<tr><td colspan="100" style="text-align: center;">No data matches filters.</td></tr>';
                updateStatusBar(tab);
                updatePagination(tab);
                return;
            }

            const columns = getColumns(tab);

            thead.innerHTML = '<tr>' + columns.map(col => {
                return `<th onclick="sortTable('${tab}', '${col}')">${col} <span class="sort-indicator">${getSortIndicator(tab, col)}</span></th>`;
            }).join('') + '</tr>';

            const pageSize = appData[tab].pageSize;
            const currentPage = appData[tab].currentPage;
            const start = (currentPage - 1) * pageSize;
            const end = pageSize === 'all' ? filteredData.length : start + pageSize;
            const pageData = filteredData.slice(start, end);

            tbody.innerHTML = pageData.map(row => {
                let rowClass = '';
                
                // Check if data is unreceived (no Hearing Date)
                const isUnreceived = !row['Hearing Date'] || row['Hearing Date'].trim() === '';
                
                if (row['_rowType'] === 'paid') rowClass = 'row-green';
                else if (row['_rowType'] === 'requested') rowClass = 'row-yellow';
                else if (row['_rowType'] === 'dismissed') rowClass = 'row-dismissed'; // Darker red for dismissed
                else if (row['_rowType'] === 'disqualified') rowClass = 'row-red'; // Red for disqualified
                else if (row['_rowType'] === 'submitted') rowClass = 'row-purple'; // Purple for submitted (unreviewed)
                
                // Override with light blue if unreceived (but NOT if disqualified, dismissed, or submitted)
                if (isUnreceived && row['_rowType'] !== 'disqualified' && row['_rowType'] !== 'dismissed' && row['_rowType'] !== 'submitted') {
                    rowClass = 'row-lightblue';
                }

                return '<tr class="' + rowClass + '">' + columns.map(col => {
                    let value = row[col] || '';
                    value = formatDate(value);
                    return `<td>${value}</td>`;
                }).join('') + '</tr>';
            }).join('');

            updateStatusBar(tab);
            updateTotalsBar(tab, filteredData);
            updatePagination(tab);
        }

        function updatePagination(tab) {
            const filtered = appData[tab].filtered;
            const pageSize = appData[tab].pageSize === 'all' ? filtered.length : appData[tab].pageSize;
            const totalPages = Math.ceil(filtered.length / pageSize);
            const currentPage = appData[tab].currentPage;

            const pageInfo = document.getElementById(`${tab}-page-info`);
            if (pageInfo) {
                pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${filtered.length} total)`;
            }

            const pagination = document.getElementById(`${tab}-pagination`);
            if (!pagination) return;
            
            const prevBtn = pagination.querySelector('button:nth-child(2)');
            const nextBtn = pagination.querySelector('button:nth-child(3)');

            if (prevBtn) prevBtn.disabled = currentPage === 1;
            if (nextBtn) nextBtn.disabled = currentPage === totalPages || totalPages === 0;
        }

        function changePage(tab, direction) {
            appData[tab].currentPage += direction;
            renderTable(tab);
        }

        function changePageSize(tab) {
            const value = document.getElementById(`${tab}-page-size`).value;
            appData[tab].pageSize = value === 'all' ? 'all' : parseInt(value);
            appData[tab].currentPage = 1;
            renderTable(tab);
        }

        function getSortIndicator(tab, column) {
            if (currentSortColumn[tab] === column) {
                return currentSortDirection[tab] === 'asc' ? '‚ñ≤' : '‚ñº';
            }
            return '‚áÖ';
        }

        function sortTable(tab, column) {
            if (currentSortColumn[tab] === column) {
                currentSortDirection[tab] = currentSortDirection[tab] === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn[tab] = column;
                currentSortDirection[tab] = 'asc';
            }

            const data = appData[tab].filtered;
            data.sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';

                const aNum = parseFloat(aVal.replace(/[$,]/g, ''));
                const bNum = parseFloat(bVal.replace(/[$,]/g, ''));

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return currentSortDirection[tab] === 'asc' ? aNum - bNum : bNum - aNum;
                }

                if (currentSortDirection[tab] === 'asc') {
                    return aVal.localeCompare(bVal);
                } else {
                    return bVal.localeCompare(aVal);
                }
            });

            renderTable(tab);
        }

        function updateStatusBar(tab) {
            const data = appData[tab].merged;
            const statusBar = document.getElementById(`${tab}-status`);
            
            // If status bar doesn't exist, skip
            if (!statusBar) {
                console.log(`Skipping status bar update for ${tab} - DOM not ready`);
                return;
            }

            const paidCount = data.filter(row => row['_rowType'] === 'paid').length;
            const requestedCount = data.filter(row => row['_rowType'] === 'requested').length;
            const disqualifiedCount = data.filter(row => row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed').length;
            const totalCount = data.length;

            // Data Received: has violation date AND status is not Disqualified or Not Pursued
            const eligibleCount = data.filter(row => {
                const status = (row['Status'] || '').toLowerCase();
                return status !== 'disqualified' && status !== 'not pursued';
            }).length;
            
            const dataReceivedCount = data.filter(row => {
                const hasViolationDate = row['Violation Date'] && row['Violation Date'].trim() !== '';
                const status = (row['Status'] || '').toLowerCase();
                const notDisqualified = status !== 'disqualified' && status !== 'not pursued';
                return hasViolationDate && notDisqualified;
            }).length;
            const dataReceivedPercentage = eligibleCount > 0 ? ((dataReceivedCount / eligibleCount) * 100).toFixed(1) : 0;

            const reviewedCount = data.filter(row => {
                const status = (row['Status'] || '').toLowerCase();
                return status !== 'submitted' && status !== '';
            }).length;

            const nonSubmittedCount = data.filter(row => {
                const status = (row['Status'] || '').toLowerCase();
                return status !== 'submitted' && status !== '';
            }).length;
            const disqualifiedPercentage = nonSubmittedCount > 0 ? ((disqualifiedCount / nonSubmittedCount) * 100).toFixed(1) : 0;
            
            // Calculate reviewed percentage
            const reviewedPercentage = totalCount > 0 ? ((reviewedCount / totalCount) * 100).toFixed(1) : 0;

            // Special handling for AT NYC dataset
            if (tab === 'at-nyc') {
                statusBar.innerHTML = `
                    <div class="status-item">
                        <span class="status-badge badge-total">Total: ${totalCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-green">Paid: ${paidCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-yellow">Requested: ${requestedCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-red">Disq: ${disqualifiedCount} (${disqualifiedPercentage}%)</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge" style="background: #3498db; color: white;">Data Received: ${dataReceivedCount} (${dataReceivedPercentage}%)</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge" style="background: #9b59b6; color: white;">Reviewed: ${reviewedCount} (${reviewedPercentage}%)</span>
                    </div>
                `;
            } else {
                statusBar.innerHTML = `
                    <div class="status-item">
                        <span class="status-badge badge-total">Total: ${totalCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-green">Paid: ${paidCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-yellow">Requested: ${requestedCount}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge badge-red">Disq: ${disqualifiedCount} (${disqualifiedPercentage}%)</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge" style="background: #3498db; color: white;">Data Received: ${dataReceivedCount} (${dataReceivedPercentage}%)</span>
                    </div>
                `;
            }
            
            // Add refresh timestamps
            const lastSheets = appData[tab].lastRefreshSheets;
            const lastNYC = appData[tab].lastRefreshNYC;
            const formatTimestamp = (isoString) => {
                if (!isoString) return 'Never';
                const date = new Date(isoString);
                return date.toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
            };
            
            // Insert timestamps into the placeholder div
            const timestampDiv = document.getElementById(`${tab}-timestamps`);
            if (timestampDiv) {
                timestampDiv.innerHTML = `
                    üìä <strong>Last Google Sheets Refresh:</strong> ${formatTimestamp(lastSheets)} &nbsp;
                    üèôÔ∏è <strong>Last NYC OpenData Refresh:</strong> ${formatTimestamp(lastNYC)}
                `;
            }
        }

        function updateTotalsBar(tab, filteredData) {
            const totalsBar = document.getElementById(`${tab}-totals`);
            if (!totalsBar) return;

            let totalHtml = `<div class="total-item">Visible: ${filteredData.length}</div>`;

            let totalPaidAmount = 0;
            let totalRequestedAmount = 0;

            filteredData.forEach(row => {
                const paidAmount = parseFloat((row['Paid Amount'] || '').replace(/[$,]/g, ''));
                
                if (row['_rowType'] === 'paid' && !isNaN(paidAmount)) {
                    totalPaidAmount += paidAmount;
                } else if (row['_rowType'] === 'requested' && !isNaN(paidAmount)) {
                    totalRequestedAmount += paidAmount;
                }
            });

            if (totalPaidAmount > 0) {
                const quarterPaid = totalPaidAmount / 4;
                totalHtml += `<div class="total-item">Paid: $${totalPaidAmount.toFixed(2)} ($${quarterPaid.toFixed(2)})</div>`;
            }

            if (totalRequestedAmount > 0) {
                const quarterRequested = totalRequestedAmount / 4;
                totalHtml += `<div class="total-item">Requested: $${totalRequestedAmount.toFixed(2)} ($${quarterRequested.toFixed(2)})</div>`;
            }
            
            // Add expected revenue
            const expectedTotal = filteredData.length * 82.50;
            const yourExpected = expectedTotal * 0.25;
            totalHtml += `<div class="total-item">Expected: $${expectedTotal.toFixed(2)} ($${yourExpected.toFixed(2)})</div>`;

            totalsBar.innerHTML = totalHtml;
        }

        function updateProgress(tab, percent, message) {
            const progressContainer = document.getElementById(`${tab}-progress`);
            const progressFill = document.getElementById(`${tab}-progress-fill`);
            const progressStatus = document.getElementById(`${tab}-progress-status`);

            if (!progressContainer) return;

            progressContainer.classList.add('show');
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
            progressStatus.textContent = message;

            if (percent >= 100) {
                setTimeout(() => {
                    progressContainer.classList.remove('show');
                }, 1500);
            }
        }

        function renderNewMoney() {
            console.log('=== renderNewMoney called ===');
            
            // Check if data is loaded
            if (!appData || !appData['at'] || !appData['at'].merged) {
                console.log('No data loaded yet, skipping renderNewMoney');
                return;
            }
            
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                console.log(`Processing ${tab}:`, appData[tab].merged.length, 'total rows');
                const data = appData[tab].merged;
                
                // Log first few rows to see their Hearing Status and Payment Status
                console.log(`  ${tab}: Sample row data (first 3):`);
                data.slice(0, 3).forEach((row, idx) => {
                    console.log(`    Row ${idx}:`, {
                        'Summons Number': row['Summons Number'],
                        'Hearing Status': row['Hearing Status'],
                        'Payment Status': row['Payment Status'],
                        'Paid Amount': row['Paid Amount']
                    });
                });
                
                // Count rows with Hearing Status = Paid in Full
                const rowsWithPaidInFull = data.filter(row => {
                    const hearingStatus = (row['Hearing Status'] || '').toLowerCase();
                    return hearingStatus === 'paid in full';
                });
                console.log(`  ${tab}: Rows with Hearing Status = 'Paid in Full': ${rowsWithPaidInFull.length}`);
                
                // Count how many also have Payment Status
                const rowsWithBoth = rowsWithPaidInFull.filter(row => {
                    const paymentStatus = (row['Payment Status'] || '').trim();
                    return paymentStatus;
                });
                console.log(`  ${tab}: Of those, ${rowsWithBoth.length} have Payment Status`);
                console.log(`  ${tab}: So ${rowsWithPaidInFull.length - rowsWithBoth.length} should show in New Money`);
                
                // NEW MONEY = Hearing Status is "Paid in Full" BUT no Payment Status yet
                const newMoneyData = data.filter(row => {
                    const hearingStatus = (row['Hearing Status'] || '').toLowerCase();
                    const paymentStatus = (row['Payment Status'] || '').trim();
                    return hearingStatus === 'paid in full' && !paymentStatus;
                });
                
                console.log(`  ${tab}: Found ${newMoneyData.length} new money rows`);
                
                // Log first match if exists
                if (newMoneyData.length > 0) {
                    console.log(`  ${tab}: First matching row:`, {
                        'Summons Number': newMoneyData[0]['Summons Number'],
                        'Hearing Status': newMoneyData[0]['Hearing Status'],
                        'Payment Status': newMoneyData[0]['Payment Status'],
                        'Paid Amount': newMoneyData[0]['Paid Amount'],
                        'Paid To Me': newMoneyData[0]['Paid To Me']
                    });
                }

                const thead = document.getElementById(`new-money-${tab}-thead`);
                const tbody = document.getElementById(`new-money-${tab}-tbody`);
                
                console.log(`  ${tab}: thead=${!!thead}, tbody=${!!tbody}`);

                if (newMoneyData.length === 0) {
                    if (thead) thead.innerHTML = '';
                    if (tbody) tbody.innerHTML = '<tr><td colspan="100" style="text-align: center;">‚úÖ All caught up!</td></tr>';
                    const totalsDiv = document.getElementById(`new-money-${tab}-totals`);
                    if (totalsDiv) totalsDiv.innerHTML = 'üí∞ Total: $0.00';
                    console.log(`  ${tab}: No data, showing "All caught up"`);
                    return; // Continue to next dataset in forEach
                }

                const columns = Object.keys(newMoneyData[0]).filter(col => !col.startsWith('_'));
                console.log(`  ${tab}: Rendering ${columns.length} columns`);

                if (thead) thead.innerHTML = '<tr>' + columns.map(col => `<th>${col}</th>`).join('') + '</tr>';
                if (tbody) {
                    tbody.innerHTML = newMoneyData.map(row => {
                        return '<tr>' + columns.map(col => {
                            let value = row[col] || '';
                            value = formatDate(value);
                            return `<td>${value}</td>`;
                        }).join('') + '</tr>';
                    }).join('');
                }

                let totalWaitingToCollect = 0;
                newMoneyData.forEach(row => {
                    const amount = parseFloat((row['Paid Amount'] || '').replace(/[$,]/g, ''));
                    if (!isNaN(amount)) {
                        totalWaitingToCollect += amount;
                    }
                });

                const quarterAmount = totalWaitingToCollect / 4;
                const totalsDiv = document.getElementById(`new-money-${tab}-totals`);
                if (totalsDiv) {
                    totalsDiv.innerHTML = `
                        üí∞ Total: $${totalWaitingToCollect.toFixed(2)} | Your 25%: $${quarterAmount.toFixed(2)} | Count: ${newMoneyData.length}
                    `;
                }
                console.log(`  ${tab}: Complete - $${totalWaitingToCollect.toFixed(2)}`);
            });
            console.log('=== renderNewMoney complete ===');
        }

        function refreshNewMoney() {
            // loadAllData will reload data AND render all tabs including New Money
            loadAllData(true);
        }

        function renderPendingPayments() {
            console.log('=== renderPendingPayments called ===');
            const allPendingTotals = { count: 0, amount: 0 };
            
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                console.log(`Processing pending ${tab}:`, appData[tab].merged.length, 'total rows');
                const data = appData[tab].merged;
                
                // Filter for requested but not yet paid
                const pendingData = data.filter(row => {
                    const paymentStatus = (row['Payment Status'] || '').trim();
                    return paymentStatus === 'REQUESTED';
                });
                
                console.log(`  ${tab}: Found ${pendingData.length} pending rows`);

                const thead = document.getElementById(`pending-${tab}-thead`);
                const tbody = document.getElementById(`pending-${tab}-tbody`);
                const totalsDiv = document.getElementById(`pending-${tab}-totals`);
                
                console.log(`  ${tab}: thead=${!!thead}, tbody=${!!tbody}, totalsDiv=${!!totalsDiv}`);

                if (pendingData.length === 0) {
                    if (thead) thead.innerHTML = '';
                    if (tbody) tbody.innerHTML = '<tr><td colspan="100" style="text-align: center;">‚úÖ No pending requests!</td></tr>';
                    if (totalsDiv) totalsDiv.innerHTML = 'üí∞ Expected: $0.00';
                    console.log(`  ${tab}: No pending data`);
                    return; // Continue to next dataset in forEach
                }

                // Parse and sort pending data
                const parsedPendingData = pendingData.map(row => {
                    const requestDateRaw = row['Payment Request Email'] || row['Request Date'] || '';
                    let sequenceNum = 0;
                    let dateOnly = requestDateRaw;
                    
                    // Check for sequence number - handle both "- #3" and "- 3" formats
                    const seqMatch = requestDateRaw.match(/(.+?)\s*-\s*#?(\d+)/);
                    if (seqMatch) {
                        dateOnly = seqMatch[1].trim();
                        sequenceNum = parseInt(seqMatch[2]);
                    }
                    
                    return {
                        ...row,
                        _requestDateRaw: requestDateRaw,
                        _dateOnly: dateOnly,
                        _sequenceNum: sequenceNum
                    };
                });

                // Sort by date (oldest first / chronological), then by sequence number (earlier numbers first)
                parsedPendingData.sort((a, b) => {
                    const dateA = parseDateForSorting(a._dateOnly);
                    const dateB = parseDateForSorting(b._dateOnly);
                    
                    if (dateA && dateB) {
                        if (dateA.getTime() !== dateB.getTime()) {
                            return dateA - dateB; // Oldest first (chronological order)
                        }
                        // Same date, sort by sequence number (lower numbers first)
                        return a._sequenceNum - b._sequenceNum;
                    }
                    return 0;
                });

                // Define simplified columns
                if (thead) {
                    thead.innerHTML = `
                        <tr>
                            <th>Summons Number</th>
                            <th>Company Name</th>
                            <th>Expected Amount</th>
                            <th>Date Requested</th>
                            <th>Days Since Request</th>
                        </tr>
                    `;
                }
                
                if (tbody) {
                    tbody.innerHTML = parsedPendingData.map(row => {
                    const summonsNum = row['Summons Number'] || '';
                    const companyName = row['Company Name'] || '';
                    const paidAmount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    const expectedAmount = paidAmount * 0.25;
                    
                    let requestDate = row._dateOnly;
                    let daysSince = 'N/A';
                    let displayDate = row._requestDateRaw; // Show original with sequence number
                    
                    if (requestDate) {
                        const result = parseRequestDate(requestDate);
                        if (result) {
                            displayDate = result.displayDate + (row._sequenceNum > 0 ? ` - #${row._sequenceNum}` : '');
                            daysSince = result.daysSince;
                        }
                    }

                    // Add to overall totals
                    if (!isNaN(expectedAmount)) {
                        allPendingTotals.amount += expectedAmount;
                        allPendingTotals.count++;
                    }

                    // Color code days
                    let daysClass = '';
                    if (typeof daysSince === 'number') {
                        if (daysSince > 60) daysClass = 'style="color: #e74c3c; font-weight: bold;"'; // Red for >60 days
                        else if (daysSince > 30) daysClass = 'style="color: #f39c12; font-weight: bold;"'; // Orange for >30 days
                        else daysClass = 'style="color: #27ae60; font-weight: bold;"'; // Green for <=30 days
                    }

                    return `
                        <tr>
                            <td>${summonsNum}</td>
                            <td>${companyName}</td>
                            <td>$${expectedAmount.toFixed(2)}</td>
                            <td>${displayDate}</td>
                            <td ${daysClass}>${daysSince}${typeof daysSince === 'number' ? ' days' : ''}</td>
                        </tr>
                    `;
                }).join('');
                }

                // Calculate totals for this dataset
                let totalExpected = 0;
                parsedPendingData.forEach(row => {
                    const amount = parseFloat((row['Paid Amount'] || '').replace(/[$,]/g, ''));
                    if (!isNaN(amount)) {
                        totalExpected += amount * 0.25;
                    }
                });

                if (totalsDiv) {
                    totalsDiv.innerHTML = `
                        ‚è≥ Expected: $${totalExpected.toFixed(2)} | Count: ${parsedPendingData.length}
                    `;
                }
            });

            // Update overall total at the top of the section
            const overallTotalDiv = document.getElementById('pending-overall-total');
            if (overallTotalDiv) {
                overallTotalDiv.innerHTML = `
                    <div style="background: white; padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; color: #2c3e50;">üí∞ Overall Pending Total</h3>
                        <div style="font-size: 1.8em; font-weight: bold; color: #f39c12;">$${allPendingTotals.amount.toFixed(2)}</div>
                        <div style="font-size: 0.9em; color: #666; margin-top: 5px;">${allPendingTotals.count} summonses across all datasets</div>
                    </div>
                `;
            }
        }

        function parseRequestDate(dateStr) {
            try {
                let parsedDate;
                const today = new Date();
                
                // Handle M/D/YY format (like "8/18/25")
                if (dateStr.match(/^\d{1,2}\/\d{1,2}\/\d{2}$/)) {
                    const parts = dateStr.split('/');
                    const month = parseInt(parts[0]);
                    const day = parseInt(parts[1]);
                    const yearShort = parseInt(parts[2]);
                    const year = 2000 + yearShort;
                    
                    parsedDate = new Date(year, month - 1, day);
                }
                // Handle M/D format (like "9/17") - use most recent year with that month
                else if (dateStr.match(/^\d{1,2}\/\d{1,2}$/)) {
                    const parts = dateStr.split('/');
                    const month = parseInt(parts[0]);
                    const day = parseInt(parts[1]);
                    
                    // Start with current year
                    let year = today.getFullYear();
                    parsedDate = new Date(year, month - 1, day);
                    
                    // If this date hasn't occurred yet this year, it must be from this year
                    // (we assume it's the most recent occurrence)
                    if (parsedDate > today) {
                        // Date is in the future, so it must have been from a previous occurrence
                        // But since we want the most recent year with that month, and it hasn't 
                        // happened yet this year, keep it as this year
                        // Actually, if it's in the future, it can't be a request date, so use last year
                        year = year - 1;
                        parsedDate = new Date(year, month - 1, day);
                    }
                }
                // Try standard formats
                else {
                    parsedDate = new Date(dateStr);
                }
                
                if (parsedDate && !isNaN(parsedDate.getTime())) {
                    const diffTime = today - parsedDate;
                    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                    
                    const displayDate = `${parsedDate.getMonth() + 1}/${parsedDate.getDate()}/${parsedDate.getFullYear()}`;
                    
                    return {
                        displayDate: displayDate,
                        daysSince: diffDays,
                        parsedDate: parsedDate
                    };
                }
            } catch (e) {
                console.log('Error parsing date:', dateStr, e);
            }
            return null;
        }

        function parseDateForSorting(dateStr) {
            const result = parseRequestDate(dateStr);
            return result ? result.parsedDate : null;
        }

        function generateFunFacts() {
            const container = document.getElementById('fun-facts-container');
            
            try {
                const allData = [];
                
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    appData[tab].merged.forEach(row => {
                        allData.push({ ...row, _dataset: tab });
                    });
                });

                if (allData.length === 0) {
                    container.innerHTML = '<p>No data available. Please load data first.</p>';
                    return;
                }

                const facts = [];

                // REVENUE & PERFORMANCE INSIGHTS
                
                // 1. Total Potential vs Realized
                let totalPotential = 0;
                let totalCollected = 0;
                allData.forEach(row => {
                    try {
                        const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                        if (!isNaN(amount) && amount > 0) {
                            totalPotential += amount;
                            // Count paid as full amount, requested as 25%
                            if (row['_rowType'] === 'paid') {
                                totalCollected += amount;
                            } else if (row['_rowType'] === 'requested') {
                                totalCollected += amount * 0.25;
                            }
                        }
                    } catch (e) {
                        console.error('Error processing row:', e);
                    }
                });
            const yourPotential = totalPotential * 0.25;
            const yourCollected = totalCollected * 0.25;
            const uncollected = yourPotential - yourCollected;
            facts.push({
                title: 'üí∞ Total Earnings Potential',
                description: `You've collected/requested $${yourCollected.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} out of a potential $${yourPotential.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} - that's $${uncollected.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} still outstanding!`
            });

            // 2. Success Rate
            const paidAndRequestedCount = allData.filter(row => row['_rowType'] === 'paid' || row['_rowType'] === 'requested').length;
            const successRate = ((paidAndRequestedCount / allData.length) * 100).toFixed(1);
            facts.push({
                title: 'üìà Overall Success Rate',
                description: `${successRate}% success rate - ${paidAndRequestedCount} out of ${allData.length.toLocaleString()} summonses resulted in payment or request`
            });

            // 3. Average Payout
            const avgPayout = paidAndRequestedCount > 0 ? yourCollected / paidAndRequestedCount : 0;
            facts.push({
                title: 'üíµ Average Payout Per Case',
                description: `Each successful summons nets you an average of $${avgPayout.toFixed(2)}`
            });

            // 4. Biggest Single Win
            let biggestWin = 0;
            let biggestWinCompany = '';
            allData.filter(row => row['_rowType'] === 'paid').forEach(row => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (!isNaN(amount) && amount > biggestWin) {
                    biggestWin = amount;
                    biggestWinCompany = row['Company Name'] || 'Unknown';
                }
            });
            if (biggestWin > 0) {
                const yourCut = biggestWin * 0.25;
                facts.push({
                    title: 'üèÜ Biggest Single Win',
                    description: `Your largest payday was $${yourCut.toFixed(2)} from ${biggestWinCompany} (NYC paid $${biggestWin.toFixed(2)})`
                });
            }

            // 5. Money Still in Pipeline (show 25% expected from requested amounts)
            const requestedCount = allData.filter(row => row['_rowType'] === 'requested').length;
            let requestedAmount = 0;
            allData.filter(row => row['_rowType'] === 'requested').forEach(row => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (!isNaN(amount)) requestedAmount += amount;
            });
            const yourRequestedShare = requestedAmount * 0.25 * 0.25; // 25% of amount, expecting 25% payment rate
            if (requestedCount > 0) {
                facts.push({
                    title: '‚è≥ Money in Pipeline',
                    description: `You have ${requestedCount} payment requests pending worth approximately $${yourRequestedShare.toFixed(2)} to you (assuming 25% payment rate)`
                });
            }

            // 6. Disqualification Rate (include dismissed)
            const disqualifiedCount = allData.filter(row => row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed').length;
            const disqualificationRate = ((disqualifiedCount / allData.length) * 100).toFixed(1);
            facts.push({
                title: '‚ùå Disqualification Rate',
                description: `${disqualificationRate}% of cases were disqualified (${disqualifiedCount} total) - room for improvement here!`
            });

            // 7. Win/Loss Ratio
            const paidCount = allData.filter(row => row['_rowType'] === 'paid').length;
            const winLossRatio = disqualifiedCount > 0 ? (paidCount / disqualifiedCount).toFixed(2) : 'Infinity';
            facts.push({
                title: '‚öñÔ∏è Win/Loss Ratio',
                description: `You win ${winLossRatio} cases for every one you lose - ${winLossRatio > 2 ? 'excellent!' : winLossRatio > 1 ? 'good!' : 'needs work'}`
            });

            // 8. Collection Speed
            const daysToPayment = [];
            allData.filter(row => row['_rowType'] === 'paid').forEach(row => {
                try {
                    if (!row['Violation Date']) return;
                    const violationDate = new Date(row['Violation Date']);
                    const paymentDate = new Date(row['Payment Received'] || row['Hearing Date']);
                    if (violationDate && paymentDate && !isNaN(violationDate.getTime()) && !isNaN(paymentDate.getTime())) {
                        const days = Math.floor((paymentDate - violationDate) / (1000 * 60 * 60 * 24));
                        if (days >= 0 && days < 1000) daysToPayment.push(days);
                    }
                } catch (e) {
                    // Skip invalid dates
                }
            });
            if (daysToPayment.length > 0) {
                const avgDays = Math.round(daysToPayment.reduce((a, b) => a + b, 0) / daysToPayment.length);
                const fastestDays = Math.min(...daysToPayment);
                const slowestDays = Math.max(...daysToPayment);
                facts.push({
                    title: '‚è±Ô∏è Collection Speed',
                    description: `Average time to payment: ${avgDays} days (fastest: ${fastestDays} days, slowest: ${slowestDays} days)`
                });
            }

            // 9. Conversion Rate
            const totalWithOutcome = paidCount + disqualifiedCount;
            const conversionRate = totalWithOutcome > 0 ? ((paidCount / totalWithOutcome) * 100).toFixed(1) : 0;
            facts.push({
                title: 'üéØ Conversion Rate',
                description: `${conversionRate}% of decided cases result in payment - that means ${conversionRate}% of your work pays off!`
            });

            // STRATEGIC COMPANY INSIGHTS

            // 10. Repeat Offenders - Your Biggest Customer
            const companyCounts = {};
            const companyRevenue = {};
            allData.forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                companyCounts[company] = (companyCounts[company] || 0) + 1;
                if (row['_rowType'] === 'paid') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) {
                        companyRevenue[company] = (companyRevenue[company] || 0) + amount;
                    }
                }
            });
            const topCompany = Object.keys(companyCounts).reduce((a, b) => companyCounts[a] > companyCounts[b] ? a : b);
            const topCompanyYourShare = (companyRevenue[topCompany] || 0) * 0.25;
            facts.push({
                title: 'üöö Your Biggest Customer',
                description: `${topCompany} has ${companyCounts[topCompany]} violations worth $${topCompanyYourShare.toFixed(2)} to you - your golden goose!`
            });

            // 11. Best Payers
            const companyPaymentRate = {};
            Object.keys(companyCounts).forEach(company => {
                const companyData = allData.filter(row => normalizeCompanyName(row['Company Name']) === company);
                const companyPaid = companyData.filter(row => row['_rowType'] === 'paid').length;
                companyPaymentRate[company] = {
                    rate: (companyPaid / companyData.length) * 100,
                    count: companyData.length,
                    paidCount: companyPaid,
                    avgDays: 0
                };
                // Calculate avg days for this company
                const companyDays = [];
                companyData.filter(row => row['_rowType'] === 'paid').forEach(row => {
                    try {
                        if (!row['Violation Date']) return;
                        const violationDate = new Date(row['Violation Date']);
                        const paymentDate = new Date(row['Payment Received'] || row['Hearing Date']);
                        if (violationDate && paymentDate && !isNaN(violationDate.getTime()) && !isNaN(paymentDate.getTime())) {
                            const days = Math.floor((paymentDate - violationDate) / (1000 * 60 * 60 * 24));
                            if (days >= 0 && days < 1000) companyDays.push(days);
                        }
                    } catch (e) {
                        // Skip invalid dates
                    }
                });
                if (companyDays.length > 0) {
                    companyPaymentRate[company].avgDays = Math.round(companyDays.reduce((a, b) => a + b, 0) / companyDays.length);
                }
            });
            const bestPayers = Object.keys(companyPaymentRate)
                .filter(company => companyCounts[company] >= 3 && companyPaymentRate[company].rate >= 80)
                .sort((a, b) => companyPaymentRate[b].rate - companyPaymentRate[a].rate);
            if (bestPayers.length > 0) {
                const bestPayer = bestPayers[0];
                const rate = companyPaymentRate[bestPayer].rate.toFixed(0);
                const avgDays = companyPaymentRate[bestPayer].avgDays;
                facts.push({
                    title: '‚≠ê Most Reliable Payer',
                    description: `${bestPayer} pays ${rate}% of the time${avgDays > 0 ? ` and averages ${avgDays} days to payment` : ''} - a dream client!`
                });
            }

            // 12. Worst Performers
            const worstPayers = Object.keys(companyPaymentRate)
                .filter(company => companyCounts[company] >= 3 && companyPaymentRate[company].rate < 30)
                .sort((a, b) => companyPaymentRate[a].rate - companyPaymentRate[b].rate);
            if (worstPayers.length > 0) {
                const worstPayer = worstPayers[0];
                const rate = companyPaymentRate[worstPayer].rate.toFixed(0);
                facts.push({
                    title: '‚ö†Ô∏è Problem Company',
                    description: `${worstPayer} only pays ${rate}% of the time - maybe not worth pursuing`
                });
            }

            // 13. High-Value Targets
            const unpaidCases = allData.filter(row => !row['_rowType'] || row['_rowType'] === 'submitted');
            let unpaidPotential = 0;
            unpaidCases.forEach(row => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (!isNaN(amount)) unpaidPotential += amount;
            });
            const yourUnpaidPotential = unpaidPotential * 0.25;
            if (unpaidCases.length > 0) {
                facts.push({
                    title: 'üéØ High-Value Targets',
                    description: `You have ${unpaidCases.length} unpaid violations worth $${yourUnpaidPotential.toFixed(2)} to you - time to chase these down!`
                });
            }

            // GEOGRAPHIC & TIMING PATTERNS

            // 14. Best Borough
            const boroughStats = {};
            allData.forEach(row => {
                const borough = row['Violation Location (Borough)'] || 'Unknown';
                if (!boroughStats[borough]) {
                    boroughStats[borough] = { total: 0, paid: 0 };
                }
                boroughStats[borough].total++;
                if (row['_rowType'] === 'paid') boroughStats[borough].paid++;
                else if (row['_rowType'] === 'requested') boroughStats[borough].paid += 0.25;
            });
            let bestBorough = null;
            let bestBoroughRate = 0;
            Object.keys(boroughStats).forEach(borough => {
                if (boroughStats[borough].total >= 5) {
                    const rate = (boroughStats[borough].paid / boroughStats[borough].total) * 100;
                    if (rate > bestBoroughRate) {
                        bestBoroughRate = rate;
                        bestBorough = borough;
                    }
                }
            });
            if (bestBorough && bestBorough !== 'Unknown') {
                facts.push({
                    title: 'üó∫Ô∏è Best Borough',
                    description: `${bestBorough} violations are ${bestBoroughRate.toFixed(0)}% more likely to pay than other boroughs - focus your efforts here!`
                });
            }

            // 15. Seasonal Patterns
            const monthCounts = {};
            allData.forEach(row => {
                try {
                    if (!row['Violation Date']) return;
                    const date = new Date(row['Violation Date']);
                    if (date && !isNaN(date.getTime())) {
                        const month = date.getMonth();
                        monthCounts[month] = (monthCounts[month] || 0) + 1;
                    }
                } catch (e) {
                    // Skip invalid dates
                }
            });
            if (Object.keys(monthCounts).length > 0) {
                const busiestMonth = Object.keys(monthCounts).reduce((a, b) => monthCounts[a] > monthCounts[b] ? a : b);
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const avgMonthCount = Object.values(monthCounts).reduce((a, b) => a + b, 0) / Object.keys(monthCounts).length;
                const increasePercent = ((monthCounts[busiestMonth] / avgMonthCount - 1) * 100).toFixed(0);
                facts.push({
                    title: 'üìÖ Peak Season',
                    description: `${monthNames[busiestMonth]} is your busiest month with ${increasePercent}% more violations than average - probably due to cold weather idling!`
                });
            }

            // 16. Day of Week Success
            const dowStats = {};
            allData.forEach(row => {
                try {
                    if (!row['Violation Date']) return;
                    const date = new Date(row['Violation Date']);
                    if (date && !isNaN(date.getTime())) {
                        const dow = date.getDay();
                        if (!dowStats[dow]) dowStats[dow] = { total: 0, paid: 0 };
                        dowStats[dow].total++;
                        if (row['_rowType'] === 'paid') dowStats[dow].paid++;
                        else if (row['_rowType'] === 'requested') dowStats[dow].paid += 0.25;
                    }
                } catch (e) {
                    // Skip invalid dates
                }
            });
            let bestDOW = null;
            let bestDOWRate = 0;
            Object.keys(dowStats).forEach(dow => {
                if (dowStats[dow].total >= 10) {
                    const rate = (dowStats[dow].paid / dowStats[dow].total) * 100;
                    if (rate > bestDOWRate) {
                        bestDOWRate = rate;
                        bestDOW = dow;
                    }
                }
            });
            if (bestDOW !== null) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                facts.push({
                    title: 'üìÜ Lucky Day',
                    description: `Violations on ${dayNames[bestDOW]} have the highest success rate at ${bestDOWRate.toFixed(0)}% - your lucky day!`
                });
            }

            // 17. Hot Zone
            const locationCounts = {};
            allData.forEach(row => {
                const street = row['Violation Location (Street Name)'] || row['Place of Occurrence'] || 'Unknown';
                if (street && street !== 'Unknown') {
                    locationCounts[street] = (locationCounts[street] || 0) + 1;
                }
            });
            if (Object.keys(locationCounts).length > 0) {
                const hotZone = Object.keys(locationCounts).reduce((a, b) => locationCounts[a] > locationCounts[b] ? a : b);
                if (locationCounts[hotZone] >= 5) {
                    facts.push({
                        title: 'üî• Hot Zone',
                        description: `${hotZone} has the most violations (${locationCounts[hotZone]} total) - your prime hunting ground!`
                    });
                }
            }

            // ACTIONABLE INSIGHTS

            // 18. Quick Wins
            const unpaidUnder500 = allData.filter(row => {
                if (row['_rowType'] === 'paid' || row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') return false;
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                return !isNaN(amount) && amount > 0 && amount < 500;
            });
            if (unpaidUnder500.length > 0) {
                let quickWinValue = 0;
                unpaidUnder500.forEach(row => {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) quickWinValue += amount;
                });
                const yourQuickWins = quickWinValue * 0.25;
                facts.push({
                    title: 'üí° Quick Wins Available',
                    description: `You have ${unpaidUnder500.length} violations under $500 still unpaid - easy money worth $${yourQuickWins.toFixed(2)} to you!`
                });
            }

            // 19. Old Cases Needing Attention
            const oldUnpaid = allData.filter(row => {
                try {
                    if (row['_rowType'] === 'paid' || row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') return false;
                    if (!row['Violation Date']) return false;
                    const violationDate = new Date(row['Violation Date']);
                    const sixMonthsAgo = new Date();
                    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                    return violationDate && !isNaN(violationDate.getTime()) && violationDate < sixMonthsAgo;
                } catch (e) {
                    return false;
                }
            });
            if (oldUnpaid.length > 0) {
                facts.push({
                    title: '‚è∞ Old Cases Alert',
                    description: `${oldUnpaid.length} cases are over 6 months old with no activity - time to close or push these!`
                });
            }

            // 20. Recent Activity
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            const recentViolations = allData.filter(row => {
                try {
                    if (!row['Violation Date']) return false;
                    const date = new Date(row['Violation Date']);
                    return date && !isNaN(date.getTime()) && date > oneMonthAgo;
                } catch (e) {
                    return false;
                }
            });
            if (recentViolations.length > 0) {
                // Compare to previous month
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const previousMonthViolations = allData.filter(row => {
                    try {
                        if (!row['Violation Date']) return false;
                        const date = new Date(row['Violation Date']);
                        return date && !isNaN(date.getTime()) && date > twoMonthsAgo && date <= oneMonthAgo;
                    } catch (e) {
                        return false;
                    }
                });
                const change = previousMonthViolations.length > 0 
                    ? ((recentViolations.length / previousMonthViolations.length - 1) * 100).toFixed(0)
                    : 0;
                const direction = change > 0 ? 'up' : change < 0 ? 'down' : 'same';
                facts.push({
                    title: 'üìä Recent Activity Trend',
                    description: `You've had ${recentViolations.length} new violations this month - ${direction === 'same' ? 'holding steady' : direction === 'up' ? `up ${Math.abs(change)}% from last month!` : `down ${Math.abs(change)}% from last month`}`
                });
            }

            // 21. Payment Velocity by Quarter
            const q1Data = allData.filter(row => {
                const date = new Date(row['Date Submitted']);
                return !isNaN(date.getTime()) && date.getMonth() < 3;
            });
            const q1Paid = q1Data.filter(row => row['_rowType'] === 'paid').length;
            const q4Data = allData.filter(row => {
                const date = new Date(row['Date Submitted']);
                return !isNaN(date.getTime()) && date.getMonth() >= 9;
            });
            const q4Paid = q4Data.filter(row => row['_rowType'] === 'paid').length;
            if (q1Data.length >= 10 && q4Data.length >= 10) {
                const q1Rate = (q1Paid / q1Data.length * 100).toFixed(0);
                const q4Rate = (q4Paid / q4Data.length * 100).toFixed(0);
                const better = q1Rate > q4Rate ? 'Q1' : 'Q4';
                facts.push({
                    title: 'üìà Best Quarter',
                    description: `Violations submitted in ${better} are more likely to pay (${better === 'Q1' ? q1Rate : q4Rate}% vs ${better === 'Q1' ? q4Rate : q1Rate}%)`
                });
            }

            // INTERESTING PATTERNS

            // 22. Busiest Time of Day
            const hourCounts = {};
            allData.forEach(row => {
                const time = row['Violation Time'];
                if (time) {
                    const hour = parseInt(time.split(':')[0]);
                    if (!isNaN(hour)) {
                        hourCounts[hour] = (hourCounts[hour] || 0) + 1;
                    }
                }
            });
            if (Object.keys(hourCounts).length > 0) {
                const busiestHour = Object.keys(hourCounts).reduce((a, b) => hourCounts[a] > hourCounts[b] ? a : b);
                const period = busiestHour < 12 ? 'AM' : 'PM';
                const hour12 = busiestHour > 12 ? busiestHour - 12 : busiestHour === 0 ? 12 : busiestHour;
                facts.push({
                    title: '‚è∞ Peak Idling Hours',
                    description: `Most violations happen around ${hour12}${period} - prime time for truck idling!`
                });
            }

            // 23. Company Size Analysis
            const smallCompanies = Object.keys(companyCounts).filter(c => companyCounts[c] <= 3);
            const largeCompanies = Object.keys(companyCounts).filter(c => companyCounts[c] > 10);
            if (smallCompanies.length > 0 && largeCompanies.length > 0) {
                const smallCompanyData = allData.filter(row => smallCompanies.includes(row['Company Name']));
                const largeCompanyData = allData.filter(row => largeCompanies.includes(row['Company Name']));
                const smallPaidRate = (smallCompanyData.filter(r => r['_rowType'] === 'paid').length / smallCompanyData.length * 100).toFixed(0);
                const largePaidRate = (largeCompanyData.filter(r => r['_rowType'] === 'paid').length / largeCompanyData.length * 100).toFixed(0);
                const better = smallPaidRate > largePaidRate ? 'Small' : 'Large';
                facts.push({
                    title: 'üè¢ Company Size Pattern',
                    description: `${better} companies pay more reliably (${better === 'Small' ? smallPaidRate : largePaidRate}% vs ${better === 'Small' ? largePaidRate : smallPaidRate}%)`
                });
            }

            // 24. Hearing Success Rate
            const hearingCases = allData.filter(row => row['Hearing Result'] && row['Hearing Result'].trim() !== '');
            const hearingPaid = hearingCases.filter(row => row['_rowType'] === 'paid').length;
            const noHearingCases = allData.filter(row => !row['Hearing Result'] || row['Hearing Result'].trim() === '');
            const noHearingPaid = noHearingCases.filter(row => row['_rowType'] === 'paid').length;
            if (hearingCases.length >= 10 && noHearingCases.length >= 10) {
                const hearingRate = (hearingPaid / hearingCases.length * 100).toFixed(0);
                const noHearingRate = (noHearingPaid / noHearingCases.length * 100).toFixed(0);
                const better = hearingRate > noHearingRate ? 'with hearings' : 'without hearings';
                facts.push({
                    title: '‚öñÔ∏è Hearing Impact',
                    description: `Cases ${better} have a ${better === 'with hearings' ? hearingRate : noHearingRate}% success rate vs ${better === 'with hearings' ? noHearingRate : hearingRate}% - ${better === 'with hearings' ? 'fighting helps!' : 'settle early works better!'}`
                });
            }

            // 25. Chronic Offenders
            const chronicOffenders = Object.keys(companyCounts).filter(c => companyCounts[c] >= 5);
            if (chronicOffenders.length > 0) {
                const totalFromChronic = chronicOffenders.reduce((sum, company) => sum + companyCounts[company], 0);
                const percentOfTotal = (totalFromChronic / allData.length * 100).toFixed(0);
                facts.push({
                    title: 'üîÅ Repeat Offenders',
                    description: `${chronicOffenders.length} companies have 5+ violations - they represent ${percentOfTotal}% of your cases. They clearly aren't learning!`
                });
            }

            // 26. Collection Improvement
            try {
                const dates = allData.map(row => parseDateSafely(row['Violation Date'])).filter(d => d && !isNaN(d.getTime())).sort((a, b) => a - b);
                if (dates.length > 50) {
                    const midpoint = Math.floor(dates.length / 2);
                    const midDate = dates[midpoint];
                    const oldData = allData.filter(row => {
                        try {
                            const d = parseDateSafely(row['Violation Date']);
                            return d && !isNaN(d.getTime()) && d < midDate;
                        } catch (e) {
                            return false;
                        }
                    });
                    const newData = allData.filter(row => {
                        try {
                            const d = parseDateSafely(row['Violation Date']);
                            return d && !isNaN(d.getTime()) && d >= midDate;
                        } catch (e) {
                            return false;
                        }
                    });
                    const oldRate = (oldData.filter(r => r['_rowType'] === 'paid').length / oldData.length * 100).toFixed(1);
                    const newRate = (newData.filter(r => r['_rowType'] === 'paid').length / newData.length * 100).toFixed(1);
                    const change = (newRate - oldRate).toFixed(1);
                    if (Math.abs(change) > 1) {
                        facts.push({
                            title: 'üìä Performance Trend',
                            description: `Your collection rate has ${change > 0 ? 'improved' : 'decreased'} ${Math.abs(change)}% over time - ${change > 0 ? 'keep it up!' : 'time to revisit your strategy'}`
                        });
                    }
                }
            } catch (e) {
                console.log('Skipping Collection Improvement fact due to error:', e);
            }

            // 27. Revenue Concentration Analysis
            const revenueByCompany = {};
            allData.filter(row => row['_rowType'] === 'paid').forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (!isNaN(amount)) {
                    revenueByCompany[company] = (revenueByCompany[company] || 0) + amount;
                }
            });
            
            const totalPaidRevenue = Object.values(revenueByCompany).reduce((a, b) => a + b, 0);
            const sortedCompanies = Object.entries(revenueByCompany).sort((a, b) => b[1] - a[1]);
            
            if (sortedCompanies.length >= 3) {
                const top3Revenue = sortedCompanies.slice(0, 3).reduce((sum, [_, amt]) => sum + amt, 0);
                const top3Percent = (top3Revenue / totalPaidRevenue * 100).toFixed(0);
                const yourTop3 = top3Revenue * 0.25;
                
                facts.push({
                    title: 'üéØ Revenue Concentration',
                    description: `Your top 3 companies (${sortedCompanies[0][0]}, ${sortedCompanies[1][0]}, ${sortedCompanies[2][0]}) account for ${top3Percent}% of revenue ($${yourTop3.toFixed(2)}) - ${top3Percent > 50 ? 'high concentration risk!' : 'good diversification!'}`
                });
            }

            // Add walking facts
            let totalWalkingMiles = 0;
            Object.keys(walkingDataCache).forEach(dateKey => {
                Object.values(walkingDataCache[dateKey]).forEach(km => totalWalkingMiles += km * 0.621371);
            });
            
            if (totalWalkingMiles > 0) {
                const marathons = (totalWalkingMiles / 26.2).toFixed(1);
                facts.push({
                    icon: 'üö∂',
                    title: 'Marathon Walker',
                    description: `You walked ${totalWalkingMiles.toFixed(1)} miles during work - that's ${marathons} marathons worth of effort!`
                });
                
                const calories = (totalWalkingMiles * 100).toFixed(0);
                facts.push({
                    icon: 'üî•',
                    title: 'Calories Crushed',
                    description: `Walking ${totalWalkingMiles.toFixed(0)} miles burned approximately ${calories.toLocaleString()} calories!`
                });
                
                const milesPerSummons = (totalWalkingMiles / allData.length).toFixed(2);
                facts.push({
                    icon: 'üìä',
                    title: 'Walking Efficiency',
                    description: `You average ${milesPerSummons} miles per summons across all violations`
                });
            }
            
            // Weekend violations
            let weekendCount = 0;
            allData.forEach(row => {
                try {
                    if (!row['Violation Date']) return;
                    const date = new Date(row['Violation Date']);
                    if (date && !isNaN(date.getTime())) {
                        const dow = date.getDay();
                        if (dow === 0 || dow === 6) weekendCount++;
                    }
                } catch (e) {
                    // Skip invalid dates
                }
            });
            if (weekendCount > 0) {
                const weekendPercent = ((weekendCount / allData.length) * 100).toFixed(1);
                facts.push({
                    icon: 'üìÖ',
                    title: 'Weekend Warrior',
                    description: `${weekendCount} summonses (${weekendPercent}%) were issued on weekends - extra hustle pays off!`
                });
            }
            
            // Rain violations (using weatherDataCache)
            let rainCount = 0;
            allData.forEach(row => {
                const dateKey = row['Violation Date'];
                if (dateKey && weatherDataCache[dateKey]) {
                    Object.values(weatherDataCache[dateKey]).forEach(weather => {
                        if (weather.precipitation > 0.5) rainCount++;
                    });
                }
            });
            if (rainCount > 0) {
                facts.push({
                    icon: 'üåßÔ∏è',
                    title: 'Rain or Shine',
                    description: `${rainCount} summonses were issued during rainy conditions - you don't let weather stop you!`
                });
            }
            
            // Best performing day of week (5+ summons only)
            const dowPerformance = {};
            const dowNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            // Group by date first, then calculate daily averages
            const dailyStats = {};
            allData.forEach(row => {
                const dateKey = row['Violation Date'];
                if (!dateKey) return;
                const d = dateKeyToNYCDate(dateKey);
                if (!d || isNaN(d.getTime())) return;
                
                const dow = d.getDay();
                if (!dailyStats[dateKey]) {
                    dailyStats[dateKey] = { count: 0, dow: dow, collected: 0, paid: 0 };
                }
                dailyStats[dateKey].count++;
                
                if (row['_rowType'] === 'paid') {
                    dailyStats[dateKey].paid++;
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) dailyStats[dateKey].collected += amount * 0.25;
                }
            });
            
            // Now calculate averages per DOW (only days with 5+ summonses)
            Object.values(dailyStats).forEach(day => {
                if (day.count >= 5) {
                    if (!dowPerformance[day.dow]) {
                        dowPerformance[day.dow] = { totalDays: 0, totalSummonses: 0, totalCollected: 0, totalPaid: 0 };
                    }
                    dowPerformance[day.dow].totalDays++;
                    dowPerformance[day.dow].totalSummonses += day.count;
                    dowPerformance[day.dow].totalCollected += day.collected;
                    dowPerformance[day.dow].totalPaid += day.paid;
                }
            });
            
            // Calculate averages and find best day
            let bestWorkDOW = null;
            let bestAvg = 0;
            Object.keys(dowPerformance).forEach(dow => {
                const stats = dowPerformance[dow];
                stats.avgSummonses = stats.totalSummonses / stats.totalDays;
                stats.avgCollected = stats.totalCollected / stats.totalDays;
                stats.avgPaid = stats.totalPaid / stats.totalDays;
                
                if (stats.avgSummonses > bestAvg) {
                    bestAvg = stats.avgSummonses;
                    bestWorkDOW = dow;
                }
            });
            
            if (bestWorkDOW !== null && dowPerformance[bestWorkDOW].totalDays >= 3) {
                const stats = dowPerformance[bestWorkDOW];
                facts.push({
                    icon: 'üìÖ',
                    title: 'Best Day of the Week',
                    description: `${dowNames[bestWorkDOW]} is your most productive day averaging ${stats.avgSummonses.toFixed(1)} summonses and $${stats.avgCollected.toFixed(2)} collected per shift (based on ${stats.totalDays} ${dowNames[bestWorkDOW]}s with 5+ summonses)`
                });
            }
            
            // Shuffle for variety
            facts.sort(() => Math.random() - 0.5);

            // Render all facts with desktop-optimized grid layout
            container.innerHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 15px;">' +
            facts.map(fact => `
                <div style="background: white; padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column;">
                    <h4 style="color: #1e3c72; margin-bottom: 10px; font-size: 1em;">${fact.icon || ''} ${fact.title}</h4>
                    <p style="color: #2c3e50; line-height: 1.5; font-size: 0.9em; margin: 0;">${fact.description}</p>
                </div>
            `).join('') + '</div>';
            
            // Add weather facts asynchronously (non-blocking)
            addWeatherFacts(allData, container);
            
        } catch (error) {
            console.error('Error generating fun facts:', error);
            console.error('Error stack:', error.stack);
            container.innerHTML = `<div style="background: #fff3cd; padding: 15px; border-radius: 6px; border-left: 4px solid #ffc107;">
                <h4 style="color: #856404; margin: 0 0 10px 0;">‚ö†Ô∏è Error Generating Fun Facts</h4>
                <p style="color: #856404; margin: 0;">There was an error generating fun facts. Error: ${error.message}</p>
                <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.85em; margin-top: 10px;">${error.stack}</pre>
                <button class="btn btn-primary" onclick="generateFunFacts()" style="margin-top: 10px;">üîÑ Try Again</button>
            </div>`;
        }
        }
        
        // Simple weather API helper
        async function getWeatherForDate(dateStr) {
            try {
                const url = `https://archive-api.open-meteo.com/v1/archive?latitude=40.7128&longitude=-74.0060&start_date=${dateStr}&end_date=${dateStr}&daily=temperature_2m_mean,precipitation_sum&temperature_unit=fahrenheit&timezone=America/New_York`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.daily && data.daily.temperature_2m_mean && data.daily.temperature_2m_mean[0]) {
                    return {
                        temp: Math.round(data.daily.temperature_2m_mean[0]),
                        precip: data.daily.precipitation_sum[0] || 0
                    };
                }
            } catch (e) {
                console.log('Weather API error:', e);
            }
            return null;
        }
        
        // Add weather-based facts without blocking
        async function addWeatherFacts(allData, container) {
            try {
                // Group by date
                const dateGroups = {};
                allData.forEach(row => {
                    const date = row['Violation Date'];
                    if (date) {
                        const d = new Date(date);
                        const dateKey = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
                        if (!dateGroups[dateKey]) dateGroups[dateKey] = [];
                        dateGroups[dateKey].push(row);
                    }
                });
                
                // Sample up to 20 recent days
                const dates = Object.keys(dateGroups).sort().reverse().slice(0, 20);
                const weatherData = [];
                
                for (const dateKey of dates) {
                    const weather = await getWeatherForDate(dateKey);
                    if (weather) {
                        weatherData.push({
                            date: dateKey,
                            temp: weather.temp,
                            precip: weather.precip,
                            count: dateGroups[dateKey].length
                        });
                    }
                }
                
                if (weatherData.length < 10) return; // Not enough data
                
                // Analyze temperature impact
                const cold = weatherData.filter(d => d.temp < 50);
                const nice = weatherData.filter(d => d.temp >= 50 && d.temp < 75);
                const hot = weatherData.filter(d => d.temp >= 75);
                
                let bestRange = null;
                let bestAvg = 0;
                
                if (cold.length >= 3) {
                    const avg = cold.reduce((s, d) => s + d.count, 0) / cold.length;
                    if (avg > bestAvg) { bestAvg = avg; bestRange = { name: 'cold (<50¬∞F)', emoji: 'ü•∂', avg }; }
                }
                if (nice.length >= 3) {
                    const avg = nice.reduce((s, d) => s + d.count, 0) / nice.length;
                    if (avg > bestAvg) { bestAvg = avg; bestRange = { name: 'nice (50-75¬∞F)', emoji: 'üòä', avg }; }
                }
                if (hot.length >= 3) {
                    const avg = hot.reduce((s, d) => s + d.count, 0) / hot.length;
                    if (avg > bestAvg) { bestAvg = avg; bestRange = { name: 'hot (75¬∞F+)', emoji: 'üî•', avg }; }
                }
                
                if (bestRange) {
                    const weatherFact = `
                        <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <h4 style="color: white; margin-bottom: 10px; font-size: 1em;">${bestRange.emoji} Best Weather for Hunting</h4>
                            <p style="color: white; line-height: 1.5; font-size: 0.9em;">Your most productive temperature is ${bestRange.name} with ${bestRange.avg.toFixed(1)} summonses/day average!</p>
                        </div>
                    `;
                    container.innerHTML += weatherFact;
                }
                
                // Rain analysis
                const clear = weatherData.filter(d => d.precip === 0);
                const rainy = weatherData.filter(d => d.precip > 0.1);
                
                if (clear.length >= 5 && rainy.length >= 3) {
                    const clearAvg = clear.reduce((s, d) => s + d.count, 0) / clear.length;
                    const rainyAvg = rainy.reduce((s, d) => s + d.count, 0) / rainy.length;
                    const diff = Math.abs(((clearAvg - rainyAvg) / rainyAvg * 100));
                    
                    if (diff > 20) {
                        const better = clearAvg > rainyAvg ? 'clear' : 'rainy';
                        const emoji = better === 'clear' ? '‚òÄÔ∏è' : 'üåßÔ∏è';
                        const rainFact = `
                            <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                <h4 style="color: white; margin-bottom: 10px; font-size: 1em;">${emoji} Weather Impact</h4>
                                <p style="color: white; line-height: 1.5; font-size: 0.9em;">You catch ${diff.toFixed(0)}% more violations on ${better} days (${better === 'clear' ? clearAvg.toFixed(1) : rainyAvg.toFixed(1)} vs ${better === 'clear' ? rainyAvg.toFixed(1) : clearAvg.toFixed(1)} avg)!</p>
                            </div>
                        `;
                        container.innerHTML += rainFact;
                    }
                }
            } catch (e) {
                console.log('Could not add weather facts:', e);
            }
        }

        // ===== TIME ANALYSIS FUNCTIONS =====
        
        // Normalize date to YYYY-MM-DD format
        function normalizeDate(dateStr) {
            if (!dateStr) return null;
            
            // If already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // If ISO format with time, extract just the date part
            if (/^\d{4}-\d{2}-\d{2}T/.test(dateStr)) {
                return dateStr.split('T')[0];
            }
            
            // If MM/DD/YYYY format, parse manually
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }
            
            // Try parsing as date with explicit time to avoid timezone issues
            try {
                const date = new Date(dateStr + ' 00:00:00');
                if (isNaN(date.getTime())) return null;
                
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (e) {
                console.error('Error normalizing date:', dateStr, e);
                return null;
            }
        }
        
        // Helper function to convert YYYY-MM-DD string to Date object in NYC timezone
        // All summonses are in NYC, so we need to use Eastern time consistently
        function dateKeyToNYCDate(dateKey) {
            if (!dateKey) return null;
            const match = dateKey.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (!match) return null;
            const [_, year, month, day] = match;
            // Create date string in format that forces NYC timezone interpretation
            const dateStr = `${year}-${month}-${day}T12:00:00-05:00`; // Use noon EST to avoid DST edge cases
            return new Date(dateStr);
        }
        
        // Safe date parser that handles any date format and converts to NYC timezone
        function parseDateSafely(dateStr) {
            if (!dateStr) return null;
            
            // If it's already a Date object, return it
            if (dateStr instanceof Date) return dateStr;
            
            // If it's YYYY-MM-DD format, use dateKeyToNYCDate
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateKeyToNYCDate(dateStr);
            }
            
            // If it's YYYY-MM-DDTHH:MM:SS format, extract date part
            if (/^\d{4}-\d{2}-\d{2}T/.test(dateStr)) {
                const datePart = dateStr.split('T')[0];
                return dateKeyToNYCDate(datePart);
            }
            
            // If MM/DD/YYYY format, parse manually and create NYC date
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const year = parts[2];
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                return dateKeyToNYCDate(`${year}-${month}-${day}`);
            }
            
            // For other formats, try to extract date components and use NYC timezone
            const d = new Date(dateStr);
            if (isNaN(d.getTime())) return null;
            const year = d.getUTCFullYear();
            const month = String(d.getUTCMonth() + 1).padStart(2, '0');
            const day = String(d.getUTCDate()).padStart(2, '0');
            return dateKeyToNYCDate(`${year}-${month}-${day}`);
        }
        
        // Get day of week for a YYYY-MM-DD date key in NYC timezone
        function getDayOfWeekNYC(dateKey) {
            const date = dateKeyToNYCDate(dateKey);
            if (!date) return null;
            return date.getDay();
        }
        
        // Format a date key as a readable string in NYC timezone
        function formatDateKeyNYC(dateKey) {
            const date = dateKeyToNYCDate(dateKey);
            if (!date) return '';
            return date.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                timeZone: 'America/New_York'
            });
        }
        
        // Walking distance data cache - organized by date and hour
        // Structure: walkingDataCache["2024-09-15"][14] = miles for 2PM-3PM
        const walkingDataCache = {};
        const weatherDataCache = {};
        let walkingDataLoadedDates = new Set();
        
        // Fetch and parse walking data from Google Sheets CSV for specific dates
        async function loadWalkingDataForDates(dateKeys) {
            const datesToFetch = dateKeys.filter(d => !walkingDataLoadedDates.has(d));
            if (datesToFetch.length === 0) {
                console.log('All walking data already loaded');
                return;
            }
            
            console.log('Loading walking data for', datesToFetch.length, 'dates');
            
            
            try {
                const csvUrl = sheetURLs.walking;
                if (!csvUrl) {
                    console.error('Walking data URL not configured');
                    return;
                }
                
                console.log('Fetching from:', csvUrl);
                
                // Use fetchWithCORS like the other datasets
                const csvText = await fetchWithCORS(csvUrl);
                
                console.log('CSV loaded, length:', csvText.length, 'chars');
                
                // Parse CSV - format is: start_period,end_period,value
                const lines = csvText.split('\n');
                console.log('Total lines:', lines.length);
                
                let processedCount = 0;
                
                for (let i = 1; i < lines.length; i++) { // Skip header
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        const startPeriod = parts[0].trim();
                        const kmValue = parseFloat(parts[2].trim());
                        
                        if (!isNaN(kmValue)) {
                            // Parse timestamp - format is "YYYY-MM-DD HH:00:00" already in NYC time
                            try {
                                // Extract date and hour directly without timezone conversion
                                const match = startPeriod.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2})/);
                                if (match) {
                                    const [_, year, month, day, hour] = match;
                                    const dateKey = `${year}-${month}-${day}`;
                                    const hourNum = parseInt(hour);
                                        
                                        // Only process dates we need
                                        if (datesToFetch.includes(dateKey)) {
                                            
                                            if (!walkingDataCache[dateKey]) {
                                                walkingDataCache[dateKey] = {};
                                            }
                                            // Convert km to miles and accumulate if there's already data for this hour
                                            if (!walkingDataCache[dateKey][hourNum]) {
                                                walkingDataCache[dateKey][hourNum] = 0;
                                            }
                                            walkingDataCache[dateKey][hourNum] += kmValue * 0.621371;
                                            
                                            // Extract weather
                                            const temperature = parts.length >= 4 ? parseFloat(parts[3].trim()) : null;
                                            const precipitation = parts.length >= 5 ? parseFloat(parts[4].trim()) : 0;
                                            
                                            if (!weatherDataCache[dateKey]) {
                                                weatherDataCache[dateKey] = {};
                                            }
                                            if (!isNaN(temperature) || precipitation > 0) {
                                                weatherDataCache[dateKey][hourNum] = {
                                                    temperature: temperature,
                                                    precipitation: precipitation
                                                };
                                            }
                                            
                                            processedCount++;
                                        }
                                }
                            } catch (e) {
                                console.error('Error parsing timestamp:', startPeriod, e);
                            }
                        }
                    }
                }
                
                // Mark dates as loaded (even if no data found)
                datesToFetch.forEach(dateKey => {
                    walkingDataLoadedDates.add(dateKey);
                });
                
                console.log('Walking data loaded successfully:', processedCount, 'records processed');
                console.log('Dates with data:', Object.keys(walkingDataCache).length);
            } catch (error) {
                console.error('Failed to load walking data:', error);
                console.error('Error details:', error.message, error.stack);
                // Don't show alert - just log
            }
        }
        
        // Calculate walking distance during work hours only (excluding breaks)
        function getWalkingDistanceForWorkHours(dateKey, workSegments) {
            
            
            
            const hourlyData = walkingDataCache[dateKey];
            if (!hourlyData) {
                
                return 0;
            }
            
            
            let totalMiles = 0;
            
            // For each work segment
            workSegments.forEach(segment => {
                // Convert segment minutes to hours
                const startHour = Math.floor(segment.start / 60);
                const endHour = Math.ceil(segment.end / 60);
                
                // Sum up walking distance for hours that overlap with work
                for (let hour = startHour; hour < endHour; hour++) {
                    if (hourlyData[hour]) {
                        // Calculate what portion of this hour is actually work time
                        const hourStartMinutes = hour * 60;
                        const hourEndMinutes = (hour + 1) * 60;
                        const workStartInHour = Math.max(segment.start, hourStartMinutes);
                        const workEndInHour = Math.min(segment.end, hourEndMinutes);
                        const minutesWorked = workEndInHour - workStartInHour;
                        
                        // Prorate the walking distance for this hour
                        const proportion = minutesWorked / 60;
                        totalMiles += hourlyData[hour] * proportion;
                    }
                }
            });
            
            
            return totalMiles;
        }
        
        // Get total walking distance for entire day (for comparison)

        function getWeatherAtNoon(dateKey) {
            if (weatherDataCache[dateKey] && weatherDataCache[dateKey][12]) {
                return weatherDataCache[dateKey][12];
            }
            return { temperature: null, precipitation: 0 };
        }
        
        function getWeatherEmoji(temp, precip) {
            if (precip > 5) return 'üåßÔ∏è';
            if (precip > 0.5) return 'üå¶Ô∏è';
            if (temp >= 85) return '‚òÄÔ∏è';
            if (temp >= 70) return '‚õÖ';
            if (temp >= 50) return 'üå§Ô∏è';
            if (temp >= 32) return '‚ùÑÔ∏è';
            if (temp < 32) return 'ü•∂';
            return 'üå•Ô∏è';
        }
        
        function calculateHoursWorked(workSegments) {
            let totalMins = 0;
            workSegments.forEach(seg => { totalMins += (seg.end - seg.start); });
            return totalMins / 60;
        }
        function getTotalWalkingDistanceForDate(dateKey) {
            const hourlyData = walkingDataCache[dateKey];
            if (!hourlyData) {
                // Debug: show available dates on first few misses
                if (Object.keys(walkingDataCache).length > 0 && Math.random() < 0.01) {
                    console.log('Walking cache miss for:', dateKey, 'Available dates sample:', Object.keys(walkingDataCache).slice(0, 5));
                }
                return 0;
            }
            
            return Object.values(hourlyData).reduce((sum, miles) => sum + miles, 0);
        }
        
        function getAverageTemperatureForDate(dateKey) {
            const hourlyData = weatherDataCache[dateKey];
            if (!hourlyData) return null;
            
            const temps = Object.values(hourlyData)
                .map(h => h.temperature)
                .filter(t => t !== null && !isNaN(t));
            
            if (temps.length === 0) return null;
            
            const sum = temps.reduce((acc, t) => acc + t, 0);
            return Math.round(sum / temps.length);
        }
        
        // Load walking data for the currently selected time period
        async function loadWalkingDataForPeriod() {
            const dataset = document.getElementById('time-dataset').value;
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            
            // Get all dates that have summons
            const datesWithSummons = Object.keys(grouped).filter(dateKey => {
                return grouped[dateKey].count > 0;
            });
            
            if (datesWithSummons.length === 0) {
                alert('No summons found in the selected period. Please select a different time period.');
                return;
            }
            
            await loadWalkingDataForDates(datesWithSummons);
            
            // Refresh the current view to show the walking data
            generateTimeAnalysis();
        }
        
        // Load walking data for a single day and refresh the display
        async function loadWalkingDataForSingleDay(dateKey) {
            await loadWalkingDataForDates([dateKey]);
            
            // Refresh the day detail view
            const dataset = document.getElementById('time-dataset').value;
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            const dayData = grouped[dateKey];
            
            if (dayData) {
                showDayDetail(dateKey, dayData, dataset);
            }
        }
        
        let currentTimeView = 'daily';
        let currentTimeYear = 2024;
        let currentTimeMonth = 11; // December 2024 (0-indexed)
        let selectedDate = null;
        let currentWeekStart = null;
        
        function switchTimeView(view) {
            currentTimeView = view;
            const dailyBtn = document.getElementById('view-daily-btn');
            const weeklyBtn = document.getElementById('view-weekly-btn');
            
            if (view === 'daily') {
                dailyBtn.className = 'btn btn-primary';
                weeklyBtn.className = 'btn';
                document.getElementById('daily-view').style.display = 'block';
                document.getElementById('weekly-view').style.display = 'none';
            } else {
                dailyBtn.className = 'btn';
                weeklyBtn.className = 'btn btn-primary';
                document.getElementById('daily-view').style.display = 'none';
                document.getElementById('weekly-view').style.display = 'block';
            }
            
            generateTimeAnalysis();
        }
        
        function initializeTimeAnalysis() {
            const yearSelect = document.getElementById('time-year');
            const currentYear = new Date().getFullYear();
            yearSelect.innerHTML = '';
            for (let year = currentYear; year >= 2020; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            }
            
            const monthSelect = document.getElementById('time-month');
            const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                          'July', 'August', 'September', 'October', 'November', 'December'];
            monthSelect.innerHTML = '';
            months.forEach((month, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = month;
                monthSelect.appendChild(option);
            });
            
            yearSelect.value = currentTimeYear;
            monthSelect.value = currentTimeMonth;
        }
        
        function generateTimeAnalysis() {
            const dataset = document.getElementById('time-dataset').value;
            currentTimeYear = parseInt(document.getElementById('time-year').value);
            currentTimeMonth = parseInt(document.getElementById('time-month').value);
            
            if (currentTimeView === 'daily') {
                generateCalendar(dataset);
            } else {
                generateWeeklyView(dataset);
            }
        }
        
        function getTimeAnalysisData(dataset) {
            let data = [];
            if (dataset === 'all') {
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    data.push(...appData[tab].merged.map(row => ({ ...row, _dataset: tab })));
                });
            } else {
                data = appData[dataset].merged.map(row => ({ ...row, _dataset: dataset }));
            }
            return data;
        }
        
        function groupDataByDate(data) {
            const grouped = {};
            
            data.forEach(row => {
                // ONLY use Violation Date from NYC enrichment
                // Skip rows that don't have NYC violation date yet
                const violationDate = row['Violation Date'];
                if (!violationDate) return; // Skip if no violation date
                
                // Parse date - all dates should be interpreted as NYC time
                let dateKey;
                if (violationDate.match(/^\d{4}-\d{2}-\d{2}T/)) {
                    // ISO format like "2023-12-13T00:00:00.000"
                    // Extract YYYY-MM-DD directly without timezone conversion
                    dateKey = violationDate.split('T')[0];
                    
                } else if (violationDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    // Already in YYYY-MM-DD format
                    dateKey = violationDate;
                } else if (violationDate.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                    // MM/DD/YYYY format - parse manually to avoid timezone issues
                    const parts = violationDate.split('/');
                    const month = parts[0].padStart(2, '0');
                    const day = parts[1].padStart(2, '0');
                    const year = parts[2];
                    dateKey = `${year}-${month}-${day}`;
                } else {
                    // Other formats - try to parse but use UTC to avoid timezone shifts
                    const date = new Date(violationDate + ' 00:00:00');
                    if (isNaN(date.getTime())) return;
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    dateKey = `${year}-${month}-${day}`;
                    
                }
                
                if (!grouped[dateKey]) {
                    grouped[dateKey] = { date: dateKey, summonses: [], count: 0, collectedRevenue: 0, potentialRevenue: 0 };
                }
                
                const violationTime = row['Violation Time'] || row['Time of Occurrence'] || '';
                const paidAmount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                const balanceDue = parseFloat((row['Balance Due'] || '0').replace(/[$,]/g, ''));
                const rowType = row['_rowType'];
                
                grouped[dateKey].summonses.push({
                    time: violationTime,
                    number: row['Summons Number'],
                    address: row['Place of Occurrence'] || row['Violation Location (Street Name)'] || '',
                    company: row['Company Name'],
                    paidAmount: paidAmount,
                    balanceDue: balanceDue,
                    rowType: rowType
                });
                
                grouped[dateKey].count++;
                
                // Calculate collected (paid + requested) vs potential (outstanding)
                if (rowType === 'paid' || rowType === 'requested') {
                    // Already collected or requested - use Paid Amount
                    if (!isNaN(paidAmount) && paidAmount > 0) {
                        grouped[dateKey].collectedRevenue += paidAmount * 0.25;
                    }
                } else {
                    // Outstanding - potential is 25% of (Balance Due + Paid Amount)
                    const totalAmount = (isNaN(balanceDue) ? 0 : balanceDue) + (isNaN(paidAmount) ? 0 : paidAmount);
                    if (totalAmount > 0) {
                        grouped[dateKey].potentialRevenue += totalAmount * 0.25;
                    }
                }
            });
            
            return grouped;
        }
        
        function generateCalendar(dataset) {
            console.log('=== generateCalendar CALLED ===', new Date().toISOString());
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            
            console.log('generateCalendar - dataset:', dataset);
            console.log('generateCalendar - data rows:', data.length);
            console.log('generateCalendar - grouped dates:', Object.keys(grouped).length);
            console.log('generateCalendar - sample dates:', Object.keys(grouped).slice(0, 10));
            console.log('generateCalendar - viewing:', currentTimeYear, currentTimeMonth);
            
            // Sample some rows to see if they have Violation Date
            if (data.length > 0) {
                console.log('generateCalendar - first row has these fields:', Object.keys(data[0]).join(', '));
                console.log('generateCalendar - first 3 rows with Violation Date:');
                const rowsWithViolationDate = data.filter(r => r['Violation Date']).slice(0, 3);
                console.log(`  Found ${rowsWithViolationDate.length} rows with Violation Date out of ${data.length} total`);
                rowsWithViolationDate.forEach((row, idx) => {
                    console.log(`  Row ${idx}:`, {
                        'Summons': row['Summons Number'],
                        'Violation Date': row['Violation Date'],
                        'Date Submitted': row['Date Submitted']
                    });
                });
            }
            
            const year = currentTimeYear;
            const month = currentTimeMonth;
            
            // Use UTC to avoid timezone shifts that cause day-of-week misalignment
            const firstDay = new Date(Date.UTC(year, month, 1));
            const lastDay = new Date(Date.UTC(year, month + 1, 0));
            const daysInMonth = lastDay.getUTCDate();
            const startDay = firstDay.getUTCDay();
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            document.getElementById('calendar-title').textContent = monthNames[month] + ' ' + year;
            
            const calendarGrid = document.getElementById('calendar-grid');
            calendarGrid.innerHTML = '';
            
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(day => {
                const header = document.createElement('div');
                header.style.cssText = 'text-align: center; font-weight: bold; color: #667eea; padding: 10px; font-size: 0.9em;';
                header.textContent = day;
                calendarGrid.appendChild(header);
            });
            
            for (let i = 0; i < startDay; i++) {
                calendarGrid.appendChild(document.createElement('div'));
            }
            
            for (let day = 1; day <= daysInMonth; day++) {
                // Use UTC to avoid timezone shifts
                const dateObj = new Date(Date.UTC(year, month, day));
                // Build dateKey directly to avoid timezone conversion
                const dateKey = year + '-' + String(month + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                const dayData = grouped[dateKey];
                const isWeekend = dateObj.getUTCDay() === 0 || dateObj.getUTCDay() === 6;
                
                const dayCell = document.createElement('div');
                dayCell.style.cssText = 'padding: 10px; border-radius: 8px; cursor: pointer; transition: all 0.2s; min-height: 90px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;';
                
                let bgColor = isWeekend ? '#e0e0e0' : '#f8f9fa';
                let borderColor = '#dee2e6';
                
                if (dayData) {
                    if (dayData.count >= 10) {
                        bgColor = isWeekend ? '#c0c0c0' : '#d4edda';
                        borderColor = isWeekend ? '#ff9800' : '#28a745';
                    } else if (dayData.count >= 5) {
                        bgColor = '#fff3cd';
                        borderColor = '#ffc107';
                    } else {
                        bgColor = isWeekend ? '#d0d0d0' : '#e7f3ff';
                        borderColor = isWeekend ? '#ff9800' : '#667eea';
                    }
                    
                    dayCell.style.background = bgColor;
                    dayCell.style.border = '2px solid ' + borderColor;
                    
                    let revenueHtml = '';
                    if (dayData.collectedRevenue > 0) {
                        revenueHtml += '<div style="font-size: 0.85em; color: #28a745; font-weight: bold;">$' + dayData.collectedRevenue.toFixed(0) + '</div>';
                    }
                    if (dayData.potentialRevenue > 0) {
                        revenueHtml += '<div style="font-size: 0.75em; color: #ffc107; font-style: italic;">$' + dayData.potentialRevenue.toFixed(0) + '</div>';
                    }
                    
                    // Build enhanced cell - calculate all metrics first
                    const times = dayData.summonses.map(s => {
                        const time = s.time;
                        if (!time) return 0;
                        const [hours, minutes] = time.split(':').map(Number);
                        return hours * 60 + minutes;
                    }).filter(t => t > 0).sort((a, b) => a - b);
                    
                    let hoursWorked = 0;
                    let milesWalked = 0;
                    if (times.length > 0) {
                        const workSegments = calculateWorkSegments(times);
                        hoursWorked = calculateHoursWorked(workSegments);
                        milesWalked = getWalkingDistanceForWorkHours(dateKey, workSegments);
                    }
                    
                    const weather = getWeatherAtNoon(dateKey);
                    let weatherStr = '';
                    if (weather.temperature !== null) {
                        const weatherEmoji = getWeatherEmoji(weather.temperature, weather.precipitation);
                        weatherStr = weatherEmoji + Math.round(weather.temperature) + '¬∞';
                    }
                    
                    let cellHTML = '<div style="font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 3px;">' + day + '</div>';
                    cellHTML += '<div style="font-size: 0.85em; color: #666; margin-bottom: 2px;">üìπ ' + dayData.count + '</div>';
                    
                    // Combine hours and miles on one line
                    if (hoursWorked > 0 && milesWalked > 0) {
                        cellHTML += '<div style="font-size: 0.73em; color: #555; margin: 1px 0;">‚è±Ô∏è' + hoursWorked.toFixed(1) + 'h üö∂' + milesWalked.toFixed(1) + 'mi</div>';
                    } else if (hoursWorked > 0) {
                        cellHTML += '<div style="font-size: 0.73em; color: #555; margin: 1px 0;">‚è±Ô∏è ' + hoursWorked.toFixed(1) + 'h</div>';
                    } else if (milesWalked > 0) {
                        cellHTML += '<div style="font-size: 0.73em; color: #555; margin: 1px 0;">üö∂ ' + milesWalked.toFixed(1) + ' mi</div>';
                    }
                    
                    if (weatherStr) {
                        cellHTML += '<div style="font-size: 0.73em; color: #3498db; margin: 1px 0;">' + weatherStr + '</div>';
                    }
                    
                    cellHTML += revenueHtml;
                    dayCell.innerHTML = cellHTML;
                } else {
                    dayCell.style.background = bgColor;
                    dayCell.style.border = '2px solid ' + borderColor;
                    dayCell.innerHTML = '<div style="font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 5px;">' + day + '</div>';
                }
                
                if (dayData) {
                    dayCell.onclick = () => showDayDetail(dateKey, dayData, dataset);
                    dayCell.onmouseover = () => { dayCell.style.transform = 'scale(1.05)'; dayCell.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)'; };
                    dayCell.onmouseout = () => { dayCell.style.transform = 'scale(1)'; dayCell.style.boxShadow = 'none'; };
                }
                
                calendarGrid.appendChild(dayCell);
            }
        }
        


        function calculateExpectedRevenue(count) {
            return count * 82.50;
        }
        function populateWalkingInsights() {
            let totalMiles = 0;
            Object.keys(walkingDataCache).forEach(dateKey => {
                Object.values(walkingDataCache[dateKey]).forEach(m => totalMiles += m);
            });
            
            const el1 = document.getElementById('walking-insight-total');
            if (el1 && totalMiles > 0) {
                el1.innerHTML = 'You walked <strong>' + totalMiles.toFixed(1) + ' miles</strong>. That is <strong>' + (totalMiles / 26.2).toFixed(1) + ' marathons</strong>!';
            }
            
            const el2 = document.getElementById('walking-insight-efficiency');
            if (el2) {
                const total = ['at', 'at-nyc', 'mbt'].reduce((s, t) => s + appData[t].merged.length, 0);
                if (total > 0 && totalMiles > 0) {
                    el2.innerHTML = 'Average <strong>' + (totalMiles / total).toFixed(2) + ' miles per summons</strong>.';
                }
            }
        }
        
        function populateViolationTypes() {
            let c = {BA51: 0, BA1E: 0, BA1F: 0, BA1I: 0, BA1JK: 0, Other: 0};
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                appData[tab].merged.forEach(row => {
                    const code = row['Charge Code'] || '';
                    if (code === 'BA51') c.BA51++;
                    else if (code === 'BA1E') c.BA1E++;
                    else if (code === 'BA1F') c.BA1F++;
                    else if (code === 'BA1I') c.BA1I++;
                    else if (code === 'BA1J' || code === 'BA1K') c.BA1JK++;
                    else if (code) c.Other++;
                });
            });
            const s = (id, v) => { const e = document.getElementById(id); if (e) e.textContent = v; };
            s('ba51-count', c.BA51); s('ba1e-count', c.BA1E); s('ba1f-count', c.BA1F);
            s('ba1i-count', c.BA1I); s('ba1jk-count', c.BA1JK); s('other-count', c.Other);
        }
        
        function populateBestDayOfWeek() {
            const dn = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dc = [0, 0, 0, 0, 0, 0, 0], ds = [0, 0, 0, 0, 0, 0, 0];
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                const g = {};
                appData[tab].merged.forEach(row => {
                    const date = row['Violation Date'];
                    if (!date) return;
                    const k = new Date(date).toISOString().split('T')[0];
                    if (!g[k]) g[k] = {count: 0, rev: 0};
                    g[k].count++;
                    g[k].rev += parseFloat((row['Paid To Me'] || '0').replace(/[$,]/g, ''));
                });
                Object.keys(g).forEach(k => {
                    if (g[k].count >= 5) {
                        const dow = dateKeyToNYCDate(k).getDay();
                        dc[dow]++; ds[dow] += g[k].rev;
                    }
                });
            });
            let bd = -1, ba = 0;
            for (let i = 0; i < 7; i++) {
                if (dc[i] > 0) {
                    const a = ds[i] / dc[i];
                    if (a > ba) { ba = a; bd = i; }
                }
            }
            const el = document.getElementById('best-day-week');
            if (el && bd >= 0) el.innerHTML = '<strong>' + dn[bd] + '</strong> averages <strong>$' + ba.toFixed(2) + '</strong> per day.';
        }
        
        
        
        function checkDateInData(searchDate) {
            console.log('=== Checking for', searchDate, '===');
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                const matches = appData[tab].merged.filter(r => {
                    const vd = r['Violation Date'];
                    if (!vd) return false;
                    return vd.includes(searchDate);
                });
                if (matches.length > 0) {
                    console.log(tab + ':', matches.length, 'summons');
                    console.log('Sample dates:', matches.slice(0, 3).map(r => r['Violation Date']));
                }
            });
        }
        
function debugWalkingData(dateKey) {
            console.log('=== Walking Data Debug for', dateKey, '===');
            console.log('Date in cache?', dateKey in walkingDataCache);
            if (walkingDataCache[dateKey]) {
                console.log('Hourly data:', walkingDataCache[dateKey]);
                const total = Object.values(walkingDataCache[dateKey]).reduce((sum, km) => sum + (km * 0.621371), 0);
                console.log('Total miles:', total.toFixed(2));
            }
            console.log('All dates in cache:', Object.keys(walkingDataCache).sort());
        }
        
async function showDayDetail(dateKey, dayData, dataset) {
            
            selectedDate = dateKey;
            const date = dateKeyToNYCDate(dateKey);
            const dayName = date.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'America/New_York' });
            const dateStr = date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric', timeZone: 'America/New_York' });
            
            document.getElementById('day-detail-title').textContent = dayName + ', ' + dateStr;
            document.getElementById('day-detail').style.display = 'block';
            
            // Walking data should already be loaded from main data load
            
            
            const collectedRevenue = dayData.collectedRevenue;
            const potentialRevenue = dayData.potentialRevenue;
            const totalRevenue = collectedRevenue + potentialRevenue;
            
            // Calculate shift times with break detection
            const times = dayData.summonses.map(s => parseTime(s.time)).filter(t => t !== null).sort((a, b) => a - b);
            let workSegments = [];
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">';
            
            if (times.length > 0) {
                // Detect breaks (2.5 hours or more between summonses)
                const breakThresholdMinutes = 150; // 2.5 hours
                let currentSegmentStart = times[0];
                let currentSegmentEnd = times[0];
                
                for (let i = 1; i < times.length; i++) {
                    const gap = times[i] - times[i-1];
                    if (gap >= breakThresholdMinutes) {
                        // Break detected - end current segment 30 min after last summons
                        workSegments.push({
                            start: Math.max(0, currentSegmentStart - 30),
                            end: Math.min(1439, currentSegmentEnd + 30)
                        });
                        // Start new segment 30 min before next summons
                        currentSegmentStart = times[i];
                        currentSegmentEnd = times[i];
                    } else {
                        currentSegmentEnd = times[i];
                    }
                }
                // Add final segment
                workSegments.push({
                    start: Math.max(0, currentSegmentStart - 30),
                    end: Math.min(1439, currentSegmentEnd + 30)
                });
                
                // Calculate total working minutes (excluding breaks)
                const shiftMinutes = workSegments.reduce((total, seg) => total + (seg.end - seg.start), 0);
                const shiftHours = (shiftMinutes / 60).toFixed(2);
                
                const firstTime = times[0];
                const lastTime = times[times.length - 1];
                const clockIn = Math.max(0, firstTime - 30);
                const clockOut = Math.min(1439, lastTime + 30);
                
                const hourlyRateCollected = (collectedRevenue / parseFloat(shiftHours)).toFixed(2);
                const hourlyRatePotential = (totalRevenue / parseFloat(shiftHours)).toFixed(2);
                
                // Get walking distance for this date
                const walkingDistance = getTotalWalkingDistanceForDate(dateKey);
                
                html += '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px;"><h4 style="margin-top: 0;">‚è∞ Shift Details</h4>';
                
                if (workSegments.length > 1) {
                    html += '<div style="background: rgba(255,255,255,0.15); padding: 10px; border-radius: 6px; margin-bottom: 15px;">';
                    html += '<div style="font-weight: bold; margin-bottom: 8px;">üïê Work Segments (breaks detected):</div>';
                    workSegments.forEach((seg, i) => {
                        html += '<div style="margin: 5px 0; font-size: 0.95em;">Segment ' + (i+1) + ': ' + formatTime(seg.start) + ' - ' + formatTime(seg.end) + '</div>';
                    });
                    html += '</div>';
                } else {
                    html += '<div style="margin: 10px 0;"><strong>Clock In:</strong> ' + formatTime(clockIn) + '<br><span style="font-size: 0.9em; opacity: 0.9;">(30 min before first summons)</span></div>';
                    html += '<div style="margin: 10px 0;"><strong>Clock Out:</strong> ' + formatTime(clockOut) + '<br><span style="font-size: 0.9em; opacity: 0.9;">(30 min after last summons)</span></div>';
                }
                
                html += '<div style="margin: 10px 0; font-size: 1.3em; font-weight: bold;">Total Hours: ' + shiftHours + 'h</div>';
                html += '</div>';
                
                html += '<div style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; padding: 20px; border-radius: 8px;"><h4 style="margin-top: 0;">üìπ Activity Summary</h4>';
                html += '<div style="margin: 10px 0;"><strong>Summonses Filed:</strong> ' + dayData.count + '</div>';
                html += '<div style="margin: 10px 0;"><strong>First Summons:</strong> ' + formatTime(firstTime) + '</div>';
                html += '<div style="margin: 10px 0;"><strong>Last Summons:</strong> ' + formatTime(lastTime) + '</div></div>';
                
                const expectedDaily = calculateExpectedRevenue(dayData.count);
                const collectedPctDaily = expectedDaily > 0 ? ((collectedRevenue / expectedDaily) * 100).toFixed(1) : 0;
                
                html += '<div style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; padding: 20px; border-radius: 8px;"><h4 style="margin-top: 0;">üí∞ Revenue Analysis</h4>';
                html += '<div style="margin: 10px 0;"><strong>Collected vs Expected</strong><br><div style="background: rgba(255,255,255,0.3); border-radius: 10px; height: 20px; overflow: hidden; margin: 8px 0;"><div style="background: #28a745; height: 100%; width: ' + collectedPctDaily + '%;"></div></div><div style="font-size: 0.9em;">$' + collectedRevenue.toFixed(2) + ' of $' + expectedDaily.toFixed(2) + ' (' + collectedPctDaily + '%)</div></div>';
                if (potentialRevenue > 0) {
                    html += '<div style="margin: 10px 0;"><strong>Outstanding:</strong><br><span style="font-size: 1.2em; font-weight: bold; color: #ffc107;">$' + potentialRevenue.toFixed(2) + '</span></div>';
                }
                html += '<div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);"><strong>Hourly Rate (Collected):</strong> $' + hourlyRateCollected + '/hr</div>';
                if (potentialRevenue > 0) {
                    html += '<div style="margin: 5px 0; font-size: 0.9em; font-style: italic; opacity: 0.9;"><strong>If All Paid:</strong> $' + hourlyRatePotential + '/hr</div>';
                }
                html += '<div style="margin: 10px 0;"><strong>Summons/Hour:</strong> ' + (dayData.count / parseFloat(shiftHours)).toFixed(2) + '</div></div>';
            }
            
            html += '</div>';
            
            // Weather and Walking cards side by side
            html += '<div style="margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">';
            
            // Calculate weather for work hours
            if (weatherDataCache[dateKey] && workSegments.length > 0) {
                let totalTemp = 0;
                let tempCount = 0;
                let totalPrecip = 0;
                
                // For each work segment, sum up weather data
                workSegments.forEach(segment => {
                    const startHour = Math.floor(segment.start / 60);
                    const endHour = Math.ceil(segment.end / 60);
                    
                    for (let hour = startHour; hour < endHour; hour++) {
                        if (weatherDataCache[dateKey][hour]) {
                            const w = weatherDataCache[dateKey][hour];
                            if (w.temperature !== null && !isNaN(w.temperature)) {
                                totalTemp += w.temperature;
                                tempCount++;
                            }
                            if (w.precipitation && !isNaN(w.precipitation)) {
                                totalPrecip += w.precipitation;
                            }
                        }
                    }
                });
                
                if (tempCount > 0) {
                    const avgTemp = Math.round(totalTemp / tempCount);
                    const emoji = totalPrecip > 5 ? 'üåßÔ∏è' : totalPrecip > 0.5 ? 'üå¶Ô∏è' : avgTemp >= 85 ? '‚òÄÔ∏è' : avgTemp >= 70 ? '‚õÖ' : avgTemp >= 50 ? 'üå§Ô∏è' : avgTemp >= 32 ? '‚ùÑÔ∏è' : 'ü•∂';
                    
                    html += '<div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 20px; border-radius: 8px;"><h4 style="margin-top: 0;">üå°Ô∏è Weather Conditions</h4>';
                    html += '<div style="text-align: center; margin: 20px 0;"><div style="font-size: 3em; margin-bottom: 10px;">' + emoji + '</div>';
                    html += '<div style="font-size: 2em; font-weight: bold;">' + avgTemp + '¬∞F</div>';
                    html += '<div style="font-size: 0.85em; margin-top: 5px; opacity: 0.9;">Average during work hours</div>';
                    if (totalPrecip > 0) html += '<div style="font-size: 0.9em; margin-top: 8px;">üíß ' + totalPrecip.toFixed(1) + ' mm total precipitation</div>';
                    html += '</div></div>';
                }
            }
            
            // Walking data card
            const workDistance = getWalkingDistanceForWorkHours(dateKey, workSegments);
            const totalDistance = getTotalWalkingDistanceForDate(dateKey);
            
            if (workDistance > 0 || totalDistance > 0) {
                // Calculate efficiency
                const milesPerSummons = dayData.count > 0 ? workDistance / dayData.count : 0;
                // collectedRevenue is already your 25% share from groupDataByDate
                const revenuePerMile = workDistance > 0 ? collectedRevenue / workDistance : 0;
                
                
                
                let efficiencyColor = '#95a5a6'; // gray default
                let efficiencyRating = '';
                if (milesPerSummons < 0.5) {
                    efficiencyColor = '#27ae60'; // green - very efficient
                    efficiencyRating = '‚≠ê‚≠ê‚≠ê Excellent';
                } else if (milesPerSummons < 1.0) {
                    efficiencyColor = '#f39c12'; // orange - good
                    efficiencyRating = '‚≠ê‚≠ê Good';
                } else {
                    efficiencyColor = '#e74c3c'; // red - needs improvement
                    efficiencyRating = '‚≠ê Low';
                }
                
                html += '<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 8px;">';
                html += '<h4 style="margin-top: 0;">üö∂ Walking Distance</h4>';
                html += '<div style="text-align: center; margin: 20px 0;">';
                html += '<div style="font-size: 3em; margin-bottom: 10px;">üëü</div>';
                if (workDistance > 0) {
                    html += '<div style="font-size: 2em; font-weight: bold;">' + workDistance.toFixed(2) + ' mi</div>';
                    html += '<div style="font-size: 0.9em; margin-top: 5px; opacity: 0.9;">During work hours</div>';
                } else {
                    html += '<div style="font-size: 1.5em; font-weight: bold; opacity: 0.8;">No walking data</div>';
                    html += '<div style="font-size: 0.85em; margin-top: 5px; opacity: 0.7;">Not available for this date</div>';
                }
                
                // Efficiency metrics
                html += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.3);">';
                html += '<div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Efficiency</div>';
                html += '<div style="font-size: 1.1em; font-weight: bold;">' + milesPerSummons.toFixed(2) + ' mi/summons</div>';
                html += '<div style="background: ' + efficiencyColor + '; color: white; padding: 4px 8px; border-radius: 4px; display: inline-block; margin-top: 5px; font-size: 0.8em;">' + efficiencyRating + '</div>';
                if (revenuePerMile > 0) {
                    html += '<div style="font-size: 0.8em; margin-top: 8px; opacity: 0.85;">$' + revenuePerMile.toFixed(2) + ' earned/mile</div>';
                }
                html += '</div>';
                
                html += '</div></div>';
            }
            
            html += '</div>'; // End grid
            
            // Add summons table
            html += '<div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px;"><h4 style="color: #1e3c72; margin-top: 0;">üìã All Summonses</h4>';
            html += '<div style="overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; font-size: 0.9em;"><thead><tr style="background: #667eea; color: white;"><th style="padding: 10px; text-align: left;">Time</th><th style="padding: 10px; text-align: left;">Summons #</th><th style="padding: 10px; text-align: left;">Address</th><th style="padding: 10px; text-align: left;">Company</th><th style="padding: 10px; text-align: left;">Status</th><th style="padding: 10px; text-align: right;">Amount</th></tr></thead><tbody>';
            
            dayData.summonses.forEach(s => {
                const statusBadge = s.rowType === 'paid' ? '<span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Paid</span>' :
                                   s.rowType === 'requested' ? '<span style="background: #ffc107; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Requested</span>' :
                                   s.rowType === 'submitted' ? '<span style="background: #667eea; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Submitted</span>' :
                                   '<span style="background: #dc3545; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Outstanding</span>';
                
                const totalAmount = (s.balanceDue || 0) + (s.paidAmount || 0);
                const yourShare = totalAmount * 0.25;
                const address = s.address || 'N/A';
                
                html += '<tr style="border-bottom: 1px solid #dee2e6;"><td style="padding: 10px;">' + (s.time || 'N/A') + '</td><td style="padding: 10px;">' + s.number + '</td><td style="padding: 10px;">' + address + '</td><td style="padding: 10px;">' + (s.company || 'Unknown') + '</td><td style="padding: 10px;">' + statusBadge + '</td><td style="padding: 10px; text-align: right;">$' + yourShare.toFixed(2) + '</td></tr>';
            });
            
            html += '</tbody></table></div></div>';
            
            
            document.getElementById('day-detail-content').innerHTML = html;
            document.getElementById('day-detail').scrollIntoView({ behavior: 'smooth', block: 'start' });
            
        }
        
        function parseTime(timeStr) {
            if (!timeStr) return null;
            const match = timeStr.match(/(\d{1,2}):?(\d{2})?\s*(AM|PM)?/i);
            if (match) {
                let hours = parseInt(match[1]);
                const minutes = parseInt(match[2] || 0);
                if (match[3] && match[3].toUpperCase() === 'PM' && hours !== 12) hours += 12;
                if (match[3] && match[3].toUpperCase() === 'AM' && hours === 12) hours = 0;
                return hours * 60 + minutes;
            }
            return null;
        }
        
        function formatTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12;
            return displayHours + ':' + mins.toString().padStart(2, '0') + ' ' + period;
        }
        
        function closeDayDetail() {
            document.getElementById('day-detail').style.display = 'none';
            selectedDate = null;
        }
        
        function previousMonth() {
            currentTimeMonth--;
            if (currentTimeMonth < 0) {
                currentTimeMonth = 11;
                currentTimeYear--;
            }
            const monthDropdown = document.getElementById('time-month');
            const yearDropdown = document.getElementById('time-year');
            if (monthDropdown) monthDropdown.value = currentTimeMonth;
            if (yearDropdown) yearDropdown.value = currentTimeYear;
            generateTimeAnalysis();
        }
        
        function nextMonth() {
            currentTimeMonth++;
            if (currentTimeMonth > 11) {
                currentTimeMonth = 0;
                currentTimeYear++;
            }
            const monthDropdown = document.getElementById('time-month');
            const yearDropdown = document.getElementById('time-year');
            if (monthDropdown) monthDropdown.value = currentTimeMonth;
            if (yearDropdown) yearDropdown.value = currentTimeYear;
            generateTimeAnalysis();
        }
        
        function generateWeeklyView(dataset) {
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            
            // Determine current week if not set or if it's outside the current viewed month
            if (!currentWeekStart) {
                // Default to first Sunday of the currently viewed month (using UTC)
                const firstOfMonth = new Date(Date.UTC(currentTimeYear, currentTimeMonth, 1));
                const dayOfWeek = firstOfMonth.getUTCDay();
                // Calculate first Sunday (go back to previous Sunday if needed)
                const firstSunday = new Date(Date.UTC(currentTimeYear, currentTimeMonth, 1 - dayOfWeek));
                currentWeekStart = firstSunday;
            } else {
                // Check if currentWeekStart is in a different month than what we're viewing
                const weekMonth = currentWeekStart.getUTCMonth();
                const weekYear = currentWeekStart.getUTCFullYear();
                if (weekMonth !== currentTimeMonth || weekYear !== currentTimeYear) {
                    // Reset to first Sunday of the viewed month
                    const firstOfMonth = new Date(Date.UTC(currentTimeYear, currentTimeMonth, 1));
                    const dayOfWeek = firstOfMonth.getUTCDay();
                    const firstSunday = new Date(Date.UTC(currentTimeYear, currentTimeMonth, 1 - dayOfWeek));
                    currentWeekStart = firstSunday;
                }
            }
            
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setUTCDate(weekEnd.getUTCDate() + 6);
            
            const weekTitle = 'Week of ' + currentWeekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' }) + ' - ' + weekEnd.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' });
            document.getElementById('week-title').textContent = weekTitle;
            
            // Generate week selector calendar
            generateWeekSelector(dataset, grouped);
            
            // Collect week data with hours calculation
            let totalSummonses = 0;
            let weekendSummonses = 0;
            let collectedRevenue = 0;
            let potentialRevenue = 0;
            let weekendCollected = 0;
            let weekendPotential = 0;
            let totalMinutes = 0;
            let daysActive = 0;
            
            for (let i = 0; i < 7; i++) {
                const date = new Date(currentWeekStart);
                date.setUTCDate(date.getUTCDate() + i);
                // Build dateKey using UTC methods
                const dateKey = date.getUTCFullYear() + '-' + String(date.getUTCMonth() + 1).padStart(2, '0') + '-' + String(date.getUTCDate()).padStart(2, '0');
                const dayData = grouped[dateKey];
                const isWeekend = date.getUTCDay() === 0 || date.getUTCDay() === 6;
                
                if (dayData) {
                    totalSummonses += dayData.count;
                    collectedRevenue += dayData.collectedRevenue;
                    potentialRevenue += dayData.potentialRevenue;
                    
                    // Calculate shift hours for this day WITH BREAK DETECTION (same as day detail)
                    const times = dayData.summonses.map(s => parseTime(s.time)).filter(t => t !== null).sort((a, b) => a - b);
                    if (times.length > 0) {
                        let workSegments = [];
                        const breakThresholdMinutes = 150; // 2.5 hours
                        let currentSegmentStart = times[0];
                        let currentSegmentEnd = times[0];
                        
                        for (let j = 1; j < times.length; j++) {
                            const gap = times[j] - times[j-1];
                            if (gap >= breakThresholdMinutes) {
                                // Break detected - end current segment
                                workSegments.push({
                                    start: Math.max(0, currentSegmentStart - 30),
                                    end: Math.min(1439, currentSegmentEnd + 30)
                                });
                                // Start new segment
                                currentSegmentStart = times[j];
                                currentSegmentEnd = times[j];
                            } else {
                                currentSegmentEnd = times[j];
                            }
                        }
                        // Add final segment
                        workSegments.push({
                            start: Math.max(0, currentSegmentStart - 30),
                            end: Math.min(1439, currentSegmentEnd + 30)
                        });
                        
                        // Calculate total working minutes (excluding breaks)
                        const shiftMinutes = workSegments.reduce((total, seg) => total + (seg.end - seg.start), 0);
                        totalMinutes += shiftMinutes;
                        daysActive++;
                    }
                    
                    if (isWeekend) {
                        weekendSummonses += dayData.count;
                        weekendCollected += dayData.collectedRevenue;
                        weekendPotential += dayData.potentialRevenue;
                    }
                }
            }
            
            const weekendRevenue = weekendCollected + weekendPotential;
            const totalRevenue = collectedRevenue + potentialRevenue;
            const totalHours = (totalMinutes / 60).toFixed(2);
            const hourlyRateCollected = totalHours > 0 ? (collectedRevenue / parseFloat(totalHours)).toFixed(2) : 0;
            const hourlyRatePotential = totalHours > 0 ? (totalRevenue / parseFloat(totalHours)).toFixed(2) : 0;
            
            // Generate payment tracking cards
            const collectedPct = totalRevenue > 0 ? ((collectedRevenue / totalRevenue) * 100).toFixed(1) : 0;
            const potentialPct = totalRevenue > 0 ? ((potentialRevenue / totalRevenue) * 100).toFixed(1) : 0;
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; margin-bottom: 20px;">';
            
            const expectedWeeklyCard = calculateExpectedRevenue(totalSummonses);
            
            html += '<div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 20px; border-radius: 8px;"><div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 8px;">‚úÖ COLLECTED</div><div style="font-size: 2.2em; font-weight: bold; margin-bottom: 5px;">$' + collectedRevenue.toFixed(2) + '</div><div style="font-size: 0.85em; opacity: 0.85;">' + collectedPct + '% of expected</div><div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); font-size: 0.85em;">üí∞ Yours or coming!</div></div>';
            
            html += '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px;"><div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 8px;">üíµ EXPECTED</div><div style="font-size: 2.2em; font-weight: bold; margin-bottom: 5px;">$' + expectedWeeklyCard.toFixed(2) + '</div><div style="font-size: 0.85em; opacity: 0.85;">' + totalSummonses + ' summonses √ó $82.50</div></div>';
            
            if (weekendSummonses > 0) {
                html += '<div style="background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%); color: white; padding: 20px; border-radius: 8px; border: 3px solid #fff;"><div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 8px;">üéÅ WEEKEND BONUS</div><div style="font-size: 2.2em; font-weight: bold; margin-bottom: 5px;">$' + weekendRevenue.toFixed(2) + '</div><div style="font-size: 0.85em; opacity: 0.85;">' + weekendSummonses + ' summonses</div><div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); font-size: 0.85em;">üî• Extra hustle pays off!</div></div>';
            }
            
            html += '</div>';
            
            // Progress bar
            const expectedForBar = calculateExpectedRevenue(totalSummonses);
            const collectedPctOfExpected = expectedForBar > 0 ? ((collectedRevenue / expectedForBar) * 100).toFixed(1) : 0;
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;"><h4 style="color: #1e3c72; margin: 0 0 10px 0; font-size: 1em;">üí∞ Collected vs Expected</h4><div style="background: #764ba2; border-radius: 20px; height: 30px; overflow: hidden; position: relative;">';
            html += '<div style="position: absolute; left: 0; top: 0; height: 100%; background: #28a745; width: ' + collectedPctOfExpected + '%;"></div>';
            html += '</div><div style="margin-top: 10px; font-size: 0.85em; color: #666;"><span style="color: #28a745;">‚óè</span> Collected: ' + collectedPctOfExpected + '% of expected ($' + expectedForBar.toFixed(2) + ')</div>';
            
            html += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;"><div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">üí° Outstanding</div><div style="font-size: 1.3em; font-weight: bold; color: #ffc107;">$' + potentialRevenue.toFixed(2) + '</div></div></div>';
            
            // Week summary
            html += '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 8px;"><h3 style="margin: 0 0 20px 0; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 15px;">üìÖ Weekly Summary</h3><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">';
            
            html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üìπ Total Summonses</div><div style="font-size: 2em; font-weight: bold;">' + totalSummonses + '</div></div>';
            
            html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üí∞ Total Potential</div><div style="font-size: 2em; font-weight: bold;">$' + totalRevenue.toFixed(2) + '</div></div>';
            
            // Calculate total miles walked this week
            let weekMiles = 0;
            for (let i = 0; i < 7; i++) {
                const date = new Date(currentWeekStart);
                date.setUTCDate(date.getUTCDate() + i);
                const dateKey = date.getUTCFullYear() + '-' + String(date.getUTCMonth() + 1).padStart(2, '0') + '-' + String(date.getUTCDate()).padStart(2, '0');
                if (walkingDataCache[dateKey]) {
                    Object.values(walkingDataCache[dateKey]).forEach(km => weekMiles += km * 0.621371);
                }
            }
            
            if (weekMiles > 0) {
                html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üö∂ Miles Walked</div><div style="font-size: 2em; font-weight: bold;">' + weekMiles.toFixed(1) + ' mi</div><div style="font-size: 0.85em; opacity: 0.8;">' + (weekMiles / totalSummonses).toFixed(2) + ' mi/summons</div></div>';
            }
            
            if (totalHours > 0) {
                html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">‚è∞ Hours Worked</div><div style="font-size: 2em; font-weight: bold;">' + totalHours + 'h</div><div style="font-size: 0.85em; opacity: 0.8;">' + daysActive + ' days active</div></div>';
                
                html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üíµ Hourly Rate (Collected)</div><div style="font-size: 2em; font-weight: bold;">$' + hourlyRateCollected + '</div></div>';
                
                if (potentialRevenue > 0) {
                    html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üí° Hourly (If All Paid)</div><div style="font-size: 2em; font-weight: bold;">$' + hourlyRatePotential + '</div></div>';
                }
            }
            
            if (weekendSummonses > 0) {
                html += '<div><div style="opacity: 0.9; font-size: 0.9em; margin-bottom: 5px;">üéÅ Weekend Work</div><div style="font-size: 2em; font-weight: bold;">' + weekendSummonses + ' summons</div><div style="font-size: 0.85em; opacity: 0.8;">$' + weekendRevenue.toFixed(2) + '</div></div>';
            }
            
            html += '</div></div>';
            
            document.getElementById('week-payment-tracking').innerHTML = html;
            
            // Generate week summons table
            let tableHtml = '<div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px;"><h4 style="color: #1e3c72; margin-top: 0;">üìã All Summonses This Week</h4>';
            tableHtml += '<div style="overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; font-size: 0.9em;"><thead><tr style="background: #667eea; color: white;"><th style="padding: 10px; text-align: left;">Date</th><th style="padding: 10px; text-align: left;">Time</th><th style="padding: 10px; text-align: left;">Summons #</th><th style="padding: 10px; text-align: left;">Company</th><th style="padding: 10px; text-align: left;">Status</th><th style="padding: 10px; text-align: right;">Amount</th></tr></thead><tbody>';
            
            for (let i = 0; i < 7; i++) {
                const date = new Date(currentWeekStart);
                date.setUTCDate(date.getUTCDate() + i);
                // Build dateKey using UTC methods
                const dateKey = date.getUTCFullYear() + '-' + String(date.getUTCMonth() + 1).padStart(2, '0') + '-' + String(date.getUTCDate()).padStart(2, '0');
                const dayData = grouped[dateKey];
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', timeZone: 'UTC' });
                
                if (dayData && dayData.summonses) {
                    dayData.summonses.forEach(s => {
                        const statusBadge = s.rowType === 'paid' ? '<span style="background: #28a745; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Paid</span>' :
                                           s.rowType === 'requested' ? '<span style="background: #ffc107; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Requested</span>' :
                                           s.rowType === 'submitted' ? '<span style="background: #667eea; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Submitted</span>' :
                                           '<span style="background: #dc3545; color: white; padding: 3px 8px; border-radius: 4px; font-size: 0.85em;">Outstanding</span>';
                        
                        const totalAmount = (s.balanceDue || 0) + (s.paidAmount || 0);
                        const yourShare = totalAmount * 0.25;
                        
                        tableHtml += '<tr style="border-bottom: 1px solid #dee2e6;"><td style="padding: 10px;">' + dayName + '</td><td style="padding: 10px;">' + (s.time || 'N/A') + '</td><td style="padding: 10px;">' + s.number + '</td><td style="padding: 10px;">' + (s.company || 'Unknown') + '</td><td style="padding: 10px;">' + statusBadge + '</td><td style="padding: 10px; text-align: right;">$' + yourShare.toFixed(2) + '</td></tr>';
                    });
                }
            }
            
            tableHtml += '</tbody></table></div></div>';
            
            document.getElementById('week-summary').innerHTML = tableHtml;
        }
        
        function generateWeekSelector(dataset, grouped) {
            // Use currentTimeYear and currentTimeMonth from dropdowns instead of currentWeekStart
            const year = currentTimeYear;
            const month = currentTimeMonth;
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDay = firstDay.getDay();
            const daysInMonth = lastDay.getDate();
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            
            let html = '<div style="text-align: center; margin-bottom: 15px;"><h4 style="color: #667eea; margin: 0;">' + monthNames[month] + ' ' + year + '</h4></div>';
            html += '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px;">';
            
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayNames.forEach(day => {
                html += '<div style="text-align: center; font-weight: bold; color: #667eea; padding: 8px; font-size: 0.85em;">' + day + '</div>';
            });
            
            for (let i = 0; i < startDay; i++) {
                html += '<div></div>';
            }
            
            for (let day = 1; day <= daysInMonth; day++) {
                const dateObj = new Date(year, month, day);
                const dayOfWeek = dateObj.getDay();
                // Build dateKey directly to avoid timezone conversion
                const dateKey = year + '-' + String(month + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                const dayData = grouped[dateKey];
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                
                // Calculate Sunday of this week without timezone conversion
                const sundayDay = day - dayOfWeek;
                const sundayYear = year;
                let sundayMonth = month;
                let adjustedSundayDay = sundayDay;
                
                // Handle month boundaries
                if (sundayDay < 1) {
                    sundayMonth = month - 1;
                    if (sundayMonth < 0) {
                        sundayMonth = 11;
                    }
                    const prevMonthLastDay = new Date(year, month, 0).getDate();
                    adjustedSundayDay = prevMonthLastDay + sundayDay;
                }
                
                const weekKey = sundayYear + '-' + String(sundayMonth + 1).padStart(2, '0') + '-' + String(adjustedSundayDay).padStart(2, '0');
                
                // Compare week keys directly
                let currentWeekKey = null;
                if (currentWeekStart) {
                    const cws = currentWeekStart;
                    currentWeekKey = cws.getFullYear() + '-' + String(cws.getMonth() + 1).padStart(2, '0') + '-' + String(cws.getDate()).padStart(2, '0');
                }
                const isSelectedWeek = currentWeekKey && weekKey === currentWeekKey;
                
                let bgColor = isWeekend ? '#e0e0e0' : '#f8f9fa';
                let borderColor = '#dee2e6';
                let borderWidth = '2px';
                
                if (dayData) {
                    if (dayData.count >= 10) {
                        bgColor = isWeekend ? '#c0c0c0' : '#d4edda';
                        borderColor = isWeekend ? '#ff9800' : '#28a745';
                    } else if (dayData.count >= 5) {
                        bgColor = '#fff3cd';
                        borderColor = '#ffc107';
                    } else {
                        bgColor = isWeekend ? '#d0d0d0' : '#e7f3ff';
                        borderColor = isWeekend ? '#ff9800' : '#667eea';
                    }
                }
                
                if (isSelectedWeek) {
                    borderColor = '#764ba2';
                    borderWidth = '3px';
                }
                
                html += '<div onclick="selectWeek(\'' + weekKey + '\')" style="padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s; min-height: 70px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; background: ' + bgColor + '; border: ' + borderWidth + ' solid ' + borderColor + ';" onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(0,0,0,0.15)\';" onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'none\';"><div style="font-size: 1.1em; font-weight: bold; color: #1e3c72; margin-bottom: 3px;">' + day + '</div>';
                
                if (dayData) {
                    // Calculate all metrics first
                    const times = dayData.summonses.map(s => parseTime(s.time)).filter(t => t !== null).sort((a, b) => a - b);
                    let hoursWorked = 0;
                    if (times.length > 0) {
                        const workSegments = calculateWorkSegments(times);
                        hoursWorked = calculateHoursWorked(workSegments);
                    }
                    
                    let milesWalked = 0;
                    if (walkingDataCache[dateKey]) {
                        Object.values(walkingDataCache[dateKey]).forEach(km => milesWalked += km * 0.621371);
                    }
                    
                    const weather = getWeatherAtNoon(dateKey);
                    let weatherEmoji = '';
                    let temp = '';
                    if (weather && weather.temperature !== null) {
                        weatherEmoji = getWeatherEmoji(weather.temperature, weather.precipitation);
                        temp = Math.round(weather.temperature) + '¬∞';
                    }
                    
                    // Build compact display
                    html += '<div style="font-size: 0.75em; color: #666; margin: 2px 0;">üìπ ' + dayData.count + '</div>';
                    
                    // Combine hours and miles on one line if both exist
                    if (hoursWorked > 0 && milesWalked > 0) {
                        html += '<div style="font-size: 0.68em; color: #555; margin: 1px 0;">‚è±Ô∏è' + hoursWorked.toFixed(1) + 'h üö∂' + milesWalked.toFixed(1) + 'mi</div>';
                    } else if (hoursWorked > 0) {
                        html += '<div style="font-size: 0.68em; color: #555; margin: 1px 0;">‚è±Ô∏è ' + hoursWorked.toFixed(1) + 'h</div>';
                    } else if (milesWalked > 0) {
                        html += '<div style="font-size: 0.68em; color: #555; margin: 1px 0;">üö∂ ' + milesWalked.toFixed(1) + ' mi</div>';
                    }
                    
                    if (weatherEmoji) {
                        html += '<div style="font-size: 0.68em; color: #3498db; margin: 1px 0;">' + weatherEmoji + temp + '</div>';
                    }
                    
                    if (dayData.collectedRevenue > 0) {
                        html += '<div style="font-size: 0.7em; color: #28a745; font-weight: bold; margin: 1px 0;">$' + dayData.collectedRevenue.toFixed(0) + '</div>';
                    }
                    if (dayData.potentialRevenue > 0) {
                        html += '<div style="font-size: 0.65em; color: #ffc107; margin: 1px 0;">$' + dayData.potentialRevenue.toFixed(0) + '</div>';
                    }
                }
                
                if (isSelectedWeek && dayOfWeek === 0) {
                    html += '<div style="margin-top: 5px; font-size: 0.7em; color: #764ba2; font-weight: bold;">‚¨á WEEK ‚¨á</div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            html += '<div style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.85em;"><div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;"><div><span style="color: #28a745;">‚óè</span> Weekday (work)</div><div><span style="color: #ff9800;">üéÅ</span> Weekend (bonus!)</div><div><span style="color: #764ba2;">‚îÅ‚îÅ</span> Selected week</div></div></div>';
            
            document.getElementById('week-selector-calendar').innerHTML = html;
        }
        
        function selectWeek(weekKey) {
            currentWeekStart = new Date(weekKey);
            currentWeekStart.setHours(0, 0, 0, 0);
            generateTimeAnalysis();
        }
        
        function previousWeek() {
            // Navigate calendar view to previous month
            currentTimeMonth--;
            if (currentTimeMonth < 0) {
                currentTimeMonth = 11;
                currentTimeYear--;
            }
            // Update the dropdowns to match
            document.getElementById('time-month').value = currentTimeMonth;
            document.getElementById('time-year').value = currentTimeYear;
            generateTimeAnalysis();
        }
        
        function nextWeek() {
            // Navigate calendar view to next month
            currentTimeMonth++;
            if (currentTimeMonth > 11) {
                currentTimeMonth = 0;
                currentTimeYear++;
            }
            // Update the dropdowns to match
            document.getElementById('time-month').value = currentTimeMonth;
            document.getElementById('time-year').value = currentTimeYear;
            generateTimeAnalysis();
        }

        // ===== ADVANCED INSIGHTS FUNCTIONS =====
        
        // Get filtered data for insights based on selected checkboxes
        function getFilteredInsightsData() {
            const cutoffDate = new Date('2024-10-01');
            const includeATBefore = document.getElementById('insights-filter-at-before').checked;
            const includeATAfter = document.getElementById('insights-filter-at-after').checked;
            const includeMBT = document.getElementById('insights-filter-mbt').checked;
            const includeATNYC = document.getElementById('insights-filter-at-nyc').checked;
            
            const filteredData = [];
            
            // AT dataset - split by date
            if (includeATBefore || includeATAfter) {
                appData['at'].merged.forEach(row => {
                    const violationDate = new Date(row['Violation Date']);
                    if (!isNaN(violationDate.getTime())) {
                        if (includeATBefore && violationDate < cutoffDate) {
                            filteredData.push({ ...row, _dataset: 'at', _period: 'before' });
                        } else if (includeATAfter && violationDate >= cutoffDate) {
                            filteredData.push({ ...row, _dataset: 'at', _period: 'after' });
                        }
                    } else {
                        // If no valid date, include based on checkbox settings
                        if (includeATBefore) {
                            filteredData.push({ ...row, _dataset: 'at', _period: 'unknown' });
                        }
                    }
                });
            }
            
            // MBT dataset
            if (includeMBT) {
                appData['mbt'].merged.forEach(row => {
                    filteredData.push({ ...row, _dataset: 'mbt' });
                });
            }
            
            // AT NYC dataset
            if (includeATNYC) {
                appData['at-nyc'].merged.forEach(row => {
                    filteredData.push({ ...row, _dataset: 'at-nyc' });
                });
            }
            
            return filteredData;
        }
        
        // Update the dataset info display
        function updateInsightsDatasetInfo() {
            const data = getFilteredInsightsData();
            const infoDiv = document.getElementById('insights-dataset-info');
            
            if (data.length === 0) {
                infoDiv.innerHTML = '<strong style="color: #e74c3c;">‚ö†Ô∏è No datasets selected! Please select at least one dataset to analyze.</strong>';
                return;
            }
            
            // Count by dataset
            const counts = {
                'at-before': 0,
                'at-after': 0,
                'mbt': 0,
                'at-nyc': 0
            };
            
            data.forEach(row => {
                if (row._dataset === 'at') {
                    if (row._period === 'before') counts['at-before']++;
                    else if (row._period === 'after') counts['at-after']++;
                } else if (row._dataset === 'mbt') {
                    counts['mbt']++;
                } else if (row._dataset === 'at-nyc') {
                    counts['at-nyc']++;
                }
            });
            
            let html = '<strong>üìä Analyzing: </strong>';
            const parts = [];
            if (counts['at-before'] > 0) parts.push(`AT Before 10/1/24 (${counts['at-before'].toLocaleString()})`);
            if (counts['at-after'] > 0) parts.push(`AT After 10/1/24 (${counts['at-after'].toLocaleString()})`);
            if (counts['mbt'] > 0) parts.push(`MBT (${counts['mbt'].toLocaleString()})`);
            if (counts['at-nyc'] > 0) parts.push(`AT NYC (${counts['at-nyc'].toLocaleString()})`);
            
            html += parts.join(' | ');
            html += ` <strong style="color: #667eea;">Total: ${data.length.toLocaleString()} records</strong>`;
            
            infoDiv.innerHTML = html;
        }
        
        // ===== AI ANALYSIS FUNCTIONS =====
        
        async function askClaudeAI() {
            const questionEl = document.getElementById('ai-question');
            const question = questionEl.value.trim();
            
            if (!question) {
                alert('Please enter a question first.');
                return;
            }
            
            // Show loading
            document.getElementById('ai-loading').style.display = 'inline';
            document.getElementById('ai-response').style.display = 'none';
            
            try {
                // Use direct analysis for now (API would require backend)
                const answer = analyzeQuestion(question);
                
                // Display response
                document.getElementById('ai-response-content').textContent = answer;
                document.getElementById('ai-response').style.display = 'block';
                
            } catch (error) {
                console.error('Analysis Error:', error);
                document.getElementById('ai-response-content').textContent = '‚ö†Ô∏è Sorry, I encountered an error analyzing your data. Please try rephrasing your question.';
                document.getElementById('ai-response').style.display = 'block';
            } finally {
                document.getElementById('ai-loading').style.display = 'none';
            }
        }
        
        function analyzeQuestion(question) {
            const q = question.toLowerCase();
            const allData = [];
            
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                allData.push(...appData[tab].merged.map(r => ({...r, _dataset: tab})));
            });
            
            // DATE-BASED QUERIES
            if (q.includes('december') || q.includes('dec') || q.includes('month') || q.includes('2022') || q.includes('2023') || q.includes('2024')) {
                // Extract year and month
                let targetYear = null;
                let targetMonth = null;
                
                if (q.includes('2022')) targetYear = 2022;
                if (q.includes('2023')) targetYear = 2023;
                if (q.includes('2024')) targetYear = 2024;
                if (q.includes('2025')) targetYear = 2025;
                
                const months = ['january', 'february', 'march', 'april', 'may', 'june', 
                               'july', 'august', 'september', 'october', 'november', 'december'];
                months.forEach((month, idx) => {
                    if (q.includes(month) || q.includes(month.substring(0, 3))) {
                        targetMonth = idx + 1;
                    }
                });
                
                if (targetYear || targetMonth) {
                    const filtered = allData.filter(r => {
                        const date = r['Violation Date'];
                        if (!date) return false;
                        const parts = date.split('T')[0].split('-');
                        if (parts.length !== 3) return false;
                        const year = parseInt(parts[0]);
                        const month = parseInt(parts[1]);
                        
                        let matches = true;
                        if (targetYear) matches = matches && (year === targetYear);
                        if (targetMonth) matches = matches && (month === targetMonth);
                        return matches;
                    });
                    
                    if (q.includes('balance') || q.includes('owe') || q.includes('amount')) {
                        const totalBalance = filtered.reduce((sum, r) => {
                            const balance = parseFloat((r['Balance Due'] || '0').toString().replace(/[$,]/g, ''));
                            return sum + balance;
                        }, 0);
                        
                        const paidAmount = filtered.reduce((sum, r) => {
                            const paid = parseFloat((r['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                            return sum + paid;
                        }, 0);
                        
                        const totalAmount = totalBalance + paidAmount;
                        const yourShare = totalAmount * 0.25;
                        
                        const monthName = targetMonth ? months[targetMonth - 1] : 'the specified month';
                        const yearStr = targetYear || 'that year';
                        
                        return `üìä Analysis for ${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${yearStr}:

Found ${filtered.length} summonses

Total Balance Due: $${totalBalance.toFixed(2)}
Total Paid Amount: $${paidAmount.toFixed(2)}
Total Amount (Balance + Paid): $${totalAmount.toFixed(2)}

Your 25% Share:
- From Balance Due: $${(totalBalance * 0.25).toFixed(2)}
- From Paid Amount: $${(paidAmount * 0.25).toFixed(2)}
- Total Expected: $${yourShare.toFixed(2)}

Note: "Balance Due" shows what's currently outstanding. "Paid Amount" shows what NYC already received.`;
                    }
                    
                    return `Found ${filtered.length} summonses in ${targetMonth ? months[targetMonth-1] : ''} ${targetYear || ''}. Try asking about the balance due or payment amounts for this period.`;
                }
            }
            
            // COMPANY QUERIES
            if (q.includes('compan') || q.includes('who owes')) {
                const companyMap = {};
                allData.forEach(r => {
                    const company = r['Company Name'] || 'Unknown';
                    const balance = parseFloat((r['Balance Due'] || '0').toString().replace(/[$,]/g, ''));
                    const paid = parseFloat((r['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    const isOutstanding = !r['Payment Status'] && (r['Hearing Status'] || '').toLowerCase() === 'paid in full';
                    
                    if (!companyMap[company]) {
                        companyMap[company] = { count: 0, balance: 0, paid: 0, outstanding: 0 };
                    }
                    companyMap[company].count++;
                    companyMap[company].balance += balance;
                    companyMap[company].paid += paid;
                    if (isOutstanding) companyMap[company].outstanding += paid * 0.25;
                });
                
                if (q.includes('owe') || q.includes('outstanding')) {
                    const sorted = Object.entries(companyMap)
                        .filter(([_, data]) => data.outstanding > 0)
                        .sort((a, b) => b[1].outstanding - a[1].outstanding)
                        .slice(0, 10);
                    
                    if (sorted.length === 0) {
                        return '‚úÖ Great news! No companies have outstanding payments owed to you.';
                    }
                    
                    let result = `üí∞ Top Companies with Outstanding Payments (your 25% share):\n\n`;
                    sorted.forEach(([company, data], i) => {
                        result += `${i+1}. ${company}\n   Outstanding: $${data.outstanding.toFixed(2)} (${data.count} summonses)\n\n`;
                    });
                    result += `Total Outstanding: $${sorted.reduce((sum, c) => sum + c[1].outstanding, 0).toFixed(2)}`;
                    return result;
                }
                
                const sorted = Object.entries(companyMap)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 10);
                
                let result = `üìä Top Companies by Summons Count:\n\n`;
                sorted.forEach(([company, data], i) => {
                    const total = (data.balance + data.paid) * 0.25;
                    result += `${i+1}. ${company}\n   Summonses: ${data.count} | Your Share: $${total.toFixed(2)}\n\n`;
                });
                return result;
            }
            
            // BUSIEST DAYS
            if (q.includes('busy') || q.includes('busiest') || q.includes('day of week') || q.includes('which day')) {
                const dayMap = {};
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                
                allData.forEach(r => {
                    const date = r['Violation Date'];
                    if (date) {
                        const parts = date.split('T')[0].split('-');
                        if (parts.length === 3) {
                            const dateObj = new Date(Date.UTC(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2])));
                            const dayName = days[dateObj.getUTCDay()];
                            if (!dayMap[dayName]) dayMap[dayName] = { count: 0, amount: 0 };
                            dayMap[dayName].count++;
                            const amount = parseFloat((r['Paid Amount'] || r['Balance Due'] || '0').toString().replace(/[$,]/g, ''));
                            dayMap[dayName].amount += amount * 0.25;
                        }
                    }
                });
                
                const sorted = Object.entries(dayMap).sort((a, b) => b[1].count - a[1].count);
                
                let result = `üìÖ Summonses by Day of Week:\n\n`;
                sorted.forEach(([day, data], i) => {
                    result += `${i+1}. ${day}: ${data.count} summonses ($${data.amount.toFixed(2)})\n`;
                });
                result += `\nBusiest: ${sorted[0][0]} | Slowest: ${sorted[sorted.length-1][0]}`;
                return result;
            }
            
            // PAYMENT SUCCESS RATE
            if (q.includes('payment') || q.includes('success') || q.includes('collection') || q.includes('paid')) {
                const paidInFull = allData.filter(r => (r['Hearing Status'] || '').toLowerCase() === 'paid in full');
                const received = allData.filter(r => r['Payment Status']);
                const rate = paidInFull.length > 0 ? ((received.length / paidInFull.length) * 100).toFixed(1) : 0;
                
                const totalExpected = paidInFull.reduce((sum, r) => {
                    const amount = parseFloat((r['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                
                const totalReceived = received.reduce((sum, r) => {
                    const amount = parseFloat((r['Paid To Me'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + amount;
                }, 0);
                
                return `üíµ Payment Collection Analysis:

Total "Paid in Full" Summonses: ${paidInFull.length}
Payments Received: ${received.length}
Collection Rate: ${rate}%

Expected Revenue (25%): $${totalExpected.toFixed(2)}
Actual Received: $${totalReceived.toFixed(2)}
Outstanding: $${(totalExpected - totalReceived).toFixed(2)}

${paidInFull.length - received.length} payments are still pending.`;
            }
            
            // TOTAL REVENUE / EARNINGS
            if (q.includes('total') || q.includes('revenue') || q.includes('earn') || q.includes('how much')) {
                const totalPaid = allData.reduce((sum, r) => {
                    const amount = parseFloat((r['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + amount;
                }, 0);
                
                const totalBalance = allData.reduce((sum, r) => {
                    const amount = parseFloat((r['Balance Due'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + amount;
                }, 0);
                
                const received = allData.filter(r => r['Payment Status']).reduce((sum, r) => {
                    const amount = parseFloat((r['Paid To Me'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + amount;
                }, 0);
                
                return `üí∞ Revenue Summary:

Total Summonses: ${allData.length}

NYC Received (Paid Amount): $${totalPaid.toFixed(2)}
Your Expected Share (25%): $${(totalPaid * 0.25).toFixed(2)}

Actually Received: $${received.toFixed(2)}
Still Outstanding: $${((totalPaid * 0.25) - received).toFixed(2)}

Potential Future (Balance Due): $${totalBalance.toFixed(2)}
Your Potential Share: $${(totalBalance * 0.25).toFixed(2)}`;
            }
            
            // DEFAULT RESPONSE
            return `I can help you analyze your data! Try asking questions like:

‚Ä¢ "What is the sum of balance due from December 2022?"
‚Ä¢ "Which companies owe me money?"
‚Ä¢ "What are my busiest days?"
‚Ä¢ "What's my payment collection rate?"
‚Ä¢ "How much total revenue have I earned?"
‚Ä¢ "Show me summonses from January 2024"

Your data includes ${allData.length} total summonses across AT, AT-NYC, and MBT datasets.`;
        }
        
        function clearAIResponse() {
            document.getElementById('ai-question').value = '';
            document.getElementById('ai-response').style.display = 'none';
            document.getElementById('ai-response-content').textContent = '';
        }
        
        // ===== INSIGHTS GENERATION =====
        
        function generateAllInsights() {
            const data = getFilteredInsightsData();
            
            if (data.length === 0) {
                alert('Please select at least one dataset to analyze!');
                return;
            }
            
            generateAveragePerSummons();
            generateCompanyIntelligence();
            generateWalkingEfficiency();
            generateCashFlowForecast();
            generateDisqualificationDetective();
            generateGeographicHeatMap();
            generateViolationTypeAnalysis();
            generateSmartAlerts();
            generateSeasonalPlanner();
            generateBehaviorChangeDetector();
            generateROIMetrics();
            generateConEdInsight();
        }
        
        function exportInsightsReport() {
            alert('Exporting comprehensive insights report... (Feature coming soon!)');
        }

        // 1. Average $ per Summons
        function generateAveragePerSummons() {
            const container = document.getElementById('insight-payment-predictor');
            const allData = getFilteredInsightsData();

            // Filter out NEW ISSUANCE and summonses awaiting data
            const validSummons = allData.filter(row => {
                const hearingStatus = (row['Hearing Status'] || '').toUpperCase();
                const paidAmount = row['Paid Amount'];
                
                // Exclude if NEW ISSUANCE
                if (hearingStatus === 'NEW ISSUANCE') return false;
                
                // Exclude if awaiting data (no hearing status and no paid amount)
                if (!hearingStatus && !paidAmount) return false;
                
                return true;
            });

            // Calculate total amount paid or requested
            let totalAmount = 0;
            let totalSummonsCount = validSummons.length;
            
            validSummons.forEach(row => {
                const rowType = row['_rowType'];
                if (rowType === 'paid' || rowType === 'requested') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount) && amount > 0) {
                        totalAmount += amount;
                    }
                }
            });

            const averagePerSummons = totalSummonsCount > 0 ? totalAmount / totalSummonsCount : 0;
            const yourAverageShare = averagePerSummons * 0.25;
            
            const excludedCount = allData.length - validSummons.length;

            let html = '<div style="margin-bottom: 15px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center;">';
            html += '<div style="font-size: 1.2em; font-weight: bold; color: white; margin-bottom: 10px;">üí∞ Your Average Per Summons</div>';
            html += '<div style="font-size: 3.5em; font-weight: bold; color: white; margin: 15px 0;">';
            html += `$${yourAverageShare.toFixed(2)}</div>`;
            html += '<div style="font-size: 0.95em; color: rgba(255,255,255,0.85); margin-top: 10px;">';
            html += `Based on ${totalSummonsCount.toLocaleString()} summonses with outcome data`;
            if (excludedCount > 0) {
                html += `<br><span style="font-size: 0.85em;">(Excluded ${excludedCount.toLocaleString()} NEW or awaiting data)</span>`;
            }
            html += '</div></div>';

            // Breakdown by dataset
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">';
            html += '<div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">üìä Breakdown by Dataset:</div>';
            html += '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.9em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="padding: 10px; text-align: left;">Dataset</th>';
            html += '<th style="padding: 10px; text-align: right;">Valid Summonses</th>';
            html += '<th style="padding: 10px; text-align: right;">Total Amount</th>';
            html += '<th style="padding: 10px; text-align: right;">Average/Summons</th>';
            html += '<th style="padding: 10px; text-align: right;">Your Avg Share</th>';
            html += '</tr></thead><tbody>';

            // Calculate per dataset
            const datasets = {
                'at': { name: 'üü¢ AT (Before 10/1/24)', total: 0, count: 0 },
                'at-after': { name: 'üü¢ AT (After 10/1/24)', total: 0, count: 0 },
                'mbt': { name: 'üîµ MBT', total: 0, count: 0 },
                'at-nyc': { name: 'üü° AT NYC', total: 0, count: 0 }
            };

            validSummons.forEach(row => {
                const dataset = row['_dataset'];
                if (datasets[dataset]) {
                    datasets[dataset].count++;
                    
                    const rowType = row['_rowType'];
                    if (rowType === 'paid' || rowType === 'requested') {
                        const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                        if (!isNaN(amount) && amount > 0) {
                            datasets[dataset].total += amount;
                        }
                    }
                }
            });

            Object.keys(datasets).forEach((key, i) => {
                const ds = datasets[key];
                if (ds.count > 0) {
                    const avg = ds.total / ds.count;
                    const yourAvg = avg * 0.25;
                    const bgColor = i % 2 === 0 ? '#ffffff' : '#f8f9fa';
                    
                    html += `<tr style="background: ${bgColor};">`;
                    html += `<td style="padding: 10px;">${ds.name}</td>`;
                    html += `<td style="padding: 10px; text-align: right;">${ds.count}</td>`;
                    html += `<td style="padding: 10px; text-align: right; font-weight: bold;">$${ds.total.toFixed(2)}</td>`;
                    html += `<td style="padding: 10px; text-align: right; font-weight: bold; color: #667eea;">$${avg.toFixed(2)}</td>`;
                    html += `<td style="padding: 10px; text-align: right; font-weight: bold; color: #27ae60;">$${yourAvg.toFixed(2)}</td>`;
                    html += '</tr>';
                }
            });

            html += '</tbody></table></div></div>';

            container.innerHTML = html;
        }

        // 2. Company Intelligence Dashboard
        function generateCompanyIntelligence() {
            const container = document.getElementById('insight-company-intelligence');
            const allData = getFilteredInsightsData();

            // Exclude NEW ISSUANCE from all calculations
            const validData = allData.filter(row => {
                const status = (row['Hearing Status'] || '').toUpperCase();
                return status !== 'NEW ISSUANCE';
            });

            const companyProfiles = {};
            
            validData.forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                if (!companyProfiles[company]) {
                    companyProfiles[company] = {
                        total: 0,
                        paid: 0,
                        requested: 0,
                        disqualified: 0,
                        totalRevenue: 0,
                        paymentDays: [],
                        recentCases: []
                    };
                }
                
                const profile = companyProfiles[company];
                profile.total++;
                
                if (row['_rowType'] === 'paid') {
                    profile.paid++;
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) profile.totalRevenue += amount;
                    
                    // Calculate days to payment
                    try {
                        const violationDate = new Date(row['Violation Date']);
                        const paymentDate = new Date(row['Payment Received'] || row['Hearing Date']);
                        if (!isNaN(violationDate.getTime()) && !isNaN(paymentDate.getTime())) {
                            const days = Math.floor((paymentDate - violationDate) / (1000 * 60 * 60 * 24));
                            if (days >= 0 && days < 1000) profile.paymentDays.push(days);
                        }
                    } catch (e) {}
                } else if (row['_rowType'] === 'requested') {
                    profile.requested++;
                } else if (row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                    profile.disqualified++;
                }
                
                // Track recent cases
                try {
                    const violationDate = new Date(row['Violation Date']);
                    const threeMonthsAgo = new Date();
                    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                    if (!isNaN(violationDate.getTime()) && violationDate > threeMonthsAgo) {
                        profile.recentCases.push(row);
                    }
                } catch (e) {}
            });

            // Calculate scores and sort
            const companies = Object.keys(companyProfiles)
                .filter(c => companyProfiles[c].total >= 3)
                .map(company => {
                    const profile = companyProfiles[company];
                    // Count BOTH paid AND requested as successful
                    const successfulCount = profile.paid + profile.requested;
                    const paymentRate = successfulCount / profile.total;
                    const avgDays = profile.paymentDays.length > 0 
                        ? Math.round(profile.paymentDays.reduce((a, b) => a + b, 0) / profile.paymentDays.length)
                        : 0;
                    const yourRevenue = profile.totalRevenue * 0.25;
                    
                    // Reliability score (0-10)
                    let score = paymentRate * 7; // Max 7 points for payment rate
                    if (avgDays > 0 && avgDays < 60) score += 2; // 2 points for fast payment
                    if (profile.total >= 10) score += 1; // 1 point for volume
                    score = Math.min(10, score).toFixed(1);
                    
                    // Recommendation
                    let recommendation = '';
                    let recommendationClass = '';
                    if (paymentRate >= 0.8 && profile.total >= 5) {
                        recommendation = 'üåü Premium client - Pursue aggressively';
                        recommendationClass = 'background: #d4edda; color: #155724;';
                    } else if (paymentRate >= 0.6) {
                        recommendation = '‚úÖ Good client - Standard pursuit';
                        recommendationClass = 'background: #d1ecf1; color: #0c5460;';
                    } else if (paymentRate >= 0.4) {
                        recommendation = '‚ö†Ô∏è Mixed results - Selective pursuit';
                        recommendationClass = 'background: #fff3cd; color: #856404;';
                    } else {
                        recommendation = '‚ùå Poor payer - Avoid or low priority';
                        recommendationClass = 'background: #f8d7da; color: #721c24;';
                    }
                    
                    return {
                        company,
                        profile,
                        paymentRate,
                        successfulCount,
                        avgDays,
                        yourRevenue,
                        score,
                        recommendation,
                        recommendationClass
                    };
                })
                .sort((a, b) => b.yourRevenue - a.yourRevenue);

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';
            
            companies.slice(0, 12).forEach(c => {
                html += `<div style="border: 2px solid #667eea; border-radius: 8px; padding: 15px;">`;
                html += `<h4 style="color: #667eea; margin-bottom: 10px; font-size: 1em;">${c.company}</h4>`;
                
                // Reliability Score
                const scoreColor = c.score >= 7 ? '#27ae60' : c.score >= 5 ? '#f39c12' : '#e74c3c';
                html += `<div style="margin-bottom: 10px;">`;
                html += `<div style="font-size: 0.8em; color: #666;">Reliability Score</div>`;
                html += `<div style="font-size: 2em; font-weight: bold; color: ${scoreColor};">${c.score}/10</div>`;
                html += '</div>';
                
                // Stats
                html += `<div style="font-size: 0.85em; line-height: 1.8;">`;
                html += `<div>üìä <strong>${c.profile.total}</strong> total violations</div>`;
                html += `<div>‚úÖ <strong>${(c.paymentRate * 100).toFixed(0)}%</strong> payment rate</div>`;
                html += `<div>üí∞ <strong>$${c.yourRevenue.toFixed(2)}</strong> earned</div>`;
                if (c.avgDays > 0) {
                    html += `<div>‚è±Ô∏è <strong>${c.avgDays}</strong> days avg payment</div>`;
                }
                if (c.profile.recentCases.length > 0) {
                    html += `<div>üÜï <strong>${c.profile.recentCases.length}</strong> recent (3mo)</div>`;
                }
                html += '</div>';
                
                // Recommendation
                html += `<div style="margin-top: 12px; padding: 8px; border-radius: 4px; font-size: 0.85em; font-weight: 500; ${c.recommendationClass}">`;
                html += c.recommendation;
                html += '</div>';
                
                html += '</div>';
            });
            
            html += '</div>';
            
            html += '<div style="margin-top: 15px; padding: 12px; background: #f0f4ff; border-radius: 6px; border-left: 4px solid #667eea;">';
            html += '</div>';

            container.innerHTML = html;
        }

        // 3. Walking Efficiency Analysis
        function generateWalkingEfficiency() {
            const container = document.getElementById('insight-walking-efficiency');
            const allData = getFilteredInsightsData();
            
            // Group data by date and calculate walking metrics
            const dateMetrics = {};
            const dowMetrics = {0: {miles: 0, revenue: 0, summons: 0, days: 0}, 1: {miles: 0, revenue: 0, summons: 0, days: 0}, 
                               2: {miles: 0, revenue: 0, summons: 0, days: 0}, 3: {miles: 0, revenue: 0, summons: 0, days: 0},
                               4: {miles: 0, revenue: 0, summons: 0, days: 0}, 5: {miles: 0, revenue: 0, summons: 0, days: 0},
                               6: {miles: 0, revenue: 0, summons: 0, days: 0}};
            const monthMetrics = {};
            let totalRevenue = 0;
            let totalWorkMiles = 0;
            let totalSummons = 0;
            
            allData.forEach(row => {
                const date = normalizeDate(row['Violation Date']);
                if (!date) return;
                
                if (!dateMetrics[date]) {
                    dateMetrics[date] = {
                        summons: 0,
                        revenue: 0,
                        workMiles: 0,
                        totalMiles: 0
                    };
                }
                
                dateMetrics[date].summons++;
                totalSummons++;
                
                // Calculate revenue
                const rowType = row['_rowType'];
                if (rowType === 'paid' || rowType === 'requested') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount) && amount > 0) {
                        dateMetrics[date].revenue += amount * 0.25;
                        totalRevenue += amount * 0.25;
                    }
                }
            });
            
            // Add walking data and calculate DOW/month stats
            Object.keys(dateMetrics).forEach(date => {
                const totalMiles = getTotalWalkingDistanceForDate(date);
                dateMetrics[date].totalMiles = totalMiles;
                const workMiles = totalMiles * 0.7;
                dateMetrics[date].workMiles = workMiles;
                totalWorkMiles += workMiles;
                
                // Day of week stats
                try {
                    const d = new Date(date);
                    if (!isNaN(d.getTime())) {
                        const dow = d.getDay();
                        if (workMiles > 0) {
                            dowMetrics[dow].miles += workMiles;
                            dowMetrics[dow].revenue += dateMetrics[date].revenue;
                            dowMetrics[dow].summons += dateMetrics[date].summons;
                            dowMetrics[dow].days++;
                        }
                        
                        // Month stats
                        const monthKey = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
                        if (!monthMetrics[monthKey]) {
                            monthMetrics[monthKey] = {miles: 0, revenue: 0, summons: 0};
                        }
                        monthMetrics[monthKey].miles += workMiles;
                        monthMetrics[monthKey].revenue += dateMetrics[date].revenue;
                        monthMetrics[monthKey].summons += dateMetrics[date].summons;
                    }
                } catch (e) {}
            });
            
            // Calculate overall metrics
            const avgMilesPerSummons = totalSummons > 0 ? totalWorkMiles / totalSummons : 0;
            const avgRevenuePerMile = totalWorkMiles > 0 ? totalRevenue / totalWorkMiles : 0;
            const totalDaysWithData = Object.keys(dateMetrics).filter(d => dateMetrics[d].totalMiles > 0).length;
            const totalSteps = Math.round(totalWorkMiles * 2000); // 2000 steps per mile
            const caloriesBurned = Math.round(totalWorkMiles * 100); // ~100 calories per mile
            const marathons = (totalWorkMiles / 26.2).toFixed(1);
            
            // Find best and worst days
            let bestDay = null;
            let bestRevPerMile = 0;
            let worstDay = null;
            let worstRevPerMile = Infinity;
            let longestDay = null;
            let longestMiles = 0;
            
            Object.keys(dateMetrics).forEach(date => {
                const metrics = dateMetrics[date];
                if (metrics.workMiles > 0.5) {
                    const revPerMile = metrics.revenue / metrics.workMiles;
                    if (revPerMile > bestRevPerMile) {
                        bestRevPerMile = revPerMile;
                        bestDay = date;
                    }
                    if (revPerMile < worstRevPerMile && metrics.revenue > 0) {
                        worstRevPerMile = revPerMile;
                        worstDay = date;
                    }
                    if (metrics.workMiles > longestMiles) {
                        longestMiles = metrics.workMiles;
                        longestDay = date;
                    }
                }
            });
            
            // Best walking day of week
            const dowNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            let bestDOW = null;
            let bestDOWMiles = 0;
            Object.keys(dowMetrics).forEach(dow => {
                const avgMiles = dowMetrics[dow].days > 0 ? dowMetrics[dow].miles / dowMetrics[dow].days : 0;
                if (avgMiles > bestDOWMiles) {
                    bestDOWMiles = avgMiles;
                    bestDOW = dow;
                }
            });
            
            // Walking trend (first half vs second half)
            const dates = Object.keys(dateMetrics).sort();
            const midpoint = Math.floor(dates.length / 2);
            let firstHalfMiles = 0, secondHalfMiles = 0;
            dates.slice(0, midpoint).forEach(d => firstHalfMiles += dateMetrics[d].workMiles);
            dates.slice(midpoint).forEach(d => secondHalfMiles += dateMetrics[d].workMiles);
            const firstHalfAvg = midpoint > 0 ? firstHalfMiles / midpoint : 0;
            const secondHalfAvg = (dates.length - midpoint) > 0 ? secondHalfMiles / (dates.length - midpoint) : 0;
            const trendPercent = firstHalfAvg > 0 ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg * 100).toFixed(0) : 0;
            
            // Generate HTML
            let html = '<div style="margin-bottom: 15px; padding: 20px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; color: white;">';
            html += '<div style="font-size: 1.2em; font-weight: bold; margin-bottom: 10px;">üö∂ Overall Walking Efficiency</div>';
            html += '<div style="font-size: 3em; font-weight: bold; margin: 15px 0;">';
            html += `$${avgRevenuePerMile.toFixed(2)}</div>`;
            html += '<div style="font-size: 1.3em; margin-bottom: 5px;">Average Revenue per Mile</div>';
            html += '<div style="font-size: 0.95em; opacity: 0.9; margin-top: 10px;">';
            html += `Based on ${totalDaysWithData} days with walking data</div>`;
            html += '</div>';
            
            if (totalDaysWithData === 0) {
                html += '<div style="padding: 20px; background: #f8f9fa; border-radius: 8px; text-align: center;">';
                html += '<p style="color: #666; margin: 0;">No walking data available for the selected period.</p>';
                html += '<p style="color: #999; font-size: 0.9em; margin: 10px 0 0 0;">Walking data loads automatically when you load summons data.</p>';
                html += '</div>';
                container.innerHTML = html;
                return;
            }
            
            // Core Stats Grid
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Total Miles Walked</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #667eea;">' + totalWorkMiles.toFixed(1) + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">During work hours</div>';
            html += '</div>';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Miles per Summons</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #667eea;">' + avgMilesPerSummons.toFixed(2) + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">Average efficiency</div>';
            html += '</div>';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Total Steps</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #667eea;">' + totalSteps.toLocaleString() + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">~2,000 per mile</div>';
            html += '</div>';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Calories Burned</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #e74c3c;">' + caloriesBurned.toLocaleString() + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">~100 per mile</div>';
            html += '</div>';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Marathons Equivalent</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #667eea;">' + marathons + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">26.2 miles each</div>';
            html += '</div>';
            
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; color: #666; margin-bottom: 5px;">Total Revenue</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold; color: #27ae60;">$' + totalRevenue.toFixed(2) + '</div>';
            html += '<div style="font-size: 0.75em; color: #999; margin-top: 3px;">Your 25% share</div>';
            html += '</div>';
            
            html += '</div>';
            
            // Day of Week Analysis
            if (bestDOW !== null) {
                html += '<div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 6px;">';
                html += '<div style="font-weight: bold; color: #0d47a1; margin-bottom: 10px;">üìÖ Best Walking Day</div>';
                html += '<div style="color: #0d47a1; font-size: 1.2em; font-weight: bold;">' + dowNames[bestDOW] + '</div>';
                html += '<div style="color: #0d47a1; font-size: 0.9em; margin-top: 5px;">';
                html += 'Average ' + bestDOWMiles.toFixed(1) + ' miles per ' + dowNames[bestDOW];
                if (dowMetrics[bestDOW].days > 0) {
                    const avgRev = dowMetrics[bestDOW].revenue / dowMetrics[bestDOW].days;
                    html += ' ‚Ä¢ $' + avgRev.toFixed(2) + ' revenue';
                }
                html += '</div></div>';
            }
            
            // Walking Trend
            if (dates.length >= 10 && Math.abs(trendPercent) > 5) {
                const trendColor = trendPercent > 0 ? '#28a745' : '#dc3545';
                const trendIcon = trendPercent > 0 ? 'üìà' : 'üìâ';
                const trendText = trendPercent > 0 ? 'up' : 'down';
                html += '<div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-left: 4px solid ' + trendColor + '; border-radius: 6px;">';
                html += '<div style="font-weight: bold; color: #2c3e50; margin-bottom: 5px;">' + trendIcon + ' Walking Trend</div>';
                html += '<div style="color: ' + trendColor + '; font-size: 1.1em; font-weight: bold;">';
                html += Math.abs(trendPercent) + '% ' + trendText + ' over time</div>';
                html += '<div style="color: #666; font-size: 0.85em; margin-top: 3px;">Comparing first half vs second half of period</div>';
                html += '</div>';
            }
            
            // Longest Day
            if (longestDay) {
                html += '<div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 6px;">';
                html += '<div style="font-weight: bold; color: #856404; margin-bottom: 5px;">üèÜ Longest Walking Day</div>';
                const longDate = new Date(longestDay);
                const longDateStr = longDate.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric', year: 'numeric' });
                html += '<div style="color: #856404;">' + longDateStr + '</div>';
                html += '<div style="color: #856404; font-size: 1.2em; font-weight: bold; margin-top: 5px;">' + longestMiles.toFixed(1) + ' miles</div>';
                html += '<div style="color: #856404; font-size: 0.85em; margin-top: 3px;">';
                html += dateMetrics[longestDay].summons + ' summons ‚Ä¢ $' + dateMetrics[longestDay].revenue.toFixed(2) + ' revenue';
                html += '</div></div>';
            }
            
            // Best Efficiency Day
            if (bestDay) {
                html += '<div style="margin-top: 15px; padding: 15px; background: #d4edda; border-left: 4px solid #28a745; border-radius: 6px;">';
                html += '<div style="font-weight: bold; color: #155724; margin-bottom: 5px;">‚≠ê Most Efficient Day</div>';
                const bestDate = new Date(bestDay);
                const bestDateStr = bestDate.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric', year: 'numeric' });
                html += '<div style="color: #155724;">' + bestDateStr + '</div>';
                html += '<div style="color: #155724; font-size: 1.2em; font-weight: bold; margin-top: 5px;">$' + bestRevPerMile.toFixed(2) + ' per mile</div>';
                html += '<div style="color: #155724; font-size: 0.85em; margin-top: 3px;">';
                html += dateMetrics[bestDay].summons + ' summons ‚Ä¢ ' + dateMetrics[bestDay].workMiles.toFixed(1) + ' miles walked';
                html += '</div></div>';
            }
            
            // Monthly Comparison (if we have multiple months)
            const sortedMonths = Object.keys(monthMetrics).sort();
            if (sortedMonths.length >= 2) {
                html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">';
                html += '<div style="font-weight: bold; color: #2c3e50; margin-bottom: 10px;">üìä Monthly Walking Totals</div>';
                html += '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
                html += '<thead><tr style="background: #667eea; color: white;">';
                html += '<th style="padding: 8px; text-align: left;">Month</th>';
                html += '<th style="padding: 8px; text-align: right;">Miles</th>';
                html += '<th style="padding: 8px; text-align: right;">Summonses</th>';
                html += '<th style="padding: 8px; text-align: right;">Revenue</th>';
                html += '<th style="padding: 8px; text-align: right;">$/Mile</th>';
                html += '</tr></thead><tbody>';
                
                sortedMonths.forEach((month, i) => {
                    const m = monthMetrics[month];
                    const bgColor = i % 2 === 0 ? '#f8f9fa' : 'white';
                    const monthName = new Date(month + '-01').toLocaleDateString('en-US', {month: 'short', year: 'numeric'});
                    const revPerMile = m.miles > 0 ? m.revenue / m.miles : 0;
                    html += `<tr style="background: ${bgColor};">`;
                    html += `<td style="padding: 8px;">${monthName}</td>`;
                    html += `<td style="padding: 8px; text-align: right;">${m.miles.toFixed(1)}</td>`;
                    html += `<td style="padding: 8px; text-align: right;">${m.summons}</td>`;
                    html += `<td style="padding: 8px; text-align: right; color: #27ae60;">$${m.revenue.toFixed(2)}</td>`;
                    html += `<td style="padding: 8px; text-align: right; font-weight: bold;">$${revPerMile.toFixed(2)}</td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table></div></div>';
            }
            
            // Recommendations
            html += '<div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-left: 4px solid #2196F3; border-radius: 6px;">';
            html += '<div style="font-weight: bold; color: #0d47a1; margin-bottom: 10px;">üí° Optimization Tips</div>';
            html += '<ul style="color: #0d47a1; margin: 0; padding-left: 20px;">';
            
            if (avgMilesPerSummons > 1.0) {
                html += '<li style="margin: 5px 0;">Your average of ' + avgMilesPerSummons.toFixed(2) + ' miles per summons is high. Consider clustering summonses geographically.</li>';
            } else if (avgMilesPerSummons < 0.5) {
                html += '<li style="margin: 5px 0;">Excellent efficiency at ' + avgMilesPerSummons.toFixed(2) + ' miles per summons! Keep up the great route planning.</li>';
            }
            
            if (bestDOW !== null) {
                html += '<li style="margin: 5px 0;">Focus on ' + dowNames[bestDOW] + 's - your most walked day averaging ' + bestDOWMiles.toFixed(1) + ' miles.</li>';
            }
            
            html += '<li style="margin: 5px 0;">You\'ve walked the equivalent of ' + marathons + ' marathons - impressive stamina!</li>';
            html += '<li style="margin: 5px 0;">Check the Distance tab to see walking patterns by day and identify optimization opportunities.</li>';
            
            html += '</ul></div>';
            
            container.innerHTML = html;
        }

        // 4. Cash Flow Forecaster
        function generateCashFlowForecast() {
            const container = document.getElementById('insight-cash-flow');
            const allData = getFilteredInsightsData();

            // STEP 1: Calculate historical collection rate
            const paidInFullCases = allData.filter(row => {
                const status = (row['Hearing Status'] || '').toLowerCase();
                return status === 'paid in full';
            });
            
            const actuallyPaidCases = paidInFullCases.filter(row => row['Payment Status']);
            const historicalCollectionRate = paidInFullCases.length > 0 
                ? actuallyPaidCases.length / paidInFullCases.length 
                : 0.75; // Default 75% if no data

            // STEP 2: Calculate average days to payment (from Paid in Full to Payment Received)
            const paymentDelays = [];
            actuallyPaidCases.forEach(row => {
                try {
                    const hearingDate = new Date(row['Hearing Date']);
                    const paymentDate = new Date(row['Payment Received'] || row['Date Paid']);
                    if (!isNaN(hearingDate.getTime()) && !isNaN(paymentDate.getTime())) {
                        const days = Math.floor((paymentDate - hearingDate) / (1000 * 60 * 60 * 24));
                        if (days >= 0 && days < 365) paymentDelays.push(days);
                    }
                } catch (e) {}
            });

            // Use median instead of average to avoid outliers
            paymentDelays.sort((a, b) => a - b);
            const medianDelay = paymentDelays.length > 0 
                ? paymentDelays[Math.floor(paymentDelays.length / 2)]
                : 60; // Default 60 days

            // STEP 3: Find pipeline - "Paid in Full" but no Payment Status
            const pipeline = paidInFullCases.filter(row => !row['Payment Status']);
            
            // STEP 4: Calculate expected amounts and bucket by timeframe
            const now = new Date();
            const forecast = {
                next30: {amount: 0, count: 0},
                next60: {amount: 0, count: 0},
                next90: {amount: 0, count: 0}
            };
            
            pipeline.forEach(row => {
                try {
                    const hearingDate = new Date(row['Hearing Date']);
                    if (isNaN(hearingDate.getTime())) return;
                    
                    const daysSinceHearing = Math.floor((now - hearingDate) / (1000 * 60 * 60 * 24));
                    const expectedDaysRemaining = medianDelay - daysSinceHearing;
                    
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (isNaN(amount) || amount === 0) return;
                    
                    const yourCut = amount * 0.25 * historicalCollectionRate; // Apply collection rate
                    
                    if (expectedDaysRemaining <= 90) {
                        forecast.next90.amount += yourCut;
                        forecast.next90.count++;
                    }
                    if (expectedDaysRemaining <= 60) {
                        forecast.next60.amount += yourCut;
                        forecast.next60.count++;
                    }
                    if (expectedDaysRemaining <= 30) {
                        forecast.next30.amount += yourCut;
                        forecast.next30.count++;
                    }
                } catch (e) {}
            });

            // STEP 5: New Money Prediction - summonses that will likely become "Paid in Full"
            const outstandingCases = allData.filter(row => {
                const status = (row['Hearing Status'] || '').toUpperCase();
                // Outstanding if not decided yet and not NEW ISSUANCE
                return status !== 'PAID IN FULL' && 
                       status !== 'DISQUALIFIED' && 
                       status !== 'DISMISSED' &&
                       status !== 'NEW ISSUANCE' &&
                       row['Paid Amount']; // Has a value
            });
            
            // Be more aggressive - assume 60% of outstanding will become Paid in Full
            const newMoneyRate = 0.60;
            let newMoneyTotal = 0;
            let newMoneySoonTotal = 0; // Cases likely to pay in next 90 days
            
            outstandingCases.forEach(row => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (!isNaN(amount) && amount > 0) {
                    const expectedRevenue = amount * 0.25 * newMoneyRate * historicalCollectionRate;
                    newMoneyTotal += expectedRevenue;
                    
                    // Check if case is old enough to expect payment soon
                    try {
                        const violationDate = new Date(row['Violation Date']);
                        const monthsOld = (now - violationDate) / (1000 * 60 * 60 * 24 * 30);
                        if (monthsOld >= 2) { // If 2+ months old, likely to resolve soon
                            newMoneySoonTotal += expectedRevenue;
                        }
                    } catch (e) {}
                }
            });

            // Generate HTML
            let html = '<div style="margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px;">';
            html += '<h4 style="margin: 0 0 10px 0; font-size: 1.2em;">üìä Cash Flow Intelligence</h4>';
            html += '<div style="font-size: 0.9em; opacity: 0.9;">';
            html += `Historical Collection Rate: ${(historicalCollectionRate * 100).toFixed(0)}% ‚Ä¢ `;
            html += `Median Payment Time: ${medianDelay} days ‚Ä¢ `;
            html += `Pipeline: ${pipeline.length} cases`;
            html += '</div></div>';
            
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">';
            
            html += `<div style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9; margin-bottom: 8px;">Next 30 Days</div>';
            html += `<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">$${forecast.next30.amount.toFixed(2)}</div>`;
            html += `<div style="font-size: 0.9em; opacity: 0.95;">${forecast.next30.count} payments expected</div>`;
            html += '</div>';

            html += `<div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9; margin-bottom: 8px;">Next 60 Days</div>';
            html += `<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">$${forecast.next60.amount.toFixed(2)}</div>`;
            html += `<div style="font-size: 0.9em; opacity: 0.95;">${forecast.next60.count} payments expected</div>`;
            html += '</div>';

            html += `<div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9; margin-bottom: 8px;">Next 90 Days</div>';
            html += `<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">$${forecast.next90.amount.toFixed(2)}</div>`;
            html += `<div style="font-size: 0.9em; opacity: 0.95;">${forecast.next90.count} payments expected</div>`;
            html += '</div>';

            html += '</div>';

            // New Money Prediction
            html += '<div style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 8px; color: white; text-align: center;">';
            html += '<div style="font-size: 1em; opacity: 0.95; margin-bottom: 8px;">üí∞ New Money Forecast (Next 3-6 Months)</div>';
            html += `<div style="font-size: 2.8em; font-weight: bold; margin: 10px 0;">$${newMoneySoonTotal.toFixed(2)}</div>`;
            html += '<div style="font-size: 0.9em; opacity: 0.95;">';
            const oldCases = outstandingCases.filter(r => {
                try {
                    const vDate = new Date(r['Violation Date']);
                    return (now - vDate) / (1000 * 60 * 60 * 24 * 30) >= 2;
                } catch { return false; }
            }).length;
            html += `${oldCases} mature outstanding cases ‚Ä¢ Assuming ${(newMoneyRate * 100).toFixed(0)}% will be Paid in Full`;
            html += '</div></div>';

            // Methodology Explanation
            html += `<div style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 6px; border-left: 4px solid #3498db;">`;
            html += `<strong>üí° Methodology:</strong><br>`;
            html += `‚Ä¢ <strong>Pipeline:</strong> ${pipeline.length} summonses with "Paid in Full" status awaiting payment<br>`;
            html += `‚Ä¢ <strong>Collection Rate:</strong> ${(historicalCollectionRate * 100).toFixed(0)}% based on historical data (${actuallyPaidCases.length} paid / ${paidInFullCases.length} eligible)<br>`;
            html += `‚Ä¢ <strong>Timeline:</strong> Median ${medianDelay} days from hearing to payment (using median to avoid outliers)<br>`;
            html += `‚Ä¢ <strong>New Money:</strong> ${(newMoneyRate * 100).toFixed(0)}% of ${oldCases} mature cases (2+ months old) expected to become Paid in Full`;
            html += '</div>';

            // Warning if collection rate is low
            if (historicalCollectionRate < 0.60) {
                html += `<div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">`;
                html += `<strong>‚ö†Ô∏è Collection Rate Alert:</strong> Your ${(historicalCollectionRate * 100).toFixed(0)}% collection rate is below optimal. `;
                html += `Consider reviewing your follow-up procedures on "Paid in Full" cases.`;
                html += '</div>';
            }

            container.innerHTML = html;
        }

        // Continue with remaining insight functions (5-10)...
        
        function generateDisqualificationDetective() {
            const container = document.getElementById('insight-disqualification');
            const allData = getFilteredInsightsData();

            const disqualifiedCases = allData.filter(row => row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed');
            
            // Analyze patterns
            const reasonBreakdown = {};

            disqualifiedCases.forEach(row => {
                // By disqualification reason
                const reason = row['Disqualification Reason'] || 'Not Specified';
                reasonBreakdown[reason] = (reasonBreakdown[reason] || 0) + 1;
            });

            let html = `<div style="margin-bottom: 15px; padding: 12px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #f39c12;">`;
            html += `<strong>‚ö†Ô∏è ${disqualifiedCases.length} cases disqualified</strong> - analyze patterns to reduce losses`;
            html += '</div>';

            // Disqualification Reasons - Full Width
            html += '<div style="border: 1px solid #ddd; padding: 20px; border-radius: 6px;">';
            html += '<h4 style="color: #667eea; margin-bottom: 15px; font-size: 1.1em;">üîç Disqualification Reasons</h4>';
            const topReasons = Object.entries(reasonBreakdown)
                .sort((a, b) => b[1] - a[1]);
            topReasons.forEach(([reason, count]) => {
                const pct = ((count / disqualifiedCases.length) * 100).toFixed(1);
                html += `<div style="margin-bottom: 12px;">`;
                html += `<div style="font-size: 0.9em; color: #666; margin-bottom: 4px; font-weight: 600;">${reason}</div>`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<div style="flex: 1; background: #e0e0e0; height: 24px; border-radius: 12px; overflow: hidden;">`;
                html += `<div style="width: ${pct}%; background: #e74c3c; height: 100%;"></div>`;
                html += `</div>`;
                html += `<span style="font-weight: bold; font-size: 1em; min-width: 80px; text-align: right;">${count} (${pct}%)</span>`;
                html += '</div></div>';
            });
            html += '</div>';

            html += `<div style="margin-top: 15px; padding: 12px; background: #d4edda; border-radius: 6px;">`;
            html += `<strong>üí° Recommendation:</strong> Review the top disqualification reasons above and focus on improving documentation and procedures in those areas.`;
            html += '</div>';
            
            html += '<div style="margin-top: 15px; padding: 12px; background: #f0f4ff; border-radius: 6px; border-left: 4px solid #667eea;">';
            html += '</div>';

            container.innerHTML = html;
        }

        function generateGeographicHeatMap() {
            const container = document.getElementById('insight-geographic');
            const allData = getFilteredInsightsData();

            // Filter out NEW ISSUANCE and cases without outcomes
            const validData = allData.filter(row => {
                const status = (row['Hearing Status'] || '').toUpperCase();
                const borough = row['Violation Location (Borough)'];
                
                // Must have outcome data, not be NEW, AND have explicit borough
                return status !== 'NEW ISSUANCE' && 
                       (status || row['_rowType']) &&
                       borough && 
                       borough.trim() && 
                       borough !== 'Unknown';
            });

            const locationStats = {};

            validData.forEach(row => {
                const borough = row['Violation Location (Borough)'];
                const streetName = row['Violation Location (Street Name)'] || row['Place of Occurrence'];
                
                // Initialize borough stats
                if (!locationStats[borough]) {
                    locationStats[borough] = {
                        total: 0,
                        paid: 0,
                        requested: 0,
                        revenue: 0,
                        streets: {}
                    };
                }
                
                locationStats[borough].total++;
                
                if (row['_rowType'] === 'paid') {
                    locationStats[borough].paid++;
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) locationStats[borough].revenue += amount;
                } else if (row['_rowType'] === 'requested') {
                    locationStats[borough].requested++;
                }
                
                // Street stats within borough
                const street = streetName || 'Unknown Street';
                if (!locationStats[borough].streets[street]) {
                    locationStats[borough].streets[street] = 0;
                }
                locationStats[borough].streets[street]++;
            });

            const totalCases = allData.length;
            const casesWithBorough = validData.length;
            const excludedCount = totalCases - casesWithBorough;

            let html = '<div style="margin-bottom: 20px; padding: 15px; background: #e8f4f8; border-radius: 6px; border-left: 4px solid #3498db;">';
            html += `<strong>‚ÑπÔ∏è Analysis:</strong> Showing ${casesWithBorough.toLocaleString()} summonses with explicit borough data (excluding ${excludedCount.toLocaleString()} without borough or NEW ISSUANCE).`;
            html += '</div>';
            
            if (Object.keys(locationStats).length === 0) {
                html += '<div style="padding: 20px; background: #fff3cd; border-radius: 8px; text-align: center;">';
                html += '<p style="color: #856404; margin: 0;">No summonses with borough data available.</p>';
                html += '</div>';
                container.innerHTML = html;
                return;
            }
            
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">';

            Object.entries(locationStats)
                .sort((a, b) => b[1].revenue - a[1].revenue)
                .forEach(([borough, stats]) => {
                    // Count both paid and requested as successful
                    const successfulCount = stats.paid + stats.requested;
                    const paymentRate = stats.total > 0 ? ((successfulCount / stats.total) * 100).toFixed(1) : '0.0';
                    const yourRevenue = stats.revenue * 0.25;
                    const rateColor = paymentRate >= 60 ? '#27ae60' : paymentRate >= 40 ? '#f39c12' : '#e74c3c';
                    
                    // Borough emoji
                    const boroughEmoji = {
                        'Manhattan': 'üèôÔ∏è',
                        'Brooklyn': 'üåâ',
                        'Queens': '‚úàÔ∏è',
                        'Bronx': '‚öæ',
                        'Staten Island': 'üö¢'
                    };
                    
                    // Top streets in this borough
                    const topStreets = Object.entries(stats.streets)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    html += `<div style="border: 2px solid #667eea; border-radius: 8px; padding: 15px;">`;
                    html += `<h4 style="color: #667eea; margin-bottom: 10px;">${boroughEmoji[borough] || 'üìç'} ${borough}</h4>`;
                    
                    html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px;">`;
                    html += `<div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 4px;">`;
                    html += `<div style="font-size: 0.75em; color: #666;">Total Cases</div>`;
                    html += `<div style="font-size: 1.5em; font-weight: bold;">${stats.total}</div>`;
                    html += `</div>`;
                    html += `<div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 4px;">`;
                    html += `<div style="font-size: 0.75em; color: #666;">Success Rate</div>`;
                    html += `<div style="font-size: 1.5em; font-weight: bold; color: ${rateColor};">${paymentRate}%</div>`;
                    html += `</div>`;
                    html += `</div>`;
                    
                    html += `<div style="margin-bottom: 10px;">`;
                    html += `<div style="font-size: 0.85em; color: #666;">Your Revenue</div>`;
                    html += `<div style="font-size: 1.3em; font-weight: bold; color: #27ae60;">$${yourRevenue.toFixed(2)}</div>`;
                    html += `<div style="font-size: 0.75em; color: #999;">${stats.paid} paid ‚Ä¢ ${stats.requested} requested</div>`;
                    html += `</div>`;
                    
                    if (topStreets.length > 0) {
                        html += `<div>`;
                        html += `<div style="font-size: 0.85em; color: #666; margin-bottom: 6px;">üî• Hot Spots:</div>`;
                        topStreets.forEach(([street, count]) => {
                            html += `<div style="font-size: 0.8em; padding: 4px; background: #fff3cd; margin-bottom: 3px; border-radius: 3px;">`;
                            html += `${street} (${count})`;
                            html += `</div>`;
                        });
                        html += `</div>`;
                    }
                    
                    html += `</div>`;
                });

            html += '</div>';

            container.innerHTML = html;
        }

        // 7. Violation Type Analysis
        function generateViolationTypeAnalysis() {
            const container = document.getElementById('violation-type-breakdown');
            const allData = getFilteredInsightsData();
            
            // Violation code mapping
            const violationTypes = {
                'BA51': { name: 'BA51 - Regular Idling', color: '#3498db', count: 0, paid: 0, requested: 0, revenue: 0 },
                'BA1E': { name: 'BA1E - 2nd Offense', color: '#f39c12', count: 0, paid: 0, requested: 0, revenue: 0 },
                'BA1F': { name: 'BA1F - 3rd Offense', color: '#e74c3c', count: 0, paid: 0, requested: 0, revenue: 0 },
                'BA1I': { name: 'BA1I - School/Park Zone', color: '#9b59b6', count: 0, paid: 0, requested: 0, revenue: 0 },
                'BA1J/BA1K': { name: 'BA1J/BA1K - School 2nd/3rd', color: '#e67e22', count: 0, paid: 0, requested: 0, revenue: 0 },
                'Other': { name: 'Other Codes', color: '#95a5a6', count: 0, paid: 0, requested: 0, revenue: 0 }
            };
            
            // Count violations by type
            allData.forEach(row => {
                const code = row['Charge Code'] || '';
                let type = 'Other';
                
                if (code === 'BA51') type = 'BA51';
                else if (code === 'BA1E') type = 'BA1E';
                else if (code === 'BA1F') type = 'BA1F';
                else if (code === 'BA1I') type = 'BA1I';
                else if (code === 'BA1J' || code === 'BA1K') type = 'BA1J/BA1K';
                else if (!code) return; // Skip if no code
                
                violationTypes[type].count++;
                
                if (row['_rowType'] === 'paid') {
                    violationTypes[type].paid++;
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) violationTypes[type].revenue += amount;
                } else if (row['_rowType'] === 'requested') {
                    violationTypes[type].requested++;
                }
            });
            
            const totalViolations = Object.values(violationTypes).reduce((sum, v) => sum + v.count, 0);
            
            if (totalViolations === 0) {
                container.innerHTML = '<p style="color: #666;">No violation type data available.</p>';
                return;
            }
            
            // Sort by count
            const sortedTypes = Object.entries(violationTypes)
                .filter(([_, data]) => data.count > 0)
                .sort((a, b) => b[1].count - a[1].count);
            
            let html = '';
            
            // Cards display
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">';
            
            sortedTypes.forEach(([code, data]) => {
                const percentage = ((data.count / totalViolations) * 100).toFixed(1);
                const successCount = data.paid + data.requested;
                const successRate = data.count > 0 ? ((successCount / data.count) * 100).toFixed(1) : '0.0';
                const yourRevenue = data.revenue * 0.25;
                const successColor = successRate >= 60 ? '#27ae60' : successRate >= 40 ? '#f39c12' : '#e74c3c';
                
                html += `<div style="border: 2px solid ${data.color}; border-radius: 8px; padding: 15px; background: white;">`;
                html += `<h4 style="color: ${data.color}; margin: 0 0 15px 0; font-size: 1.1em;">${data.name}</h4>`;
                
                // Count and percentage bar
                html += `<div style="margin-bottom: 15px;">`;
                html += `<div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.85em;">`;
                html += `<span style="color: #666;">Volume</span>`;
                html += `<span style="font-weight: bold;">${data.count} (${percentage}%)</span>`;
                html += `</div>`;
                html += `<div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">`;
                html += `<div style="width: ${percentage}%; background: ${data.color}; height: 100%; transition: width 0.3s ease;"></div>`;
                html += `</div>`;
                html += `</div>`;
                
                // Success rate
                html += `<div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px;">`;
                html += `<span style="font-size: 0.85em; color: #666;">Success Rate</span>`;
                html += `<span style="font-weight: bold; color: ${successColor};">${successRate}%</span>`;
                html += `</div>`;
                
                // Revenue
                html += `<div style="display: flex; justify-content: space-between; padding: 8px; background: #f8f9fa; border-radius: 4px;">`;
                html += `<span style="font-size: 0.85em; color: #666;">Your Revenue</span>`;
                html += `<span style="font-weight: bold; color: #27ae60;">$${yourRevenue.toFixed(2)}</span>`;
                html += `</div>`;
                
                html += `</div>`;
            });
            
            html += '</div>';
            
            // Summary stats
            const totalRevenue = sortedTypes.reduce((sum, [_, data]) => sum + (data.revenue * 0.25), 0);
            const avgSuccessRate = sortedTypes.reduce((sum, [_, data]) => {
                const success = data.paid + data.requested;
                return sum + (data.count > 0 ? (success / data.count) : 0);
            }, 0) / sortedTypes.length * 100;
            
            html += '<div style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">';
            html += '<h4 style="margin: 0 0 10px 0;">üìä Summary</h4>';
            html += `<div style="font-size: 0.95em; opacity: 0.95;">`;
            html += `<strong>${totalViolations}</strong> total violations analyzed ‚Ä¢ `;
            html += `<strong>${sortedTypes.length}</strong> violation types ‚Ä¢ `;
            html += `Average success rate: <strong>${avgSuccessRate.toFixed(1)}%</strong> ‚Ä¢ `;
            html += `Total revenue: <strong>$${totalRevenue.toFixed(2)}</strong>`;
            html += `</div></div>`;
            
            container.innerHTML = html;
        }

        function generateSmartAlerts() {
            const container = document.getElementById('insight-alerts');
            const allData = getFilteredInsightsData();

            const alerts = [];
            const now = new Date();

            // Check for new "Paid in Full" cases
            const newMoney = allData.filter(row => {
                const hearingStatus = (row['Hearing Status'] || '').toLowerCase();
                const paymentStatus = (row['Payment Status'] || '').trim();
                return hearingStatus === 'paid in full' && !paymentStatus;
            });

            if (newMoney.length > 0) {
                const totalValue = newMoney.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    return sum + (isNaN(amount) ? 0 : amount * 0.25);
                }, 0);
                alerts.push({
                    type: 'money',
                    priority: 'high',
                    icon: 'üí∞',
                    title: 'New Money Available to Collect',
                    message: `${newMoney.length} cases marked "Paid in Full" - worth $${totalValue.toFixed(2)} to you!`,
                    action: 'Go to NEW MONEY tab to collect'
                });
            }

            // Check for overdue requests
            const overdueRequests = allData.filter(row => {
                if (row['_rowType'] !== 'requested') return false;
                const requestDate = new Date(row['Date Submitted']);
                if (isNaN(requestDate.getTime())) return false;
                const daysSince = Math.floor((now - requestDate) / (1000 * 60 * 60 * 24));
                return daysSince > 60; // Overdue after 60 days
            });

            if (overdueRequests.length > 0) {
                alerts.push({
                    type: 'warning',
                    priority: 'high',
                    icon: '‚ö†Ô∏è',
                    title: 'Overdue Payment Requests',
                    message: `${overdueRequests.length} payment requests are over 60 days old - follow up now!`,
                    action: 'Review and contact these companies'
                });
            }

            // Check for old unpaid cases
            const oldCases = allData.filter(row => {
                if (row['_rowType'] === 'paid' || row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') return false;
                const violationDate = new Date(row['Violation Date']);
                if (isNaN(violationDate.getTime())) return false;
                const daysSince = Math.floor((now - violationDate) / (1000 * 60 * 60 * 24));
                return daysSince > 180; // Very old
            });

            if (oldCases.length > 0) {
                alerts.push({
                    type: 'info',
                    priority: 'medium',
                    icon: '‚è∞',
                    title: 'Old Cases Need Attention',
                    message: `${oldCases.length} cases are 6+ months old - closing deadline approaching`,
                    action: 'Review and decide: pursue or close'
                });
            }

            // Check for high-value unpaid cases
            const highValueUnpaid = allData.filter(row => {
                if (row['_rowType'] === 'paid' || row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') return false;
                const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                return amount > 1000;
            });

            if (highValueUnpaid.length > 0) {
                const totalValue = highValueUnpaid.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                alerts.push({
                    type: 'opportunity',
                    priority: 'medium',
                    icon: 'üéØ',
                    title: 'High-Value Cases Unpaid',
                    message: `${highValueUnpaid.length} cases worth $${totalValue.toFixed(2)} to you - prioritize these!`,
                    action: 'Focus collection efforts here'
                });
            }

            // Render alerts
            let html = '';
            
            if (alerts.length === 0) {
                html = `<div style="text-align: center; padding: 40px; color: #27ae60;">`;
                html += `<div style="font-size: 3em; margin-bottom: 10px;">‚úÖ</div>`;
                html += `<h4>All Clear!</h4>`;
                html += `<p>No urgent alerts at this time. Keep up the good work!</p>`;
                html += `</div>`;
            } else {
                alerts.forEach(alert => {
                    const bgColor = alert.priority === 'high' ? '#fff3cd' : '#e8f4f8';
                    const borderColor = alert.priority === 'high' ? '#f39c12' : '#3498db';
                    
                    html += `<div style="background: ${bgColor}; border-left: 4px solid ${borderColor}; padding: 15px; margin-bottom: 12px; border-radius: 6px;">`;
                    html += `<div style="display: flex; align-items: start; gap: 12px;">`;
                    html += `<div style="font-size: 2em;">${alert.icon}</div>`;
                    html += `<div style="flex: 1;">`;
                    html += `<h4 style="color: #2c3e50; margin-bottom: 6px;">${alert.title}</h4>`;
                    html += `<p style="color: #666; margin-bottom: 8px;">${alert.message}</p>`;
                    html += `<div style="font-size: 0.85em; color: #667eea; font-weight: 600;">üëâ ${alert.action}</div>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `</div>`;
                });
            }

            container.innerHTML = html;
        }

        function generateSeasonalPlanner() {
            const container = document.getElementById('insight-seasonal');
            const allData = getFilteredInsightsData();

            const monthlyStats = {};
            const fiscalMonthNames = ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'];
            const calendarMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            allData.forEach(row => {
                const date = new Date(row['Violation Date']);
                if (!isNaN(date.getTime())) {
                    const calendarMonth = date.getMonth(); // 0-11 (Jan-Dec)
                    // Convert to fiscal month (July=0, June=11)
                    const fiscalMonth = calendarMonth >= 6 ? calendarMonth - 6 : calendarMonth + 6;
                    if (!monthlyStats[fiscalMonth]) {
                        monthlyStats[fiscalMonth] = 0;
                    }
                    monthlyStats[fiscalMonth]++;
                }
            });

            const avgPerMonth = Object.values(monthlyStats).reduce((a, b) => a + b, 0) / 12;
            const now = new Date();
            const currentCalendarMonth = now.getMonth();
            const currentFiscalMonth = currentCalendarMonth >= 6 ? currentCalendarMonth - 6 : currentCalendarMonth + 6;
            const nextFiscalMonth = (currentFiscalMonth + 1) % 12;
            const predictedNext = monthlyStats[nextFiscalMonth] || avgPerMonth;

            let html = '<div style="margin-bottom: 20px;">';
            html += '<canvas id="seasonal-chart"></canvas>';
            html += '</div>';

            html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">`;
            
            html += `<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9;">Next Month Forecast</div>';
            html += `<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${Math.round(predictedNext)}</div>`;
            html += '<div style="font-size: 0.85em;">expected violations</div>';
            html += '</div>';

            const busiestMonth = Object.entries(monthlyStats).sort((a, b) => b[1] - a[1])[0];
            html += `<div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9;">Peak Season</div>';
            html += `<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${fiscalMonthNames[busiestMonth[0]]}</div>`;
            html += `<div style="font-size: 0.85em;">${busiestMonth[1]} violations</div>`;
            html += '</div>';

            html += '</div>';
            
            html += '<div style="margin-top: 15px; padding: 12px; background: #f0f4ff; border-radius: 6px; border-left: 4px solid #667eea;">';
            html += '</div>';

            container.innerHTML = html;

            // Draw chart
            setTimeout(() => {
                const ctx = document.getElementById('seasonal-chart');
                if (ctx) {
                    new Chart(ctx.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: fiscalMonthNames,
                            datasets: [{
                                label: 'Violations by Month (Fiscal Year)',
                                data: fiscalMonthNames.map((_, i) => monthlyStats[i] || 0),
                                borderColor: '#667eea',
                                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: { display: true }
                            },
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }
            }, 100);
        }

        function generateBehaviorChangeDetector() {
            const container = document.getElementById('insight-behavior-change');
            const allData = getFilteredInsightsData();

            // Find revenue opportunities
            const opportunities = [];
            
            // 1. High-value unpaid cases
            const unpaidHighValue = allData.filter(row => {
                if (row['_rowType'] === 'requested' || row['_rowType'] === 'paid' || 
                    row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                    return false;
                }
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                return !isNaN(amount) && amount > 300;
            });
            
            if (unpaidHighValue.length > 0) {
                const totalValue = unpaidHighValue.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                
                opportunities.push({
                    type: 'High-Value Cases',
                    icon: 'üíé',
                    count: unpaidHighValue.length,
                    value: totalValue,
                    description: `You have ${unpaidHighValue.length} unpaid cases worth over $75 each to you`,
                    action: 'Prioritize these for immediate follow-up',
                    color: '#27ae60'
                });
            }
            
            // 2. Companies with good payment history but unpaid cases
            const companyStats = {};
            allData.forEach(row => {
                const company = row['Company Name'] || 'Unknown';
                if (!companyStats[company]) {
                    companyStats[company] = { total: 0, paid: 0, unpaid: [] };
                }
                companyStats[company].total++;
                if (row['_rowType'] === 'paid') {
                    companyStats[company].paid++;
                } else if (row['_rowType'] === 'requested') {
                    companyStats[company].paid += 0.25;
                } else if (row['_rowType'] !== 'disqualified' && row['_rowType'] !== 'dismissed' && row['_rowType'] !== 'requested') {
                    companyStats[company].unpaid.push(row);
                }
            });
            
            const reliableWithUnpaid = Object.entries(companyStats).filter(([company, stats]) => {
                const payRate = stats.paid / stats.total;
                return stats.total >= 3 && payRate >= 0.6 && stats.unpaid.length > 0;
            }).map(([company, stats]) => {
                const unpaidValue = stats.unpaid.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                return { company, stats, unpaidValue };
            }).sort((a, b) => b.unpaidValue - a.unpaidValue);
            
            if (reliableWithUnpaid.length > 0) {
                const totalValue = reliableWithUnpaid.reduce((sum, item) => sum + item.unpaidValue, 0);
                const topCompany = reliableWithUnpaid[0];
                const payRate = Math.round((topCompany.stats.paid / topCompany.stats.total) * 100);
                
                opportunities.push({
                    type: 'Reliable Payers',
                    icon: '‚≠ê',
                    count: reliableWithUnpaid.length,
                    value: totalValue,
                    description: `${reliableWithUnpaid.length} companies with strong payment history (${payRate}%+ rate) have unpaid cases`,
                    action: `Top target: ${topCompany.company} (${topCompany.stats.unpaid.length} unpaid, worth $${topCompany.unpaidValue.toFixed(2)})`,
                    color: '#f39c12'
                });
            }
            
            // 3. Quick wins - low value but easy to collect
            const quickWins = allData.filter(row => {
                if (row['_rowType'] !== 'paid' && row['_rowType'] !== 'requested' && 
                    row['_rowType'] !== 'disqualified' && row['_rowType'] !== 'dismissed') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    const violationDate = new Date(row['Violation Date']);
                    const daysOld = (new Date() - violationDate) / (1000 * 60 * 60 * 24);
                    return !isNaN(amount) && amount > 0 && amount < 300 && daysOld < 90;
                }
                return false;
            });
            
            if (quickWins.length > 0) {
                const totalValue = quickWins.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                
                opportunities.push({
                    type: 'Quick Wins',
                    icon: '‚ö°',
                    count: quickWins.length,
                    value: totalValue,
                    description: `${quickWins.length} recent, low-value cases under $300 - easy to collect`,
                    action: 'Batch process these for efficient collection',
                    color: '#3498db'
                });
            }
            
            // 4. Cases approaching statute of limitations
            const oldCases = allData.filter(row => {
                if (row['_rowType'] === 'paid' || row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                    return false;
                }
                const violationDate = new Date(row['Violation Date']);
                const daysOld = (new Date() - violationDate) / (1000 * 60 * 60 * 24);
                return !isNaN(violationDate.getTime()) && daysOld > 365 && daysOld < 730;
            });
            
            if (oldCases.length > 0) {
                const totalValue = oldCases.reduce((sum, row) => {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    return sum + (amount * 0.25);
                }, 0);
                
                opportunities.push({
                    type: 'Urgent - Aging Cases',
                    icon: '‚ö†Ô∏è',
                    count: oldCases.length,
                    value: totalValue,
                    description: `${oldCases.length} cases over 1 year old - act now before statute runs out`,
                    action: 'These need immediate attention!',
                    color: '#e74c3c'
                });
            }

            let html = '';
            
            if (opportunities.length === 0) {
                html = `<div style="text-align: center; padding: 40px; color: #666;">`;
                html += `<div style="font-size: 2em; margin-bottom: 10px;">üí∞</div>`;
                html += `<p>All major revenue opportunities have been captured!</p>`;
                html += `</div>`;
            } else {
                // Sort by value descending
                opportunities.sort((a, b) => b.value - a.value);
                
                html += '<div style="display: grid; gap: 15px;">';
                opportunities.forEach(opp => {
                    html += `<div style="background: white; border-left: 5px solid ${opp.color}; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">`;
                    html += `<div>`;
                    html += `<h4 style="color: #2c3e50; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">`;
                    html += `<span style="font-size: 1.5em;">${opp.icon}</span> ${opp.type}`;
                    html += `</h4>`;
                    html += `</div>`;
                    html += `<div style="background: ${opp.color}; color: white; padding: 10px 20px; border-radius: 6px; text-align: center;">`;
                    html += `<div style="font-size: 1.8em; font-weight: bold;">$${opp.value.toFixed(2)}</div>`;
                    html += `<div style="font-size: 0.8em; opacity: 0.9;">${opp.count} cases</div>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `<p style="color: #666; margin-bottom: 8px;">${opp.description}</p>`;
                    html += `<div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 0.9em; color: #2c3e50;">`;
                    html += `<strong>üí° Action:</strong> ${opp.action}`;
                    html += `</div>`;
                    html += `</div>`;
                });
                html += '</div>';
                
                // Add total
                const totalOpportunityValue = opportunities.reduce((sum, opp) => sum + opp.value, 0);
                html += `<div style="margin-top: 15px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; text-align: center;">`;
                html += `<div style="font-size: 1.2em; margin-bottom: 5px;">üéØ Total Revenue Opportunity</div>`;
                html += `<div style="font-size: 3em; font-weight: bold;">$${totalOpportunityValue.toFixed(2)}</div>`;
                html += `<div style="font-size: 0.9em; opacity: 0.9;">Act on these opportunities to maximize your revenue</div>`;
                html += `</div>`;
            }

            container.innerHTML = html;
        }

        function generateROIMetrics() {
            const container = document.getElementById('insight-roi');
            const allData = getFilteredInsightsData();

            // Count requested as effectively paid for revenue calculations
            const paidAndRequestedCases = allData.filter(row => row['_rowType'] === 'paid' || row['_rowType'] === 'requested');
            const totalRevenue = paidAndRequestedCases.reduce((sum, row) => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (row['_rowType'] === 'paid') {
                    return sum + (isNaN(amount) ? 0 : amount * 0.25);
                } else if (row['_rowType'] === 'requested') {
                    return sum + (isNaN(amount) ? 0 : amount * 0.25 * 0.25);
                }
                return sum;
            }, 0);

            const avgRevenuePerCase = paidAndRequestedCases.length > 0 ? totalRevenue / paidAndRequestedCases.length : 0;

            // Break down by case characteristics
            const withHearing = paidAndRequestedCases.filter(row => row['Hearing Result'] && row['Hearing Result'].trim() !== '');
            const withoutHearing = paidAndRequestedCases.filter(row => !row['Hearing Result'] || row['Hearing Result'].trim() === '');

            const hearingRevenue = withHearing.reduce((sum, row) => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                if (row['_rowType'] === 'paid') {
                    return sum + (amount * 0.25);
                } else if (row['_rowType'] === 'requested') {
                    return sum + (amount * 0.25 * 0.25);
                }
                return sum;
            }, 0);

            const noHearingRevenue = withoutHearing.reduce((sum, row) => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                return sum + (amount * 0.25);
            }, 0);

            const avgWithHearing = withHearing.length > 0 ? hearingRevenue / withHearing.length : 0;
            const avgWithoutHearing = withoutHearing.length > 0 ? noHearingRevenue / withoutHearing.length : 0;

            // By amount range
            const ranges = {
                'Under $500': { count: 0, revenue: 0 },
                '$500-$1000': { count: 0, revenue: 0 },
                'Over $1000': { count: 0, revenue: 0 }
            };

            paidAndRequestedCases.forEach(row => {
                const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                const yourCut = amount * 0.25;
                
                if (amount < 500) {
                    ranges['Under $500'].count++;
                    ranges['Under $500'].revenue += yourCut;
                } else if (amount < 1000) {
                    ranges['$500-$1000'].count++;
                    ranges['$500-$1000'].revenue += yourCut;
                } else {
                    ranges['Over $1000'].count++;
                    ranges['Over $1000'].revenue += yourCut;
                }
            });

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">';
            
            html += `<div style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9;">Total Revenue (Your Share)</div>';
            html += `<div style="font-size: 2em; font-weight: bold; margin: 10px 0;">$${totalRevenue.toFixed(2)}</div>`;
            html += `<div style="font-size: 0.85em;">${paidAndRequestedCases.length} paid/requested cases</div>`;
            html += '</div>';

            html += `<div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">`;
            html += '<div style="font-size: 0.9em; opacity: 0.9;">Avg Per Paid Case</div>';
            html += `<div style="font-size: 2em; font-weight: bold; margin: 10px 0;">$${avgRevenuePerCase.toFixed(2)}</div>`;
            html += '<div style="font-size: 0.85em;">per success</div>';
            html += '</div>';

            html += '</div>';

            // Comparison table
            html += '<h4 style="color: #667eea; margin: 20px 0 10px 0;">Revenue by Case Type</h4>';
            html += '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.9em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="padding: 10px; text-align: left;">Case Type</th>';
            html += '<th style="padding: 10px; text-align: center;">Count</th>';
            html += '<th style="padding: 10px; text-align: right;">Total Revenue</th>';
            html += '<th style="padding: 10px; text-align: right;">Avg Per Case</th>';
            html += '</tr></thead><tbody>';

            html += `<tr style="background: #f8f9fa;">`;
            html += `<td style="padding: 10px;">With Hearing</td>`;
            html += `<td style="padding: 10px; text-align: center;">${withHearing.length}</td>`;
            html += `<td style="padding: 10px; text-align: right; font-weight: bold;">$${hearingRevenue.toFixed(2)}</td>`;
            html += `<td style="padding: 10px; text-align: right; color: #27ae60;">$${avgWithHearing.toFixed(2)}</td>`;
            html += '</tr>';

            html += `<tr style="background: white;">`;
            html += `<td style="padding: 10px;">Without Hearing</td>`;
            html += `<td style="padding: 10px; text-align: center;">${withoutHearing.length}</td>`;
            html += `<td style="padding: 10px; text-align: right; font-weight: bold;">$${noHearingRevenue.toFixed(2)}</td>`;
            html += `<td style="padding: 10px; text-align: right; color: #27ae60;">$${avgWithoutHearing.toFixed(2)}</td>`;
            html += '</tr>';

            Object.entries(ranges).forEach(([range, data], i) => {
                const avg = data.count > 0 ? data.revenue / data.count : 0;
                html += `<tr style="background: ${i % 2 === 0 ? 'white' : '#f8f9fa'};">`;
                html += `<td style="padding: 10px;">${range}</td>`;
                html += `<td style="padding: 10px; text-align: center;">${data.count}</td>`;
                html += `<td style="padding: 10px; text-align: right; font-weight: bold;">$${data.revenue.toFixed(2)}</td>`;
                html += `<td style="padding: 10px; text-align: right; color: #27ae60;">$${avg.toFixed(2)}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';

            html += `<div style="margin-top: 15px; padding: 12px; background: #e8f4f8; border-radius: 6px;">`;
            html += `<strong>üí° Insight:</strong> ${avgWithHearing > avgWithoutHearing ? 'Cases with hearings generate more revenue on average' : 'Early settlements are more profitable'} - adjust your strategy accordingly.`;
            html += '</div>';
            
            html += '<div style="margin-top: 15px; padding: 12px; background: #f0f4ff; border-radius: 6px; border-left: 4px solid #667eea;">';
            html += '</div>';

            container.innerHTML = html;
        }

        // 11. Con Edison Deep Dive
        function generateConEdInsight() {
            const container = document.getElementById('insight-coned');
            const allData = getFilteredInsightsData();

            // Filter for all Con Ed related cases using normalization
            const conEdData = allData.filter(row => {
                const normalizedName = normalizeCompanyName(row['Company Name']);
                return normalizedName === 'CON EDISON';
            });

            if (conEdData.length === 0) {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 2em; margin-bottom: 10px;">‚ö°</div>
                    <p>No Con Edison data found in selected datasets.</p>
                </div>`;
                return;
            }

            // Calculate comprehensive Con Ed stats
            const stats = {
                total: conEdData.length,
                paid: conEdData.filter(r => r['_rowType'] === 'paid').length,
                requested: conEdData.filter(r => r['_rowType'] === 'requested').length,
                disqualified: conEdData.filter(r => r['_rowType'] === 'disqualified' || r['_rowType'] === 'dismissed').length,
                unpaid: conEdData.filter(r => !r['_rowType'] || r['_rowType'] === 'submitted').length,
                totalRevenue: 0,
                totalPending: 0,
                avgPaymentDays: [],
                boroughBreakdown: {},
                monthlyTrend: {},
                recentActivity: 0
            };

            // Calculate revenue and payment timing
            conEdData.forEach(row => {
                if (row['_rowType'] === 'paid') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) stats.totalRevenue += amount;

                    // Calculate payment days
                    const violationDate = new Date(row['Violation Date']);
                    const paymentDate = new Date(row['Payment Received'] || row['Hearing Date']);
                    if (!isNaN(violationDate.getTime()) && !isNaN(paymentDate.getTime())) {
                        const days = Math.floor((paymentDate - violationDate) / (1000 * 60 * 60 * 24));
                        if (days >= 0 && days < 1000) stats.avgPaymentDays.push(days);
                    }
                } else if (row['_rowType'] === 'requested') {
                    const amount = parseFloat((row['Paid Amount'] || '0').toString().replace(/[$,]/g, ''));
                    if (!isNaN(amount)) stats.totalPending += amount;
                }

                // Borough breakdown
                const borough = row['Violation Location (Borough)'] || 'Unknown';
                stats.boroughBreakdown[borough] = (stats.boroughBreakdown[borough] || 0) + 1;

                // Monthly trend
                const date = new Date(row['Violation Date']);
                if (!isNaN(date.getTime())) {
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    stats.monthlyTrend[monthKey] = (stats.monthlyTrend[monthKey] || 0) + 1;

                    // Recent activity (last 3 months)
                    const threeMonthsAgo = new Date();
                    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                    if (date > threeMonthsAgo) stats.recentActivity++;
                }
            });

            const avgDays = stats.avgPaymentDays.length > 0 
                ? Math.round(stats.avgPaymentDays.reduce((a, b) => a + b, 0) / stats.avgPaymentDays.length)
                : 0;
            const yourRevenue = stats.totalRevenue * 0.25;
            const yourPending = stats.totalPending * 0.25;
            const paymentRate = ((stats.paid / stats.total) * 100).toFixed(1);
            const disqualificationRate = ((stats.disqualified / stats.total) * 100).toFixed(1);

            // Build comprehensive HTML report
            let html = `<div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <div style="font-size: 2.5em; margin-bottom: 10px;">‚ö°</div>
                <h3 style="margin-bottom: 10px; font-size: 1.5em;">Con Edison Complete Analysis</h3>
                <p style="font-size: 1em; opacity: 0.95;">Your largest customer - all data consolidated</p>
            </div>`;

            // Key Metrics Grid
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px;">`;
            
            html += `<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.9em; opacity: 0.9;">Total Cases</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${stats.total.toLocaleString()}</div>
                <div style="font-size: 0.85em;">All time</div>
            </div>`;

            html += `<div style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.9em; opacity: 0.9;">Payment Rate</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${paymentRate}%</div>
                <div style="font-size: 0.85em;">${stats.paid} paid cases</div>
            </div>`;

            html += `<div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.9em; opacity: 0.9;">Your Revenue</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">$${yourRevenue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                <div style="font-size: 0.85em;">Total earned</div>
            </div>`;

            html += `<div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.9em; opacity: 0.9;">Pending</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">$${yourPending.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                <div style="font-size: 0.85em;">${stats.requested} requested</div>
            </div>`;

            if (avgDays > 0) {
                html += `<div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.9em; opacity: 0.9;">Avg Payment Time</div>
                    <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${avgDays}</div>
                    <div style="font-size: 0.85em;">days</div>
                </div>`;
            }

            html += `<div style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.9em; opacity: 0.9;">Disqualification Rate</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${disqualificationRate}%</div>
                <div style="font-size: 0.85em;">${stats.disqualified} dismissed</div>
            </div>`;

            html += `</div>`;

            // Recent Activity
            if (stats.recentActivity > 0) {
                html += `<div style="background: #e8f4f8; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db; margin-bottom: 20px;">
                    <strong>üìà Recent Activity:</strong> ${stats.recentActivity} new violations in the last 3 months
                </div>`;
            }

            // Borough Breakdown
            const sortedBoroughs = Object.entries(stats.boroughBreakdown).sort((a, b) => b[1] - a[1]);
            if (sortedBoroughs.length > 0) {
                html += `<div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #667eea;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">üó∫Ô∏è Violation Hot Spots</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">`;
                
                sortedBoroughs.forEach(([borough, count]) => {
                    const percentage = ((count / stats.total) * 100).toFixed(1);
                    html += `<div style="padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #f39c12;">
                        <div style="font-weight: bold; color: #2c3e50; margin-bottom: 4px;">${borough}</div>
                        <div style="font-size: 1.3em; font-weight: bold; color: #f39c12;">${count}</div>
                        <div style="font-size: 0.85em; color: #666;">${percentage}% of total</div>
                    </div>`;
                });
                
                html += `</div></div>`;
            }

            // Monthly Trend Chart
            const sortedMonths = Object.keys(stats.monthlyTrend).sort();
            if (sortedMonths.length > 0) {
                html += `<div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #667eea;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">üìä Violation Trend Over Time</h4>
                    <canvas id="coned-trend-chart"></canvas>
                </div>`;
            }

            // Performance Breakdown
            html += `<div style="background: white; padding: 20px; border-radius: 8px; border: 2px solid #667eea;">
                <h4 style="color: #667eea; margin-bottom: 15px;">üìã Case Status Breakdown</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                    <div style="padding: 15px; background: #d4edda; border-radius: 6px; border: 2px solid #27ae60;">
                        <div style="font-size: 0.85em; color: #155724; margin-bottom: 4px;">‚úÖ Paid</div>
                        <div style="font-size: 1.8em; font-weight: bold; color: #27ae60;">${stats.paid}</div>
                        <div style="font-size: 0.85em; color: #155724;">${paymentRate}% success</div>
                    </div>
                    <div style="padding: 15px; background: #fff3cd; border-radius: 6px; border: 2px solid #f39c12;">
                        <div style="font-size: 0.85em; color: #856404; margin-bottom: 4px;">‚è≥ Requested</div>
                        <div style="font-size: 1.8em; font-weight: bold; color: #f39c12;">${stats.requested}</div>
                        <div style="font-size: 0.85em; color: #856404;">In pipeline</div>
                    </div>
                    <div style="padding: 15px; background: #f8d7da; border-radius: 6px; border: 2px solid #e74c3c;">
                        <div style="font-size: 0.85em; color: #721c24; margin-bottom: 4px;">‚ùå Disqualified</div>
                        <div style="font-size: 1.8em; font-weight: bold; color: #e74c3c;">${stats.disqualified}</div>
                        <div style="font-size: 0.85em; color: #721c24;">${disqualificationRate}% loss rate</div>
                    </div>
                    <div style="padding: 15px; background: #e2e3e5; border-radius: 6px; border: 2px solid #6c757d;">
                        <div style="font-size: 0.85em; color: #383d41; margin-bottom: 4px;">‚ö™ Unpaid</div>
                        <div style="font-size: 1.8em; font-weight: bold; color: #6c757d;">${stats.unpaid}</div>
                        <div style="font-size: 0.85em; color: #383d41;">Not yet pursued</div>
                    </div>
                </div>
            </div>`;

            // Strategic Recommendation
            let recommendation = '';
            if (paymentRate >= 70) {
                recommendation = `üåü <strong>Excellent Partner:</strong> Con Edison is your most reliable customer with a ${paymentRate}% payment rate. Prioritize all Con Ed violations for maximum ROI.`;
            } else if (paymentRate >= 50) {
                recommendation = `‚úÖ <strong>Good Partnership:</strong> Con Edison pays ${paymentRate}% of the time. Continue pursuing but monitor for improvements.`;
            } else {
                recommendation = `‚ö†Ô∏è <strong>Needs Attention:</strong> Con Edison's ${paymentRate}% payment rate is below optimal. Review your approach and consider more aggressive follow-up.`;
            }

            html += `<div style="margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #27ae60;">
                ${recommendation}
            </div>`;

            container.innerHTML = html;

            // Draw trend chart if data exists
            if (sortedMonths.length > 0) {
                setTimeout(() => {
                    const ctx = document.getElementById('coned-trend-chart');
                    if (ctx) {
                        const monthLabels = sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            return new Date(year, parseInt(month) - 1).toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
                        });
                        
                        new Chart(ctx.getContext('2d'), {
                            type: 'line',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Con Edison Violations',
                                    data: sortedMonths.map(m => stats.monthlyTrend[m]),
                                    borderColor: '#f39c12',
                                    backgroundColor: 'rgba(243, 156, 18, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                plugins: {
                                    legend: { display: true }
                                },
                                scales: {
                                    y: { beginAtZero: true }
                                }
                            }
                        });
                    }
                }, 100);
            }
        }

        function generateDiscrepancies() {
            const mismatchesDiv = document.getElementById('discrepancies-mismatches');
            const paidNotFullDiv = document.getElementById('discrepancies-paid-not-full');
            const orphanedDiv = document.getElementById('discrepancies-orphaned');

            let mismatchesHTML = '';
            let paidNotFullHTML = '';
            let orphanedHTML = '';
            
            // Reset global mismatches data
            mismatchesData = {};

            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                const datasetName = tab.toUpperCase();
                const merged = appData[tab].merged;
                const paid = appData[tab].paid;

                // Report A: Payment Mismatches
                const mismatches = [];
                let totalExpected = 0;
                let totalReceived = 0;

                merged.forEach(row => {
                    const summonsNum = (row['Summons Number'] || '').trim();
                    const nycPaidAmount = parseFloat((row['Paid Amount'] || '').replace(/[$,]/g, ''));
                    
                    if (!isNaN(nycPaidAmount) && nycPaidAmount > 0 && summonsNum) {
                        let receivedAmount = 0;
                        let paymentDate = '';
                        
                        if (row['Paid To Me']) {
                            receivedAmount = parseFloat((row['Paid To Me'] || '').replace(/[$,]/g, ''));
                            paymentDate = row['Payment Received'] || '';
                        }
                        
                        if (isNaN(receivedAmount) || receivedAmount === 0) {
                            const paidRow = paid.find(p => {
                                const paidSummons = (p['Summons #'] || p['Summons Number'] || '').trim();
                                return paidSummons === summonsNum;
                            });

                            if (paidRow) {
                                const amountFields = ['Paid To Me', 'Amount', 'Payment Amount', 'Check Amount', 'Amount Received', 'Paid Amount', 'Amount Paid'];
                                
                                for (const field of amountFields) {
                                    if (paidRow[field]) {
                                        const testAmount = parseFloat((paidRow[field] || '').replace(/[$,]/g, ''));
                                        if (!isNaN(testAmount) && testAmount > 0) {
                                            receivedAmount = testAmount;
                                            break;
                                        }
                                    }
                                }
                                paymentDate = paidRow['Payment Received'] || paidRow['Date Received'] || '';
                            }
                        }

                        if (receivedAmount > 0) {
                            const expected = nycPaidAmount * 0.25;
                            const difference = receivedAmount - expected;

                            if (Math.abs(difference) > 0.50) {
                                const invoiceNum = 'BP' + summonsNum.substring(1);
                                
                                mismatches.push({
                                    summons: summonsNum,
                                    invoice: invoiceNum,
                                    company: row['Company Name'] || 'Unknown',
                                    nycPaid: nycPaidAmount,
                                    expected: expected,
                                    received: receivedAmount,
                                    difference: difference,
                                    paymentDate: paymentDate
                                });
                                totalExpected += expected;
                                totalReceived += receivedAmount;
                            }
                        }
                    }
                });

                // Store mismatches data for this dataset
                if (mismatches.length > 0) {
                    mismatchesData[datasetName] = {
                        mismatches: mismatches,
                        totalExpected: totalExpected,
                        totalReceived: totalReceived,
                        totalDifference: totalReceived - totalExpected
                    };
                }

                if (mismatches.length > 0) {
                    const totalDifference = totalReceived - totalExpected;
                    mismatchesHTML += `
                        <div style="margin-bottom: 25px;">
                            <h4 style="color: #1e3c72; margin-bottom: 12px; font-size: 1em;">${datasetName} - ${mismatches.length} Discrepancies</h4>
                            <div style="overflow-x: auto;">
                                <table class="discrepancy-table">
                                    <thead>
                                        <tr>
                                            <th>Summons #</th>
                                            <th>Invoice #</th>
                                            <th>Company</th>
                                            <th style="text-align: right;">NYC Paid</th>
                                            <th style="text-align: right;">Expected</th>
                                            <th style="text-align: right;">Received</th>
                                            <th>Date</th>
                                            <th style="text-align: right;">Diff</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${mismatches.map(m => `
                                            <tr>
                                                <td style="font-family: monospace;">${m.summons}</td>
                                                <td>${m.invoice}</td>
                                                <td>${m.company}</td>
                                                <td style="text-align: right;">$${m.nycPaid.toFixed(2)}</td>
                                                <td style="text-align: right;">$${m.expected.toFixed(2)}</td>
                                                <td style="text-align: right;">$${m.received.toFixed(2)}</td>
                                                <td>${m.paymentDate}</td>
                                                <td style="text-align: right;" class="${m.difference < 0 ? 'amount-negative' : 'amount-positive'}">
                                                    ${m.difference < 0 ? '-' : '+'}$${Math.abs(m.difference).toFixed(2)}
                                                </td>
                                            </tr>
                                        `).join('')}
                                        <tr style="background: #f0f0f0; font-weight: bold;">
                                            <td colspan="4">TOTALS</td>
                                            <td style="text-align: right;">$${totalExpected.toFixed(2)}</td>
                                            <td style="text-align: right;">$${totalReceived.toFixed(2)}</td>
                                            <td>-</td>
                                            <td style="text-align: right;" class="${totalDifference < 0 ? 'amount-negative' : 'amount-positive'}">
                                                ${totalDifference < 0 ? '-' : '+'}$${Math.abs(totalDifference).toFixed(2)}
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                // NEW REPORT: Paid But Not "Paid in Full"
                const paidNotFull = [];
                
                // Create sets of summons numbers that are in Paid or Requested datasets
                const paidSummonsSet = new Set();
                paid.forEach(row => {
                    const summonsNum = (row['Summons #'] || row['Summons Number'] || '').trim();
                    if (summonsNum) paidSummonsSet.add(summonsNum);
                });
                
                const requestedSummonsSet = new Set();
                appData[tab].requests.forEach(row => {
                    const summonsNum = (row['Complaint Number'] || row['Summons Number'] || '').trim();
                    if (summonsNum) requestedSummonsSet.add(summonsNum);
                });
                
                merged.forEach(row => {
                    const paidAmount = parseFloat((row['Paid Amount'] || '').replace(/[$,]/g, ''));
                    const hearingStatus = (row['Hearing Status'] || '').toLowerCase();
                    const summonsNum = (row['Summons Number'] || '').trim();
                    
                    // Only include if: has paid amount, not "paid in full", and NOT in Paid or Requested datasets
                    if (!isNaN(paidAmount) && paidAmount > 0 && 
                        hearingStatus !== 'paid in full' && 
                        summonsNum &&
                        !paidSummonsSet.has(summonsNum) &&
                        !requestedSummonsSet.has(summonsNum)) {
                        const invoiceNum = 'BP' + summonsNum.substring(1);
                        paidNotFull.push({
                            invoice: invoiceNum,
                            company: row['Company Name'] || 'Unknown',
                            paidAmount: paidAmount,
                            hearingStatus: row['Hearing Status'] || 'Unknown',
                            violationDate: row['Violation Date'] || ''
                        });
                    }
                });

                if (paidNotFull.length > 0) {
                    const totalPaidNotFull = paidNotFull.reduce((sum, item) => sum + item.paidAmount, 0);
                    paidNotFullHTML += `
                        <div style="margin-bottom: 25px;">
                            <h4 style="color: #1e3c72; margin-bottom: 12px; font-size: 1em;">${datasetName} - ${paidNotFull.length} Cases</h4>
                            <div style="overflow-x: auto;">
                                <table class="discrepancy-table">
                                    <thead>
                                        <tr>
                                            <th>Invoice #</th>
                                            <th>Company</th>
                                            <th style="text-align: right;">Paid Amount</th>
                                            <th>Hearing Status</th>
                                            <th>Violation Date</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${paidNotFull.map(p => `
                                            <tr>
                                                <td>${p.invoice}</td>
                                                <td>${p.company}</td>
                                                <td style="text-align: right; color: #f39c12; font-weight: bold;">$${p.paidAmount.toFixed(2)}</td>
                                                <td>${p.hearingStatus}</td>
                                                <td>${p.violationDate}</td>
                                            </tr>
                                        `).join('')}
                                        <tr style="background: #f0f0f0; font-weight: bold;">
                                            <td colspan="2">TOTAL</td>
                                            <td style="text-align: right; color: #f39c12;">$${totalPaidNotFull.toFixed(2)}</td>
                                            <td colspan="2">-</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                // Report C: Orphaned Payments
                const orphaned = [];
                const masterSummons = new Set(merged.map(row => (row['Summons Number'] || '').trim()));

                paid.forEach(paidRow => {
                    const summonsNum = (paidRow['Summons #'] || paidRow['Summons Number'] || '').trim();
                    if (summonsNum && !masterSummons.has(summonsNum)) {
                        const amountFields = ['Paid To Me', 'Amount', 'Payment Amount', 'Check Amount', 'Amount Received', 'Paid Amount', 'Amount Paid'];
                        let amount = 0;
                        
                        for (const field of amountFields) {
                            if (paidRow[field]) {
                                amount = parseFloat((paidRow[field] || '').replace(/[$,]/g, ''));
                                if (!isNaN(amount) && amount > 0) break;
                            }
                        }

                        const invoiceNum = 'BP' + summonsNum.substring(1);
                        const paymentDate = paidRow['Payment Received'] || paidRow['Date Received'] || '';

                        orphaned.push({
                            summons: summonsNum,
                            invoice: invoiceNum,
                            amount: amount,
                            paymentDate: paymentDate
                        });
                    }
                });

                if (orphaned.length > 0) {
                    orphanedHTML += `
                        <div style="margin-bottom: 25px;">
                            <h4 style="color: #1e3c72; margin-bottom: 12px; font-size: 1em;">${datasetName} - ${orphaned.length} Orphaned</h4>
                            <div style="overflow-x: auto;">
                                <table class="discrepancy-table">
                                    <thead>
                                        <tr>
                                            <th>Invoice #</th>
                                            <th style="text-align: right;">Amount</th>
                                            <th>Date</th>
                                            <th>Note</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${orphaned.map(o => `
                                            <tr>
                                                <td>${o.invoice}</td>
                                                <td style="text-align: right;">$${o.amount.toFixed(2)}</td>
                                                <td>${o.paymentDate}</td>
                                                <td style="font-style: italic; color: #666;">Not in master</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            });

            mismatchesDiv.innerHTML = mismatchesHTML || '<p style="color: #27ae60; font-weight: bold;">‚úÖ No payment mismatches found!</p>';
            paidNotFullDiv.innerHTML = paidNotFullHTML || '<p style="color: #27ae60; font-weight: bold;">‚úÖ All paid amounts match "Paid in Full" status!</p>';
            orphanedDiv.innerHTML = orphanedHTML || '<p style="color: #27ae60; font-weight: bold;">‚úÖ No orphaned payments found!</p>';
        }

        function setChartType(type) {
            currentChartType = type;
            document.querySelectorAll('.chart-type-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function getChartColors(count, scheme) {
            const schemes = {
                'default': (i, total) => `hsl(${(i * 360 / total)}, 70%, 60%)`,
                'blue': (i, total) => `hsl(210, ${70 - (i * 40 / total)}%, ${60 - (i * 30 / total)}%)`,
                'green': (i, total) => `hsl(120, ${70 - (i * 40 / total)}%, ${50 - (i * 30 / total)}%)`,
                'red': (i, total) => `hsl(0, ${70 - (i * 40 / total)}%, ${60 - (i * 30 / total)}%)`,
                'purple': (i, total) => `hsl(280, ${70 - (i * 40 / total)}%, ${60 - (i * 30 / total)}%)`,
                'status': (i, total, label) => {
                    const statusColors = {
                        'PAID TO ME': '#27ae60',
                        'REQUESTED': '#f39c12',
                        'Paid': '#27ae60',
                        'Requested': '#f39c12',
                        'Disqualified': '#e74c3c',
                        'Submitted': '#9b59b6',
                        'Unpaid': '#95a5a6'
                    };
                    return statusColors[label] || `hsl(${(i * 360 / total)}, 70%, 60%)`;
                }
            };
            return schemes[scheme] || schemes['default'];
        }

        function filterDataByDateRange(data, dateRange) {
            if (dateRange === 'all') return data;
            
            const now = new Date();
            const getDateThreshold = () => {
                switch(dateRange) {
                    case 'ytd':
                        return new Date(now.getFullYear(), 0, 1);
                    case 'last-12':
                        return new Date(now.setMonth(now.getMonth() - 12));
                    case 'last-6':
                        return new Date(now.setMonth(now.getMonth() - 6));
                    case 'last-3':
                        return new Date(now.setMonth(now.getMonth() - 3));
                    case 'this-year':
                        return new Date(now.getFullYear(), 0, 1);
                    case 'last-year':
                        return [new Date(now.getFullYear() - 1, 0, 1), new Date(now.getFullYear() - 1, 11, 31)];
                    default:
                        return null;
                }
            };
            
            const threshold = getDateThreshold();
            if (!threshold) return data;
            
            return data.filter(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (!dateStr) return false;
                const rowDate = new Date(dateStr);
                if (Array.isArray(threshold)) {
                    return rowDate >= threshold[0] && rowDate <= threshold[1];
                }
                return rowDate >= threshold;
            });
        }

        function groupByMonth(data) {
            const monthCounts = {};
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const date = new Date(dateStr);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    monthCounts[monthKey] = (monthCounts[monthKey] || 0) + 1;
                }
            });
            return monthCounts;
        }

        function groupByYear(data) {
            const yearCounts = {};
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const date = new Date(dateStr);
                    const year = date.getFullYear();
                    yearCounts[year] = (yearCounts[year] || 0) + 1;
                }
            });
            return yearCounts;
        }

        function calculateMeasure(data, measure, field) {
            if (measure === 'count') {
                const counts = {};
                data.forEach(row => {
                    const value = row[field] || 'Unknown';
                    counts[value] = (counts[value] || 0) + 1;
                });
                return counts;
            } else if (measure === 'sum-paid') {
                const sums = {};
                data.forEach(row => {
                    const value = row[field] || 'Unknown';
                    const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    sums[value] = (sums[value] || 0) + (isNaN(amount) ? 0 : amount);
                });
                return sums;
            } else if (measure === 'avg-paid') {
                const sums = {};
                const counts = {};
                data.forEach(row => {
                    const value = row[field] || 'Unknown';
                    const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    if (!isNaN(amount) && amount > 0) {
                        sums[value] = (sums[value] || 0) + amount;
                        counts[value] = (counts[value] || 0) + 1;
                    }
                });
                const avgs = {};
                Object.keys(sums).forEach(key => {
                    avgs[key] = sums[key] / (counts[key] || 1);
                });
                return avgs;
            } else if (measure === 'sum-balance') {
                const sums = {};
                data.forEach(row => {
                    const value = row[field] || 'Unknown';
                    const amount = parseFloat((row['Balance Due'] || '0').replace(/[$,]/g, ''));
                    sums[value] = (sums[value] || 0) + (isNaN(amount) ? 0 : amount);
                });
                return sums;
            }
            return {};
        }

        function updateGlobalChart() {
            const tabSelector = document.getElementById('chart-tab-selector').value;
            const fieldSelector = document.getElementById('chart-field-selector').value;
            const measure = document.getElementById('chart-measure').value;
            const sortBy = document.getElementById('chart-sort').value;
            const maxItems = document.getElementById('chart-max-items').value;
            const statusFilter = document.getElementById('chart-status-filter').value;
            const dateRange = document.getElementById('chart-date-range').value;
            const colorScheme = document.getElementById('chart-color-scheme').value;

            let data = [];
            if (tabSelector === 'all') {
                ['at', 'at-nyc', 'mbt'].forEach(tab => data.push(...appData[tab].merged));
            } else {
                data = appData[tabSelector].merged;
            }

            if (data.length === 0) {
                alert('No data available. Please load data first.');
                return;
            }

            // Apply status filter
            if (statusFilter) {
                data = data.filter(row => {
                    if (statusFilter === 'paid') return row['_rowType'] === 'paid';
                    if (statusFilter === 'requested') return row['_rowType'] === 'requested';
                    if (statusFilter === 'disqualified') return row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed';
                    if (statusFilter === 'unpaid') return !row['Payment Status'] || row['Payment Status'] === '';
                    return true;
                });
            }

            // Apply date range filter
            data = filterDataByDateRange(data, dateRange);

            let chartData;
            if (fieldSelector === 'month') {
                chartData = groupByMonth(data);
            } else if (fieldSelector === 'year') {
                chartData = groupByYear(data);
            } else {
                chartData = calculateMeasure(data, measure, fieldSelector);
            }

            let entries = Object.entries(chartData);

            // Sort
            if (sortBy === 'value-desc') {
                entries.sort((a, b) => b[1] - a[1]);
            } else if (sortBy === 'value-asc') {
                entries.sort((a, b) => a[1] - b[1]);
            } else if (sortBy === 'label-asc') {
                entries.sort((a, b) => a[0].localeCompare(b[0]));
            } else if (sortBy === 'label-desc') {
                entries.sort((a, b) => b[0].localeCompare(a[0]));
            }

            // Limit items
            if (maxItems !== 'all') {
                entries = entries.slice(0, parseInt(maxItems));
            }

            if (entries.length === 0) {
                alert('No data matches the selected filters.');
                return;
            }

            const labels = entries.map(e => e[0]);
            const values = entries.map(e => e[1]);

            const colorFunc = getChartColors(labels.length, colorScheme);
            const colors = labels.map((label, i) => colorFunc(i, labels.length, label));

            const ctx = document.getElementById('global-chart').getContext('2d');

            if (globalChart) globalChart.destroy();

            const chartType = currentChartType === 'horizontalBar' ? 'bar' : currentChartType;
            const isHorizontal = currentChartType === 'horizontalBar';

            globalChart = new Chart(ctx, {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: getMeasureLabel(measure),
                        data: values,
                        backgroundColor: colors,
                        borderColor: '#fff',
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: isHorizontal ? 'y' : 'x',
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: chartType === 'line' || isHorizontal ? 'top' : 'right',
                            labels: { font: { size: 10 }, padding: 8 }
                        },
                        title: {
                            display: true,
                            text: getChartTitle(fieldSelector, measure),
                            font: { size: 14, weight: 'bold' },
                            color: '#1e3c72'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (measure.includes('sum') || measure.includes('avg')) {
                                        label += '$' + context.parsed.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                                    } else {
                                        label += context.parsed.toLocaleString();
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: chartType === 'bar' || chartType === 'line' ? {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    if (measure.includes('sum') || measure.includes('avg')) {
                                        return '$' + value.toLocaleString();
                                    }
                                    return value.toLocaleString();
                                }
                            }
                        }
                    } : {}
                }
            });

            // Update title
            document.getElementById('chart-title').textContent = getChartTitle(fieldSelector, measure);

            // Show stats
            displayChartStats(values, measure, labels.length, data.length);

            // Show data table
            displayChartDataTable(labels, values, measure);
        }

        function getMeasureLabel(measure) {
            const labels = {
                'count': 'Count',
                'sum-paid': 'Total Paid Amount',
                'avg-paid': 'Average Paid Amount',
                'sum-balance': 'Total Balance Due'
            };
            return labels[measure] || 'Value';
        }

        function getChartTitle(field, measure) {
            const measureName = getMeasureLabel(measure);
            return `${measureName} by ${field}`;
        }

        function displayChartStats(values, measure, categoryCount, totalRecords) {
            const total = values.reduce((a, b) => a + b, 0);
            const avg = total / values.length;
            const max = Math.max(...values);
            const min = Math.min(...values);

            const statsDiv = document.getElementById('chart-stats');
            statsDiv.style.display = 'block';
            
            const isMonetary = measure.includes('sum') || measure.includes('avg');
            const formatValue = (val) => {
                if (isMonetary) {
                    return '$' + val.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                }
                return val.toLocaleString();
            };

            statsDiv.innerHTML = `
                <h4 style="color: #1e3c72; margin-bottom: 12px; font-size: 1em;">üìà Statistics</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                    <div style="padding: 10px; background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%); border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">TOTAL</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${formatValue(total)}</div>
                    </div>
                    <div style="padding: 10px; background: #3498db; border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">AVERAGE</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${formatValue(avg)}</div>
                    </div>
                    <div style="padding: 10px; background: #27ae60; border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">HIGHEST</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${formatValue(max)}</div>
                    </div>
                    <div style="padding: 10px; background: #e74c3c; border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">LOWEST</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${formatValue(min)}</div>
                    </div>
                    <div style="padding: 10px; background: #9b59b6; border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">CATEGORIES</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${categoryCount}</div>
                    </div>
                    <div style="padding: 10px; background: #34495e; border-radius: 6px; text-align: center;">
                        <div style="color: white; font-size: 0.7em; opacity: 0.9;">RECORDS</div>
                        <div style="color: white; font-size: 1.2em; font-weight: bold;">${totalRecords.toLocaleString()}</div>
                    </div>
                </div>
            `;
        }

        function displayChartDataTable(labels, values, measure) {
            const tableDiv = document.getElementById('chart-data-table');
            tableDiv.style.display = 'block';

            const thead = document.getElementById('chart-table-head');
            const tbody = document.getElementById('chart-table-body');

            const isMonetary = measure.includes('sum') || measure.includes('avg');
            const formatValue = (val) => {
                if (isMonetary) {
                    return '$' + val.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                }
                return val.toLocaleString();
            };

            thead.innerHTML = `
                <tr style="background: #1e3c72; color: white;">
                    <th style="padding: 8px; text-align: left;">Category</th>
                    <th style="padding: 8px; text-align: right;">${getMeasureLabel(measure)}</th>
                    <th style="padding: 8px; text-align: right;">Percentage</th>
                </tr>
            `;

            const total = values.reduce((a, b) => a + b, 0);
            tbody.innerHTML = labels.map((label, i) => {
                const percentage = ((values[i] / total) * 100).toFixed(1);
                return `
                    <tr style="border-bottom: 1px solid #ddd;">
                        <td style="padding: 6px;">${label}</td>
                        <td style="padding: 6px; text-align: right; font-weight: bold;">${formatValue(values[i])}</td>
                        <td style="padding: 6px; text-align: right;">${percentage}%</td>
                    </tr>
                `;
            }).join('') + `
                <tr style="background: #f0f0f0; font-weight: bold;">
                    <td style="padding: 6px;">TOTAL</td>
                    <td style="padding: 6px; text-align: right;">${formatValue(total)}</td>
                    <td style="padding: 6px; text-align: right;">100%</td>
                </tr>
            `;
        }

        // Quick Insight Functions
        function showPaymentStatusChart() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'count';
            document.getElementById('chart-field-selector').value = 'Payment Status';
            document.getElementById('chart-status-filter').value = '';
            document.getElementById('chart-date-range').value = 'all';
            document.getElementById('chart-color-scheme').value = 'status';
            setChartTypeByName('pie');
            updateGlobalChart();
        }

        function showCompanyChart() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'count';
            document.getElementById('chart-field-selector').value = 'Company Name';
            document.getElementById('chart-status-filter').value = '';
            document.getElementById('chart-date-range').value = 'all';
            document.getElementById('chart-max-items').value = '10';
            document.getElementById('chart-color-scheme').value = 'default';
            setChartTypeByName('horizontalBar');
            updateGlobalChart();
        }

        function showBoroughChart() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'count';
            document.getElementById('chart-field-selector').value = 'Violation Location (Borough)';
            document.getElementById('chart-status-filter').value = '';
            document.getElementById('chart-date-range').value = 'all';
            document.getElementById('chart-color-scheme').value = 'blue';
            setChartTypeByName('bar');
            updateGlobalChart();
        }

        function showMonthlyTrend() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'count';
            document.getElementById('chart-field-selector').value = 'month';
            document.getElementById('chart-status-filter').value = '';
            document.getElementById('chart-date-range').value = 'last-12';
            document.getElementById('chart-sort').value = 'label-asc';
            document.getElementById('chart-max-items').value = 'all';
            document.getElementById('chart-color-scheme').value = 'blue';
            setChartTypeByName('line');
            updateGlobalChart();
        }

        function showHearingResults() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'count';
            document.getElementById('chart-field-selector').value = 'Hearing Result';
            document.getElementById('chart-status-filter').value = '';
            document.getElementById('chart-date-range').value = 'all';
            document.getElementById('chart-color-scheme').value = 'purple';
            setChartTypeByName('doughnut');
            updateGlobalChart();
        }

        function showRevenueAnalysis() {
            document.getElementById('chart-tab-selector').value = 'all';
            document.getElementById('chart-measure').value = 'sum-paid';
            document.getElementById('chart-field-selector').value = 'Company Name';
            document.getElementById('chart-status-filter').value = 'paid';
            document.getElementById('chart-date-range').value = 'all';
            document.getElementById('chart-max-items').value = '10';
            document.getElementById('chart-color-scheme').value = 'green';
            setChartTypeByName('bar');
            updateGlobalChart();
        }

        function setChartTypeByName(type) {
            currentChartType = type;
            document.querySelectorAll('.chart-type-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                if (btn.textContent.toLowerCase().includes(type.toLowerCase().replace('horizontalbar', 'h-bar'))) {
                    btn.classList.add('active');
                }
            });
        }

        function exportChartImage() {
            if (!globalChart) {
                alert('Please generate a chart first.');
                return;
            }
            const canvas = document.getElementById('global-chart');
            const link = document.createElement('a');
            link.download = 'chart-' + new Date().getTime() + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function exportChartDataCSV() {
            const thead = document.getElementById('chart-table-head');
            const tbody = document.getElementById('chart-table-body');
            
            if (!thead || !tbody || tbody.children.length === 0) {
                alert('Please generate a chart first.');
                return;
            }

            let csv = 'Category,Value,Percentage\n';
            Array.from(tbody.children).forEach(row => {
                const cells = Array.from(row.children);
                csv += cells.map(cell => '"' + cell.textContent.trim() + '"').join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'chart-data-' + new Date().getTime() + '.csv';
            link.href = url;
            link.click();
            window.URL.revokeObjectURL(url);
        }

        // ===== PROPERLY PAID REPORT FUNCTIONS =====
        
        function generateProperlyPaidReport() {
            const properlyPaid = [];
            
            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                appData[tab].merged.forEach(row => {
                    if (row['_rowType'] === 'paid') {
                        const nycPaid = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                        const expected = nycPaid * 0.25;
                        
                        // Find corresponding payment
                        const payment = appData[tab].paid.find(p => 
                            p['Summons Number'] === row['Summons Number']
                        );
                        
                        if (payment) {
                            const received = parseFloat((payment['Paid To Me'] || '0').replace(/[$,]/g, ''));
                            const difference = Math.abs(received - expected);
                            
                            // Consider it "properly paid" if difference is less than $0.50
                            if (difference < 0.50) {
                                properlyPaid.push({
                                    summons: row['Summons Number'],
                                    invoice: payment['Invoice Number'] || 'N/A',
                                    company: row['Company Name'] || 'Unknown',
                                    nycPaid: nycPaid,
                                    expected: expected,
                                    received: received,
                                    date: payment['Date Paid'] || 'N/A',
                                    dataset: tab.toUpperCase()
                                });
                            }
                        }
                    }
                });
            });
            
            const container = document.getElementById('properly-paid-section');
            
            if (properlyPaid.length === 0) {
                container.innerHTML = '<p style="color: #666;">No properly paid summonses found.</p>';
                document.getElementById('export-properly-paid-btn').style.display = 'none';
                return;
            }
            
            const totalReceived = properlyPaid.reduce((sum, p) => sum + p.received, 0);
            
            let html = '<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #28a745;">';
            html += '<h4 style="color: #155724; margin: 0 0 10px 0;">‚úÖ ' + properlyPaid.length + ' Properly Paid Summonses</h4>';
            html += '<p style="color: #155724; margin: 0;"><strong>Total Received:</strong> $' + totalReceived.toFixed(2) + '</p>';
            html += '</div>';
            
            html += '<div style="overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; font-size: 0.85em;"><thead><tr style="background: #28a745; color: white;">';
            html += '<th style="padding: 10px; text-align: left;">Summons #</th>';
            html += '<th style="padding: 10px; text-align: left;">Invoice #</th>';
            html += '<th style="padding: 10px; text-align: left;">Company</th>';
            html += '<th style="padding: 10px; text-align: right;">NYC Paid</th>';
            html += '<th style="padding: 10px; text-align: right;">Expected (25%)</th>';
            html += '<th style="padding: 10px; text-align: right;">Received</th>';
            html += '<th style="padding: 10px; text-align: left;">Date</th>';
            html += '<th style="padding: 10px; text-align: left;">Dataset</th>';
            html += '</tr></thead><tbody>';
            
            properlyPaid.forEach(p => {
                html += '<tr style="border-bottom: 1px solid #dee2e6;">';
                html += '<td style="padding: 10px;">' + p.summons + '</td>';
                html += '<td style="padding: 10px;">' + p.invoice + '</td>';
                html += '<td style="padding: 10px;">' + p.company + '</td>';
                html += '<td style="padding: 10px; text-align: right;">$' + p.nycPaid.toFixed(2) + '</td>';
                html += '<td style="padding: 10px; text-align: right;">$' + p.expected.toFixed(2) + '</td>';
                html += '<td style="padding: 10px; text-align: right; color: #28a745; font-weight: bold;">$' + p.received.toFixed(2) + '</td>';
                html += '<td style="padding: 10px;">' + p.date + '</td>';
                html += '<td style="padding: 10px;">' + p.dataset + '</td>';
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            container.innerHTML = html;
            document.getElementById('export-properly-paid-btn').style.display = 'inline-block';
            
            // Store for PDF export
            window.properlyPaidData = properlyPaid;
        }
        
        function exportProperlyPaidPDF() {
            if (!window.properlyPaidData || window.properlyPaidData.length === 0) {
                alert('Please generate the report first.');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            doc.setFontSize(16);
            doc.text('Properly Paid Summonses Report', 14, 15);
            
            doc.setFontSize(10);
            doc.text('Generated: ' + new Date().toLocaleDateString(), 14, 22);
            
            const totalReceived = window.properlyPaidData.reduce((sum, p) => sum + p.received, 0);
            doc.text('Total Count: ' + window.properlyPaidData.length + ' summonses', 14, 28);
            doc.text('Total Received: $' + totalReceived.toFixed(2), 14, 34);
            
            const tableData = window.properlyPaidData.map(p => [
                p.summons,
                p.invoice,
                p.company,
                '$' + p.nycPaid.toFixed(2),
                '$' + p.expected.toFixed(2),
                '$' + p.received.toFixed(2),
                p.date,
                p.dataset
            ]);
            
            doc.autoTable({
                startY: 40,
                head: [['Summons #', 'Invoice #', 'Company', 'NYC Paid', 'Expected', 'Received', 'Date', 'Dataset']],
                body: tableData,
                theme: 'striped',
                headStyles: {
                    fillColor: [40, 167, 69],
                    textColor: [255, 255, 255],
                    fontStyle: 'bold',
                    fontSize: 8
                },
                bodyStyles: {
                    fontSize: 7,
                    cellPadding: 2
                },
                columnStyles: {
                    0: { cellWidth: 22 },
                    1: { cellWidth: 20 },
                    2: { cellWidth: 35 },
                    3: { cellWidth: 20, halign: 'right' },
                    4: { cellWidth: 20, halign: 'right' },
                    5: { cellWidth: 20, halign: 'right' },
                    6: { cellWidth: 20 },
                    7: { cellWidth: 15 }
                }
            });
            
            doc.save('properly-paid-summonses.pdf');
        }

        // ===== DISTANCE TAB FUNCTIONS =====
        
        let currentDistanceYear = 2024;
        let currentDistanceMonth = new Date().getMonth();
        
        function generateDistanceCalendar() {
            console.log('Generating distance calendar...');
            
            // Check if data is loaded
            if (!appData || !appData['at'] || !appData['at'].merged) {
                console.log('No data loaded yet, skipping generateDistanceCalendar');
                return;
            }
            
            const dataset = document.getElementById('distance-dataset').value;
            const year = parseInt(document.getElementById('distance-year').value);
            const month = parseInt(document.getElementById('distance-month').value);
            
            console.log('Dataset:', dataset, 'Year:', year, 'Month:', month);
            
            currentDistanceYear = year;
            currentDistanceMonth = month;
            
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            
            console.log('Grouped data keys:', Object.keys(grouped).length);
            console.log('Walking data cache keys:', Object.keys(walkingDataCache).length);
            
            // Calculate stats - ONLY WORK MILES
            const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
            let monthTotal = 0;
            let workDaysCount = 0;
            let bestDayMiles = 0;
            let bestDayDate = '';
            
            Object.keys(grouped).forEach(dateKey => {
                if (dateKey.startsWith(monthKey)) {
                    const dayData = grouped[dateKey];
                    if (dayData.count > 0) {
                        workDaysCount++;
                        
                        // Get work segments for this day
                        const times = dayData.summonses.map(s => {
                            const time = s['Violation Time'];
                            if (!time) return 0;
                            const [hours, minutes] = time.split(':').map(Number);
                            return hours * 60 + minutes;
                        }).filter(t => t > 0).sort((a, b) => a - b);
                        
                        const workSegments = calculateWorkSegments(times);
                        const workDistance = getWalkingDistanceForWorkHours(dateKey, workSegments);
                        
                        monthTotal += workDistance;
                        
                        if (workDistance > bestDayMiles) {
                            bestDayMiles = workDistance;
                            bestDayDate = dateKey;
                        }
                    }
                }
            });
            
            console.log('Month total (work hours only):', monthTotal, 'Work days:', workDaysCount);
            
            const avgWorkDay = workDaysCount > 0 ? monthTotal / workDaysCount : 0;
            
            // Update stats cards
            document.getElementById('distance-month-total').textContent = monthTotal.toFixed(2);
            document.getElementById('distance-avg-workday').textContent = avgWorkDay.toFixed(2);
            document.getElementById('distance-work-split').textContent = workDaysCount; // Show shift count
            document.getElementById('distance-best-day').textContent = bestDayMiles > 0 ? bestDayMiles.toFixed(2) : '--';
            
            // Generate calendar
            generateDistanceCalendarGrid(year, month, grouped);
            
            // Generate insights
            generateDistanceInsights(monthTotal, avgWorkDay, bestDayDate, bestDayMiles, workDaysCount);
        }
        
        function calculateWorkSegments(times) {
            if (times.length === 0) return [];
            
            const segments = [];
            let currentSegment = { start: times[0] - 30, end: times[0] + 30 };
            
            for (let i = 1; i < times.length; i++) {
                const gap = times[i] - times[i - 1];
                if (gap >= 150) { // 2.5 hour break
                    currentSegment.end = times[i - 1] + 30;
                    segments.push(currentSegment);
                    currentSegment = { start: times[i] - 30, end: times[i] + 30 };
                } else {
                    currentSegment.end = times[i] + 30;
                }
            }
            
            segments.push(currentSegment);
            return segments;
        }
        
        function generateDistanceCalendarGrid(year, month, grouped) {
            const container = document.getElementById('distance-calendar');
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            
            let html = '<div style="text-align: center; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; color: #2c3e50;">';
            html += monthNames[month] + ' ' + year + '</div>';
            
            html += '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;">';
            
            // Day headers
            ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
                html += '<div style="text-align: center; font-weight: bold; padding: 8px; color: #666; font-size: 0.85em;">' + day + '</div>';
            });
            
            // Empty cells for days before month starts
            for (let i = 0; i < firstDay; i++) {
                html += '<div style="padding: 10px; background: #f5f5f5; border-radius: 6px;"></div>';
            }
            
            // Days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayData = grouped[dateKey];
                
                let workMiles = 0;
                let hasSummons = false;
                
                if (dayData && dayData.count > 0) {
                    hasSummons = true;
                    
                    // Calculate work segments based on summons times
                    const times = dayData.summonses.map(s => {
                        const time = s['Violation Time'];
                        if (!time) return 0;
                        const [hours, minutes] = time.split(':').map(Number);
                        return hours * 60 + minutes;
                    }).filter(t => t > 0).sort((a, b) => a - b);
                    
                    if (times.length > 0) {
                        const workSegments = calculateWorkSegments(times);
                        workMiles = getWalkingDistanceForWorkHours(dateKey, workSegments);
                    }
                }
                
                // Color intensity based on work miles
                let bgColor = '#f9f9f9';
                let textColor = '#999';
                if (workMiles > 0) {
                    const intensity = Math.min(workMiles / 10, 1); // Max at 10 miles
                    const green = Math.floor(152 + (61 - 152) * intensity);
                    const blue = Math.floor(142 + (125 - 142) * intensity);
                    bgColor = `rgb(17, ${green}, ${blue})`;
                    textColor = 'white';
                } else if (hasSummons) {
                    bgColor = '#e8e8e8';
                    textColor = '#666';
                }
                
                const cursor = hasSummons ? 'pointer' : 'default';
                const onclick = hasSummons ? `onclick="showDistanceDayDetail('${dateKey}')"` : '';
                
                html += `<div style="padding: 10px; background: ${bgColor}; color: ${textColor}; border-radius: 6px; text-align: center; cursor: ${cursor}; transition: all 0.2s;" ${onclick}>`;
                html += `<div style="font-weight: bold; margin-bottom: 5px;">${day}</div>`;
                if (workMiles > 0) {
                    html += `<div style="font-size: 0.8em;">${workMiles.toFixed(1)} mi</div>`;
                } else if (hasSummons) {
                    html += `<div style="font-size: 0.7em; opacity: 0.7;">No data</div>`;
                }
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function showDistanceDayDetail(dateKey) {
            console.log('Opening day detail for:', dateKey);
            
            const dataset = document.getElementById('distance-dataset').value;
            const data = getTimeAnalysisData(dataset);
            const grouped = groupDataByDate(data);
            const dayData = grouped[dateKey];
            
            console.log('Day data found:', dayData ? 'yes' : 'no');
            
            if (!dayData || dayData.count === 0) {
                console.log('No summons for this day');
                return;
            }
            
            const modal = document.getElementById('distance-day-detail');
            const content = document.getElementById('distance-day-detail-content');
            
            if (!modal) {
                console.error('Modal element #distance-day-detail not found!');
                return;
            }
            if (!content) {
                console.error('Content element #distance-day-detail-content not found!');
                return;
            }
            
            // Get work segments
            const times = dayData.summonses.map(s => {
                const time = s['Violation Time'];
                if (!time) return 0;
                const [hours, minutes] = time.split(':').map(Number);
                return hours * 60 + minutes;
            }).filter(t => t > 0).sort((a, b) => a - b);
            
            console.log('Times:', times);
            
            const workSegments = calculateWorkSegments(times);
            const workDistance = getWalkingDistanceForWorkHours(dateKey, workSegments);
            
            console.log('Work segments:', workSegments);
            console.log('Work distance:', workDistance);
            
            const date = dateKeyToNYCDate(dateKey);
            const dateStr = date.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'America/New_York' });
            
            let html = '<div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
            html += '<h3 style="margin: 0 0 10px 0;">' + dateStr + '</h3>';
            html += '<div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">' + workDistance.toFixed(2) + ' miles</div>';
            html += '<div style="font-size: 1em; opacity: 0.9;">Walked during shift</div>';
            html += '</div>';
            
            // Stats grid
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">';
            
            html += '<div style="background: #667eea; color: white; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Summonses</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold;">' + dayData.count + '</div>';
            html += '<div style="font-size: 0.75em; opacity: 0.8;">filed</div>';
            html += '</div>';
            
            const milesPerSummons = dayData.count > 0 ? workDistance / dayData.count : 0;
            html += '<div style="background: #4facfe; color: white; padding: 15px; border-radius: 8px; text-align: center;">';
            html += '<div style="font-size: 0.85em; opacity: 0.9; margin-bottom: 5px;">Efficiency</div>';
            html += '<div style="font-size: 1.8em; font-weight: bold;">' + milesPerSummons.toFixed(2) + '</div>';
            html += '<div style="font-size: 0.75em; opacity: 0.8;">miles/summons</div>';
            html += '</div>';
            
            html += '</div>';
            
            // Hourly breakdown (work hours only)
            const hourlyData = walkingDataCache[dateKey];
            if (hourlyData && Object.keys(hourlyData).length > 0) {
                html += '<div style="background: white; padding: 20px; border-radius: 8px;">';
                html += '<h4 style="color: #2c3e50; margin-top: 0; margin-bottom: 15px;">‚è∞ Walking by Hour</h4>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 10px;">';
                
                const hours = Object.keys(hourlyData).map(Number).sort((a, b) => a - b);
                hours.forEach(hour => {
                    const miles = hourlyData[hour];
                    const hourStr = hour === 0 ? '12 AM' : hour < 12 ? hour + ' AM' : hour === 12 ? '12 PM' : (hour - 12) + ' PM';
                    
                    // Check if this is a work hour
                    const isWorkHour = workSegments.some(seg => {
                        const segStartHour = Math.floor(seg.start / 60);
                        const segEndHour = Math.ceil(seg.end / 60);
                        return hour >= segStartHour && hour < segEndHour;
                    });
                    
                    const bgColor = isWorkHour ? '#667eea' : '#e0e0e0';
                    const textColor = isWorkHour ? 'white' : '#666';
                    
                    html += `<div style="background: ${bgColor}; color: ${textColor}; padding: 12px; border-radius: 6px; text-align: center;">`;
                    html += `<div style="font-size: 0.75em; margin-bottom: 5px; opacity: 0.9;">${hourStr}</div>`;
                    html += `<div style="font-size: 1.1em; font-weight: bold;">${miles.toFixed(1)}</div>`;
                    html += `<div style="font-size: 0.7em; opacity: 0.8;">mi</div>`;
                    html += '</div>';
                });
                
                html += '</div>';
                html += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.85em; color: #666;">';
                html += '<div style="margin-bottom: 5px;"><span style="display: inline-block; width: 14px; height: 14px; background: #667eea; border-radius: 3px; margin-right: 8px; vertical-align: middle;"></span><strong>Blue:</strong> During your shift (based on summons times)</div>';
                html += '<div><span style="display: inline-block; width: 14px; height: 14px; background: #e0e0e0; border-radius: 3px; margin-right: 8px; vertical-align: middle;"></span><strong>Gray:</strong> Outside shift hours</div>';
                html += '</div>';
                html += '</div>';
            } else {
                html += '<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; color: #666;">';
                html += '<p style="margin: 0;">‚ö†Ô∏è No hourly walking data available for this day.</p>';
                html += '<p style="margin: 10px 0 0 0; font-size: 0.9em;">This usually means walking data wasn\'t recorded or hasn\'t synced yet.</p>';
                html += '</div>';
            }
            
            content.innerHTML = html;
            modal.style.display = 'block';
            
            // Scroll modal into view
            setTimeout(() => {
                modal.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
            
            console.log('Modal displayed successfully');
        }
        
        function closeDistanceDayDetail() {
            document.getElementById('distance-day-detail').style.display = 'none';
        }
        
        function generateDistanceInsights(monthTotal, avgWorkDay, bestDate, bestMiles, workDaysCount) {
            const container = document.getElementById('distance-insights');
            
            let html = '<div style="display: grid; gap: 15px;">';
            
            if (monthTotal > 0) {
                html += '<div style="padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">';
                html += '<div style="font-size: 1.1em; margin-bottom: 5px;">üí™ Best Shift</div>';
                html += '<div style="font-size: 0.9em; opacity: 0.9;">';
                if (bestDate) {
                    const date = new Date(bestDate);
                    const dateStr = date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                    html += `${dateStr} - walked ${bestMiles.toFixed(2)} miles during shift`;
                } else {
                    html += 'No data available';
                }
                html += '</div></div>';
                
                html += '<div style="padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">';
                html += '<div style="font-size: 1.1em; margin-bottom: 5px;">üìä Monthly Summary</div>';
                html += '<div style="font-size: 0.9em; opacity: 0.9;">';
                html += `${workDaysCount} shifts this month ‚Ä¢ ${avgWorkDay.toFixed(2)} avg miles per shift`;
                html += '</div></div>';
                
                html += '<div style="padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">';
                html += '<div style="font-size: 1.1em; margin-bottom: 5px;">üí° About This Data</div>';
                html += '<div style="font-size: 0.85em; opacity: 0.9; line-height: 1.6;">';
                html += 'Walking distance is calculated based on your <strong>shift times</strong> - from 30 minutes before your first summons to 30 minutes after your last summons, with breaks of 2.5+ hours separating different shifts.';
                html += '</div></div>';
            } else {
                html += '<div style="padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center;">';
                html += '<div style="font-size: 1.1em; opacity: 0.9;">No walking data available</div>';
                html += '<div style="font-size: 0.85em; opacity: 0.8; margin-top: 5px;">Walking data loads automatically when you load summons data</div>';
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function initializeDistanceTab() {
            const yearSelect = document.getElementById('distance-year');
            const monthSelect = document.getElementById('distance-month');
            
            const currentYear = new Date().getFullYear();
            const currentMonth = new Date().getMonth();
            
            // Populate years (2022 to current year)
            for (let year = 2022; year <= currentYear; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === currentYear) option.selected = true;
                yearSelect.appendChild(option);
            }
            
            // Populate months
            const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            months.forEach((month, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = month;
                if (index === currentMonth) option.selected = true;
                monthSelect.appendChild(option);
            });
            
            generateDistanceCalendar();
        }

        // ===== TRENDS TAB FUNCTIONS =====
        let trendCharts = {
            volume: null,
            payment: null,
            revenue: null,
            disqualification: null,
            companies: null,
            timeOfDay: null,
            walkingDistance: null,
            walkingEfficiency: null,
            weatherImpact: null
        };

        function getTimeKey(date, grouping) {
            const d = new Date(date);
            if (isNaN(d.getTime())) return null;
            
            if (grouping === 'month') {
                return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
            } else if (grouping === 'quarter') {
                const quarter = Math.floor(d.getMonth() / 3) + 1;
                return `${d.getFullYear()}-Q${quarter}`;
            } else if (grouping === 'year') {
                return `${d.getFullYear()}`;
            }
            return null;
        }

        function formatTimeLabel(key, grouping) {
            if (grouping === 'month') {
                const [year, month] = key.split('-');
                const date = new Date(year, parseInt(month) - 1);
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            } else if (grouping === 'quarter') {
                return key;
            } else if (grouping === 'year') {
                return key;
            }
            return key;
        }

        function getTrendData() {
            const dataset = document.getElementById('trends-dataset').value;
            let data = [];
            
            if (dataset === 'all') {
                ['at', 'at-nyc', 'mbt'].forEach(tab => data.push(...appData[tab].merged));
            } else {
                data = appData[dataset].merged;
            }
            
            return data;
        }

        async function reloadWalkingDataAndTrends() {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚è≥ Loading...';
            btn.disabled = true;
            
            try {
                // Collect all unique dates from all datasets
                const allDates = new Set();
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    appData[tab].master.forEach(row => {
                        const date = normalizeDate(row['Violation Date']);
                        if (date) {
                            allDates.add(date);
                        }
                    });
                });
                
                console.log('Reloading walking data for', allDates.size, 'dates');
                
                if (allDates.size > 0) {
                    await loadWalkingDataForDates(Array.from(allDates));
                    
                    // Re-merge all datasets
                    ['at', 'at-nyc', 'mbt'].forEach(tab => {
                        if (appData[tab].master.length > 0) {
                            mergeData(tab);
                        }
                    });
                    
                    console.log('Walking data reloaded and data re-merged');
                    
                    // Regenerate trends
                    generateAllTrends();
                }
            } catch (error) {
                console.error('Error reloading walking data:', error);
                alert('Error loading walking data. Check console for details.');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function generateAllTrends() {
            const data = getTrendData();
            
            if (data.length === 0) {
                alert('No data available. Please load data first.');
                return;
            }

            const grouping = document.getElementById('trends-grouping').value;
            
            generateVolumeChart(data, grouping);
            generatePaymentTrendChart(data, grouping);
            generateRevenueChart(data, grouping);
            generateDisqualificationChart(data, grouping);
            generateCompaniesChart(data, grouping);
            generateTimeOfDayChart(data);
            generateWalkingDistanceChart(data, grouping);
            generateWalkingEfficiencyChart(data, grouping);
            generateWeatherImpactChart(data);
            
            // Generate new trend analyses
            generateTopWeeks(data);
            generateTopDays(data);
            generateTopHours(data);
            generateTop25Companies(data);
        }

        function generateVolumeChart(data, grouping) {
            const timeData = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const key = getTimeKey(dateStr, grouping);
                    if (key) {
                        timeData[key] = (timeData[key] || 0) + 1;
                    }
                }
            });

            const sortedKeys = Object.keys(timeData).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));
            const values = sortedKeys.map(key => timeData[key]);

            const ctx = document.getElementById('trend-volume-chart').getContext('2d');
            
            if (trendCharts.volume) trendCharts.volume.destroy();
            
            trendCharts.volume = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Summons Issued',
                        data: values,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Summons: ' + context.parsed.y.toLocaleString();
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function generatePaymentTrendChart(data, grouping) {
            const timeData = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const key = getTimeKey(dateStr, grouping);
                    if (key) {
                        if (!timeData[key]) {
                            timeData[key] = { paid: 0, requested: 0, disqualified: 0, unpaid: 0 };
                        }
                        
                        if (row['_rowType'] === 'paid') {
                            timeData[key].paid++;
                        } else if (row['_rowType'] === 'requested') {
                            timeData[key].requested++;
                        } else if (row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                            timeData[key].disqualified++;
                        } else {
                            timeData[key].unpaid++;
                        }
                    }
                }
            });

            const sortedKeys = Object.keys(timeData).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));

            const ctx = document.getElementById('trend-payment-chart').getContext('2d');
            
            if (trendCharts.payment) trendCharts.payment.destroy();
            
            trendCharts.payment = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Paid',
                            data: sortedKeys.map(key => timeData[key].paid),
                            borderColor: '#27ae60',
                            backgroundColor: 'rgba(39, 174, 96, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Requested',
                            data: sortedKeys.map(key => timeData[key].requested),
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Disqualified',
                            data: sortedKeys.map(key => timeData[key].disqualified),
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Unpaid',
                            data: sortedKeys.map(key => timeData[key].unpaid),
                            borderColor: '#95a5a6',
                            backgroundColor: 'rgba(149, 165, 166, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: false
                        }
                    }
                }
            });
        }

        function generateRevenueChart(data, grouping) {
            const timeData = {};
            const balanceData = {};
            
            console.log('generateRevenueChart called with', data.length, 'rows');
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                
                if (dateStr) {
                    const key = getTimeKey(dateStr, grouping);
                    if (key) {
                        // Track paid/requested amounts
                        if (row['_rowType'] === 'paid' || row['_rowType'] === 'requested') {
                            const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                            if (!isNaN(amount) && amount > 0) {
                                timeData[key] = (timeData[key] || 0) + amount;
                            }
                        }
                        
                        // Track balance due from ALL rows (including unpaid)
                        const balanceDue = parseFloat((row['Balance Due'] || '0').replace(/[$,]/g, ''));
                        if (!isNaN(balanceDue) && balanceDue > 0) {
                            balanceData[key] = (balanceData[key] || 0) + balanceDue;
                        }
                    }
                }
            });

            console.log('Revenue Chart - periods with paid/requested:', Object.keys(timeData).length, 'periods with balance:', Object.keys(balanceData).length);

            const sortedKeys = Object.keys(timeData).sort();
            
            // Merge keys from both datasets to ensure we show all periods
            const allKeys = new Set([...Object.keys(timeData), ...Object.keys(balanceData)]);
            const sortedAllKeys = Array.from(allKeys).sort();
            
            const labels = sortedAllKeys.map(key => formatTimeLabel(key, grouping));
            const yourShareValues = sortedAllKeys.map(key => (timeData[key] || 0) * 0.25);
            const potentialValues = sortedAllKeys.map(key => (balanceData[key] || 0) * 0.25);

            const ctx = document.getElementById('trend-revenue-chart');
            if (!ctx) {
                console.error('Revenue chart canvas not found');
                return;
            }
            
            if (trendCharts.revenue) trendCharts.revenue.destroy();
            
            try {
                trendCharts.revenue = new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Your 25% Share (Paid/Requested)',
                                data: yourShareValues,
                                backgroundColor: 'rgba(39, 174, 96, 0.7)',
                                borderColor: '#27ae60',
                                borderWidth: 1
                            },
                            {
                                label: 'Potential from Balance Due (25%)',
                                data: potentialValues,
                                backgroundColor: 'rgba(241, 196, 15, 0.7)',
                                borderColor: '#f1c40f',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: true, position: 'top' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': $' + context.parsed.y.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toLocaleString();
                                    }
                                }
                            }
                        }
                    }
                });
                console.log('Revenue chart created successfully');
            } catch (error) {
                console.error('Error creating revenue chart:', error);
            }
        }

        function generateDisqualificationChart(data, grouping) {
            const timeData = {};
            const MIN_SUBMISSIONS = 10; // Minimum number of submissions to show a rate
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const key = getTimeKey(dateStr, grouping);
                    if (key) {
                        if (!timeData[key]) {
                            timeData[key] = { total: 0, disqualified: 0 };
                        }
                        timeData[key].total++;
                        if (row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                            timeData[key].disqualified++;
                        }
                    }
                }
            });

            const sortedKeys = Object.keys(timeData).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));
            
            // Calculate percentages with threshold and cap
            let previousValidRate = null;
            const percentages = sortedKeys.map(key => {
                const total = timeData[key].total;
                
                // If below threshold, use the previous valid rate or 0
                if (total < MIN_SUBMISSIONS) {
                    return previousValidRate !== null ? previousValidRate : 0;
                }
                
                // Calculate rate and cap at 15%
                let rate = (timeData[key].disqualified / total) * 100;
                rate = Math.min(rate, 15); // Cap at 15%
                previousValidRate = parseFloat(rate.toFixed(1));
                return previousValidRate;
            });

            const ctx = document.getElementById('trend-disqualification-chart').getContext('2d');
            
            if (trendCharts.disqualification) trendCharts.disqualification.destroy();
            
            trendCharts.disqualification = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Disqualification Rate (%)',
                        data: percentages,
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const key = sortedKeys[index];
                                    const total = timeData[key].total;
                                    if (total < MIN_SUBMISSIONS) {
                                        return 'Rate: ' + context.parsed.y + '% (< ' + MIN_SUBMISSIONS + ' submissions)';
                                    }
                                    return 'Rate: ' + context.parsed.y + '% (' + total + ' submissions)';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 15,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateTimeOfDayChart(data) {
            // Initialize hour buckets (0-23)
            const hourCounts = {};
            for (let i = 0; i < 24; i++) {
                hourCounts[i] = 0;
            }
            
            // Count summonses by hour
            data.forEach(row => {
                const timeStr = row['Violation Time'] || row['Time of Occurrence'] || '';
                if (timeStr) {
                    const hour = parseTimeToHour(timeStr);
                    if (hour !== null) {
                        hourCounts[hour]++;
                    }
                }
            });
            
            // Create labels (1 PM - 2 PM format)
            const labels = [];
            for (let hour = 0; hour < 24; hour++) {
                const nextHour = (hour + 1) % 24;
                const startLabel = formatHourLabel(hour);
                const endLabel = formatHourLabel(nextHour);
                labels.push(startLabel + ' - ' + endLabel);
            }
            
            const values = Object.keys(hourCounts).map(h => hourCounts[h]);
            
            const ctx = document.getElementById('time-of-day-chart').getContext('2d');
            
            if (trendCharts.timeOfDay) trendCharts.timeOfDay.destroy();
            
            trendCharts.timeOfDay = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Summonses',
                        data: values,
                        backgroundColor: '#667eea',
                        borderColor: '#764ba2',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Summonses: ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 90,
                                minRotation: 45,
                                font: {
                                    size: 10
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function generateWalkingDistanceChart(data, grouping) {
            const timeData = {};
            let hasData = false;
            let debugCount = 0;
            let totalRows = 0;
            let rowsWithWalkingDist = 0;
            let rowsWithNonEmptyWalkingDist = 0;
            
            console.log('generateWalkingDistanceChart called with', data.length, 'rows');
            
            // Track unique dates to avoid counting the same day's walking multiple times
            const uniqueDatesPerPeriod = {};
            
            data.forEach(row => {
                totalRows++;
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                const walkingDist = row['Walking Distance'];
                
                if (walkingDist !== undefined && walkingDist !== null) rowsWithWalkingDist++;
                if (walkingDist && walkingDist !== '') rowsWithNonEmptyWalkingDist++;
                
                if (dateStr && walkingDist && walkingDist !== '') {
                    const key = getTimeKey(dateStr, grouping);
                    const normalizedDate = normalizeDate(dateStr);
                    
                    if (key && normalizedDate) {
                        // Only count each unique date once per period
                        if (!uniqueDatesPerPeriod[key]) {
                            uniqueDatesPerPeriod[key] = new Set();
                        }
                        
                        // If we haven't counted this date yet for this period, add it
                        if (!uniqueDatesPerPeriod[key].has(normalizedDate)) {
                            uniqueDatesPerPeriod[key].add(normalizedDate);
                            
                            // Parse walking distance (e.g., "10.7 mi" -> 10.7)
                            const milesStr = String(walkingDist).replace(/[^\d.]/g, '');
                            const miles = parseFloat(milesStr);
                            if (!isNaN(miles) && miles > 0) {
                                timeData[key] = (timeData[key] || 0) + miles;
                                hasData = true;
                            }
                        }
                    }
                }
            });
            
            console.log('Walking Distance Chart - Total rows:', totalRows, 'Unique dates with data:', Object.values(uniqueDatesPerPeriod).reduce((sum, set) => sum + set.size, 0), 'hasData:', hasData, 'periods:', Object.keys(timeData).length);
            if (Object.keys(timeData).length > 0) {
                console.log('Sample period data:', Object.entries(timeData).slice(0, 3));
            }

            const ctx = document.getElementById('walking-distance-chart');
            if (!ctx) return;
            
            if (trendCharts.walkingDistance) trendCharts.walkingDistance.destroy();
            
            if (!hasData || Object.keys(timeData).length === 0) {
                // Create a simple chart with a message
                const message = rowsWithWalkingDist === 0 
                    ? 'No walking data in trends - click "üö∂ Reload Walking Data" button above'
                    : 'Walking data exists but is empty - try reloading';
                    
                trendCharts.walkingDistance = new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ['No Data'],
                        datasets: [{
                            label: 'Miles Walked',
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.3)',
                            borderColor: '#999',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: message,
                                color: '#999',
                                font: { size: 13 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 10,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' mi';
                                    }
                                }
                            }
                        }
                    }
                });
                return;
            }

            const sortedKeys = Object.keys(timeData).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));
            const values = sortedKeys.map(key => timeData[key]);
            
            trendCharts.walkingDistance = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Miles Walked',
                        data: values,
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        borderColor: '#3498db',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Miles: ' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + ' mi';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function generateWalkingEfficiencyChart(data, grouping) {
            const timeData = {};
            let hasData = false;
            
            // Track unique dates per period (for total miles) and all summonses (for count)
            const uniqueDatesPerPeriod = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                const walkingDist = row['Walking Distance'];
                
                if (dateStr && walkingDist && walkingDist !== '') {
                    const key = getTimeKey(dateStr, grouping);
                    const normalizedDate = normalizeDate(dateStr);
                    
                    if (key && normalizedDate) {
                        if (!timeData[key]) {
                            timeData[key] = { miles: 0, count: 0 };
                            uniqueDatesPerPeriod[key] = new Set();
                        }
                        
                        // Count every summons
                        timeData[key].count++;
                        
                        // But only add miles once per unique date
                        if (!uniqueDatesPerPeriod[key].has(normalizedDate)) {
                            uniqueDatesPerPeriod[key].add(normalizedDate);
                            const milesStr = String(walkingDist).replace(/[^\d.]/g, '');
                            const miles = parseFloat(milesStr);
                            if (!isNaN(miles) && miles > 0) {
                                timeData[key].miles += miles;
                                hasData = true;
                            }
                        }
                    }
                }
            });
            
            console.log('Walking Efficiency Chart - hasData:', hasData, 'periods:', Object.keys(timeData).length);

            const ctx = document.getElementById('walking-efficiency-chart');
            if (!ctx) return;
            
            if (trendCharts.walkingEfficiency) trendCharts.walkingEfficiency.destroy();
            
            if (!hasData || Object.keys(timeData).length === 0) {
                // Create a simple chart with a message
                trendCharts.walkingEfficiency = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: ['No Data'],
                        datasets: [{
                            label: 'Miles per Summons',
                            data: [0],
                            borderColor: '#999',
                            backgroundColor: 'rgba(200, 200, 200, 0.1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'No walking distance data available',
                                color: '#999',
                                font: { size: 14 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 5,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(2) + ' mi';
                                    }
                                }
                            }
                        }
                    }
                });
                return;
            }

            const sortedKeys = Object.keys(timeData).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));
            const efficiency = sortedKeys.map(key => {
                const data = timeData[key];
                return data.count > 0 ? data.miles / data.count : 0;
            });
            
            trendCharts.walkingEfficiency = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Miles per Summons',
                        data: efficiency,
                        borderColor: '#27ae60',
                        backgroundColor: 'rgba(39, 174, 96, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Efficiency: ' + context.parsed.y.toFixed(2) + ' mi/summons';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2) + ' mi';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function generateWeatherImpactChart(data) {
            // Group summonses by temperature ranges
            const tempRanges = {
                '< 32¬∞F': { min: -999, max: 32, count: 0 },
                '32-50¬∞F': { min: 32, max: 50, count: 0 },
                '50-70¬∞F': { min: 50, max: 70, count: 0 },
                '70-85¬∞F': { min: 70, max: 85, count: 0 },
                '> 85¬∞F': { min: 85, max: 999, count: 0 }
            };
            
            let hasData = false;
            let debugCount = 0;
            
            console.log('generateWeatherImpactChart called with', data.length, 'rows');
            
            data.forEach(row => {
                // Try multiple possible field names for temperature
                const temp = parseFloat(row['Temperature'] || row['Temp'] || row['temperature'] || row['temp'] || '');
                
                // Debug: check first few rows - show ALL the fields
                if (debugCount < 3) {
                    console.log('Row', debugCount, 'fields:', Object.keys(row).sort());
                    console.log('  Temperature fields:', {
                        Temperature: row['Temperature'],
                        Temp: row['Temp'],
                        temperature: row['temperature'],
                        temp: row['temp'],
                        parsed: temp,
                        isNaN: isNaN(temp)
                    });
                    debugCount++;
                }
                
                if (!isNaN(temp)) {
                    hasData = true;
                    for (const range in tempRanges) {
                        const r = tempRanges[range];
                        if (temp >= r.min && temp < r.max) {
                            r.count++;
                            break;
                        }
                    }
                }
            });
            
            console.log('Weather Impact Chart - hasData:', hasData, 'ranges:', tempRanges);

            const ctx = document.getElementById('weather-impact-chart');
            if (!ctx) return;
            
            if (trendCharts.weatherImpact) trendCharts.weatherImpact.destroy();
            
            const labels = Object.keys(tempRanges);
            const values = labels.map(label => tempRanges[label].count);
            
            if (!hasData) {
                // Create a simple chart with a message
                trendCharts.weatherImpact = new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Summonses by Temperature',
                            data: [0, 0, 0, 0, 0],
                            backgroundColor: 'rgba(200, 200, 200, 0.3)',
                            borderColor: '#999',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: true,
                                text: 'Optional: Add "Temperature" column to your spreadsheet to track weather impact',
                                color: '#999',
                                font: { size: 12 },
                                padding: { bottom: 10 }
                            },
                            subtitle: {
                                display: true,
                                text: 'This chart will populate when temperature data is available',
                                color: '#aaa',
                                font: { size: 10 }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 10,
                                ticks: {
                                    stepSize: 1
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            trendCharts.weatherImpact = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Summonses by Temperature',
                        data: values,
                        backgroundColor: [
                            'rgba(52, 152, 219, 0.7)',
                            'rgba(46, 204, 113, 0.7)',
                            'rgba(241, 196, 15, 0.7)',
                            'rgba(230, 126, 34, 0.7)',
                            'rgba(231, 76, 60, 0.7)'
                        ],
                        borderColor: [
                            '#3498db',
                            '#2ecc71',
                            '#f1c40f',
                            '#e67e22',
                            '#e74c3c'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Summonses: ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }
        
        function parseTimeToHour(timeStr) {
            // Parse time string to hour (0-23)
            const match = timeStr.match(/(\d{1,2}):?(\d{2})?\s*(AM|PM)?/i);
            if (match) {
                let hours = parseInt(match[1]);
                const ampm = match[3] ? match[3].toUpperCase() : null;
                
                if (ampm === 'PM' && hours !== 12) hours += 12;
                if (ampm === 'AM' && hours === 12) hours = 0;
                
                if (hours >= 0 && hours < 24) return hours;
            }
            return null;
        }
        
        function formatHourLabel(hour) {
            if (hour === 0) return '12 AM';
            if (hour === 12) return '12 PM';
            if (hour < 12) return hour + ' AM';
            return (hour - 12) + ' PM';
        }

        function generateCompaniesChart(data, grouping) {
            // Get top 5 companies
            const companyCounts = {};
            data.forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                companyCounts[company] = (companyCounts[company] || 0) + 1;
            });
            
            const topCompanies = Object.entries(companyCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(e => e[0]);

            // Track each company over time
            const companyTimeData = {};
            topCompanies.forEach(company => {
                companyTimeData[company] = {};
            });

            data.forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                if (topCompanies.includes(company)) {
                    const dateStr = row['Violation Date'] || row['Date Submitted'];
                    if (dateStr) {
                        const key = getTimeKey(dateStr, grouping);
                        if (key) {
                            companyTimeData[company][key] = (companyTimeData[company][key] || 0) + 1;
                        }
                    }
                }
            });

            const allKeys = new Set();
            Object.values(companyTimeData).forEach(timeData => {
                Object.keys(timeData).forEach(key => allKeys.add(key));
            });
            const sortedKeys = Array.from(allKeys).sort();
            const labels = sortedKeys.map(key => formatTimeLabel(key, grouping));

            const colors = ['#3498db', '#27ae60', '#f39c12', '#e74c3c', '#9b59b6'];
            const datasets = topCompanies.map((company, i) => ({
                label: company,
                data: sortedKeys.map(key => companyTimeData[company][key] || 0),
                borderColor: colors[i],
                backgroundColor: colors[i] + '20',
                borderWidth: 2,
                fill: false,
                tension: 0.4
            }));

            const ctx = document.getElementById('trend-companies-chart').getContext('2d');
            
            if (trendCharts.companies) trendCharts.companies.destroy();
            
            trendCharts.companies = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function generatePeriodComparison(data, grouping) {
            const timeData = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'] || row['Date Submitted'];
                if (dateStr) {
                    const key = getTimeKey(dateStr, grouping);
                    if (key) {
                        if (!timeData[key]) {
                            timeData[key] = {
                                total: 0,
                                paid: 0,
                                requested: 0,
                                disqualified: 0,
                                revenue: 0
                            };
                        }
                        timeData[key].total++;
                        
                        if (row['_rowType'] === 'paid') {
                            timeData[key].paid++;
                            const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                            if (!isNaN(amount)) {
                                timeData[key].revenue += amount;
                            }
                        } else if (row['_rowType'] === 'requested') {
                            timeData[key].requested++;
                        } else if (row['_rowType'] === 'disqualified' || row['_rowType'] === 'dismissed') {
                            timeData[key].disqualified++;
                        }
                    }
                }
            });

            const sortedKeys = Object.keys(timeData).sort();
            const recentPeriods = sortedKeys.slice(-6); // Last 6 periods

            const comparisonDiv = document.getElementById('period-comparison');
            
            if (recentPeriods.length === 0) {
                comparisonDiv.innerHTML = '<p style="color: #666; font-size: 0.85em;">No data available for comparison</p>';
                return;
            }

            let html = '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #1e3c72; color: white;">';
            html += '<th style="padding: 8px; text-align: left;">Period</th>';
            html += '<th style="padding: 8px; text-align: right;">Total</th>';
            html += '<th style="padding: 8px; text-align: right;">Paid</th>';
            html += '<th style="padding: 8px; text-align: right;">Requested</th>';
            html += '<th style="padding: 8px; text-align: right;">Disqualified</th>';
            html += '<th style="padding: 8px; text-align: right;">Revenue</th>';
            html += '<th style="padding: 8px; text-align: right;">Your Share</th>';
            html += '</tr></thead><tbody>';

            recentPeriods.forEach((key, index) => {
                const period = timeData[key];
                const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                html += `<tr style="background: ${bgColor}; border-bottom: 1px solid #ddd;">`;
                html += `<td style="padding: 6px; font-weight: bold;">${formatTimeLabel(key, grouping)}</td>`;
                html += `<td style="padding: 6px; text-align: right;">${period.total}</td>`;
                html += `<td style="padding: 6px; text-align: right; color: #27ae60;">${period.paid}</td>`;
                html += `<td style="padding: 6px; text-align: right; color: #f39c12;">${period.requested}</td>`;
                html += `<td style="padding: 6px; text-align: right; color: #e74c3c;">${period.disqualified}</td>`;
                html += `<td style="padding: 6px; text-align: right;">$${period.revenue.toFixed(2)}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: #27ae60;">$${(period.revenue * 0.25).toFixed(2)}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            comparisonDiv.innerHTML = html;
        }

        // Function to get week start date (Sunday) for a given date
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day;
            return new Date(d.setDate(diff));
        }

        // Generate Top 10 Weeks
        function generateTopWeeks(data) {
            const weekData = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'];
                if (dateStr) {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        const weekStart = getWeekStart(date);
                        const weekKey = weekStart.toISOString().split('T')[0];
                        
                        if (!weekData[weekKey]) {
                            weekData[weekKey] = {
                                count: 0,
                                startDate: weekStart,
                                endDate: new Date(weekStart.getTime() + 6 * 24 * 60 * 60 * 1000)
                            };
                        }
                        weekData[weekKey].count++;
                    }
                }
            });

            const topWeeks = Object.entries(weekData)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);

            const container = document.getElementById('trend-top-weeks');
            let html = '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #1e3c72; color: white;">';
            html += '<th style="padding: 8px;">Rank</th>';
            html += '<th style="padding: 8px;">Week</th>';
            html += '<th style="padding: 8px;">Date Range</th>';
            html += '<th style="padding: 8px; text-align: right;">Violations</th>';
            html += '</tr></thead><tbody>';

            topWeeks.forEach(([weekKey, data], index) => {
                const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                const startStr = data.startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const endStr = data.endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="padding: 6px; text-align: center; font-weight: bold;">#${index + 1}</td>`;
                html += `<td style="padding: 6px;">Week of ${startStr}</td>`;
                html += `<td style="padding: 6px; font-size: 0.9em; color: #666;">${startStr} - ${endStr}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: #1e3c72;">${data.count}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Generate Top 10 Days
        function generateTopDays(data) {
            const dayData = {};
            
            data.forEach(row => {
                const dateStr = row['Violation Date'];
                if (dateStr) {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        const dayKey = date.toISOString().split('T')[0];
                        dayData[dayKey] = (dayData[dayKey] || 0) + 1;
                    }
                }
            });

            const topDays = Object.entries(dayData)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const container = document.getElementById('trend-top-days');
            let html = '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #1e3c72; color: white;">';
            html += '<th style="padding: 8px;">Rank</th>';
            html += '<th style="padding: 8px;">Date</th>';
            html += '<th style="padding: 8px;">Day of Week</th>';
            html += '<th style="padding: 8px; text-align: right;">Violations</th>';
            html += '</tr></thead><tbody>';

            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            topDays.forEach(([dayKey, count], index) => {
                // Parse date manually to avoid timezone issues
                // dayKey format is "YYYY-MM-DD"
                const parts = dayKey.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
                const day = parseInt(parts[2]);
                const date = new Date(Date.UTC(year, month, day));
                const dayOfWeek = dayNames[date.getUTCDay()];
                const dateStr = date.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });
                const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="padding: 6px; text-align: center; font-weight: bold;">#${index + 1}</td>`;
                html += `<td style="padding: 6px;">${dateStr}</td>`;
                html += `<td style="padding: 6px; color: #666;">${dayOfWeek}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: #1e3c72;">${count}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Generate Top 10 Hours (Specific hour-long blocks)
        function generateTopHours(data) {
            // Collect all violations with exact timestamps
            const violationTimestamps = [];
            
            data.forEach(row => {
                const dateStr = row['Violation Date'];
                const timeStr = row['Violation Time'];
                if (dateStr && timeStr) {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime()) && timeStr.includes(':')) {
                        const [hour, minute] = timeStr.split(':').map(n => parseInt(n));
                        if (!isNaN(hour) && !isNaN(minute)) {
                            date.setHours(hour, minute, 0, 0);
                            violationTimestamps.push({
                                timestamp: date.getTime(),
                                dateStr: dateStr,
                                timeStr: timeStr,
                                row: row
                            });
                        }
                    }
                }
            });
            
            // Sort by timestamp
            violationTimestamps.sort((a, b) => a.timestamp - b.timestamp);
            
            // Find hour-long blocks with most violations
            const hourBlocks = [];
            
            for (let i = 0; i < violationTimestamps.length; i++) {
                const startTime = violationTimestamps[i].timestamp;
                const endTime = startTime + (60 * 60 * 1000); // 1 hour later
                
                // Count violations in this hour block
                let count = 0;
                let j = i;
                while (j < violationTimestamps.length && violationTimestamps[j].timestamp < endTime) {
                    count++;
                    j++;
                }
                
                if (count > 1) { // Only consider blocks with multiple violations
                    const startDate = new Date(startTime);
                    const endDate = new Date(endTime);
                    
                    hourBlocks.push({
                        startTime: startTime,
                        endTime: endTime,
                        startDateStr: startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }),
                        startTimeStr: startDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                        endTimeStr: endDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                        count: count,
                        firstViolation: violationTimestamps[i],
                        lastViolation: violationTimestamps[Math.min(i + count - 1, j - 1)]
                    });
                }
            }
            
            // Remove overlapping blocks (keep the one with higher count)
            const uniqueBlocks = [];
            hourBlocks.forEach(block => {
                const overlapping = uniqueBlocks.find(existing => 
                    (block.startTime >= existing.startTime && block.startTime < existing.endTime) ||
                    (existing.startTime >= block.startTime && existing.startTime < block.endTime)
                );
                
                if (!overlapping) {
                    uniqueBlocks.push(block);
                } else if (block.count > overlapping.count) {
                    const index = uniqueBlocks.indexOf(overlapping);
                    uniqueBlocks[index] = block;
                }
            });
            
            // Sort by count and take top 10
            const topBlocks = uniqueBlocks
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);

            const container = document.getElementById('trend-top-hours');
            
            if (topBlocks.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Not enough data to identify specific hour-long violation clusters.</p>';
                return;
            }
            
            let html = '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #1e3c72; color: white;">';
            html += '<th style="padding: 8px;">Rank</th>';
            html += '<th style="padding: 8px;">Date</th>';
            html += '<th style="padding: 8px;">Hour Block</th>';
            html += '<th style="padding: 8px; text-align: right;">Violations</th>';
            html += '</tr></thead><tbody>';

            topBlocks.forEach((block, index) => {
                const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="padding: 6px; text-align: center; font-weight: bold;">#${index + 1}</td>`;
                html += `<td style="padding: 6px;">${block.startDateStr}</td>`;
                html += `<td style="padding: 6px; font-weight: bold;">${block.startTimeStr} - ${block.endTimeStr}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: #1e3c72;">${block.count}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Generate Top 25 Companies
        function generateTop25Companies(data) {
            const companyData = {};
            
            data.forEach(row => {
                const company = normalizeCompanyName(row['Company Name'] || 'Unknown');
                
                if (!companyData[company]) {
                    companyData[company] = {
                        submissions: 0,
                        totalPaid: 0,
                        paidCount: 0
                    };
                }
                
                companyData[company].submissions++;
                
                if (row['_rowType'] === 'paid') {
                    companyData[company].paidCount++;
                    const amount = parseFloat((row['Paid Amount'] || '0').replace(/[$,]/g, ''));
                    if (!isNaN(amount)) {
                        companyData[company].totalPaid += amount;
                    }
                }
            });

            const top25 = Object.entries(companyData)
                .sort((a, b) => b[1].submissions - a[1].submissions)
                .slice(0, 25);

            const container = document.getElementById('trend-top-25-companies');
            let html = '<div style="overflow-x: auto;"><table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">';
            html += '<thead><tr style="background: #1e3c72; color: white;">';
            html += '<th style="padding: 8px;">Rank</th>';
            html += '<th style="padding: 8px;">Company</th>';
            html += '<th style="padding: 8px; text-align: right;">Submissions</th>';
            html += '<th style="padding: 8px; text-align: right;">Paid Count</th>';
            html += '<th style="padding: 8px; text-align: right;">NYC Paid Total</th>';
            html += '<th style="padding: 8px; text-align: right;">Your 25%</th>';
            html += '<th style="padding: 8px; text-align: right;">Pay Rate</th>';
            html += '</tr></thead><tbody>';

            let totalYourShare = 0;
            
            top25.forEach(([company, data], index) => {
                const bgColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                const yourShare = data.totalPaid * 0.25;
                totalYourShare += yourShare;
                const payRate = data.submissions > 0 ? ((data.paidCount / data.submissions) * 100).toFixed(1) : '0.0';
                const rateColor = parseFloat(payRate) >= 60 ? '#27ae60' : parseFloat(payRate) >= 40 ? '#f39c12' : '#e74c3c';
                
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="padding: 6px; text-align: center; font-weight: bold;">#${index + 1}</td>`;
                html += `<td style="padding: 6px;">${company}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold;">${data.submissions}</td>`;
                html += `<td style="padding: 6px; text-align: right;">${data.paidCount}</td>`;
                html += `<td style="padding: 6px; text-align: right;">$${data.totalPaid.toFixed(2)}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: #27ae60;">$${yourShare.toFixed(2)}</td>`;
                html += `<td style="padding: 6px; text-align: right; font-weight: bold; color: ${rateColor};">${payRate}%</td>`;
                html += '</tr>';
            });

            // Add total row
            const totalSubmissions = top25.reduce((sum, [, data]) => sum + data.submissions, 0);
            const totalPaidCount = top25.reduce((sum, [, data]) => sum + data.paidCount, 0);
            const totalNYCPaid = top25.reduce((sum, [, data]) => sum + data.totalPaid, 0);
            const avgPayRate = totalSubmissions > 0 ? ((totalPaidCount / totalSubmissions) * 100).toFixed(1) : '0.0';
            
            html += `<tr style="background: #f0f0f0; font-weight: bold;">`;
            html += `<td colspan="2" style="padding: 8px;">TOTAL (Top 25)</td>`;
            html += `<td style="padding: 8px; text-align: right;">${totalSubmissions}</td>`;
            html += `<td style="padding: 8px; text-align: right;">${totalPaidCount}</td>`;
            html += `<td style="padding: 8px; text-align: right;">$${totalNYCPaid.toFixed(2)}</td>`;
            html += `<td style="padding: 8px; text-align: right; color: #27ae60;">$${totalYourShare.toFixed(2)}</td>`;
            html += `<td style="padding: 8px; text-align: right;">${avgPayRate}%</td>`;
            html += '</tr>';

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        function exportMismatchesPDF() {
            if (Object.keys(mismatchesData).length === 0) {
                alert('Please generate the discrepancy report first by clicking "üîç Generate Reports"');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Add title
            doc.setFontSize(18);
            doc.setTextColor(30, 60, 114);
            doc.text('Payment Amount Mismatches Report', 14, 20);
            
            // Add generation date
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text('Generated: ' + new Date().toLocaleString(), 14, 28);
            
            let yPosition = 38;
            
            // Process each dataset
            Object.keys(mismatchesData).forEach((datasetName, index) => {
                const data = mismatchesData[datasetName];
                
                // Add page break if needed (except for first dataset)
                if (index > 0 && yPosition > 240) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Dataset header
                doc.setFontSize(14);
                doc.setTextColor(30, 60, 114);
                doc.text(`${datasetName} Dataset - ${data.mismatches.length} Discrepancies`, 14, yPosition);
                yPosition += 8;
                
                // Create table data
                const tableData = data.mismatches.map(m => [
                    m.summons,
                    m.invoice,
                    m.company.length > 25 ? m.company.substring(0, 22) + '...' : m.company,
                    '$' + m.nycPaid.toFixed(2),
                    '$' + m.expected.toFixed(2),
                    '$' + m.received.toFixed(2),
                    m.paymentDate,
                    (m.difference < 0 ? '-' : '+') + '$' + Math.abs(m.difference).toFixed(2)
                ]);
                
                // Add summary row
                tableData.push([
                    '',
                    '',
                    'TOTALS',
                    '',
                    '$' + data.totalExpected.toFixed(2),
                    '$' + data.totalReceived.toFixed(2),
                    '',
                    (data.totalDifference < 0 ? '-' : '+') + '$' + Math.abs(data.totalDifference).toFixed(2)
                ]);
                
                // Generate table
                doc.autoTable({
                    startY: yPosition,
                    head: [['Summons #', 'Invoice #', 'Company', 'NYC Paid', 'Expected', 'Received', 'Date', 'Difference']],
                    body: tableData,
                    theme: 'striped',
                    headStyles: {
                        fillColor: [30, 60, 114],
                        textColor: [255, 255, 255],
                        fontStyle: 'bold',
                        fontSize: 8
                    },
                    bodyStyles: {
                        fontSize: 7,
                        cellPadding: 2
                    },
                    columnStyles: {
                        0: { cellWidth: 22, fontStyle: 'mono' }, // Summons
                        1: { cellWidth: 20 }, // Invoice
                        2: { cellWidth: 35 }, // Company
                        3: { halign: 'right', cellWidth: 20 }, // NYC Paid
                        4: { halign: 'right', cellWidth: 20 }, // Expected
                        5: { halign: 'right', cellWidth: 20 }, // Received
                        6: { cellWidth: 22, fontSize: 6 }, // Date
                        7: { halign: 'right', cellWidth: 20 } // Difference
                    },
                    didParseCell: function(data) {
                        // Highlight summary row
                        if (data.row.index === tableData.length - 1) {
                            data.cell.styles.fillColor = [240, 240, 240];
                            data.cell.styles.fontStyle = 'bold';
                        }
                        
                        // Color code differences in last column
                        if (data.column.index === 7 && data.row.index < tableData.length - 1) {
                            const value = data.cell.text[0];
                            if (value.startsWith('-')) {
                                data.cell.styles.textColor = [231, 76, 60]; // Red for negative
                            } else if (value.startsWith('+')) {
                                data.cell.styles.textColor = [52, 152, 219]; // Blue for positive
                            }
                        }
                    },
                    didDrawPage: function(data) {
                        // Footer
                        const pageCount = doc.internal.getNumberOfPages();
                        const pageSize = doc.internal.pageSize;
                        const pageHeight = pageSize.height ? pageSize.height : pageSize.getHeight();
                        
                        doc.setFontSize(8);
                        doc.setTextColor(150, 150, 150);
                        doc.text('Page ' + doc.internal.getCurrentPageInfo().pageNumber + ' of ' + pageCount, 
                                14, pageHeight - 10);
                    }
                });
                
                yPosition = doc.lastAutoTable.finalY + 15;
            });
            
            // Add summary page if multiple datasets
            if (Object.keys(mismatchesData).length > 1) {
                doc.addPage();
                
                doc.setFontSize(16);
                doc.setTextColor(30, 60, 114);
                doc.text('Overall Summary', 14, 20);
                
                let overallExpected = 0;
                let overallReceived = 0;
                let overallDiscrepancies = 0;
                
                const summaryData = [];
                Object.keys(mismatchesData).forEach(datasetName => {
                    const data = mismatchesData[datasetName];
                    overallExpected += data.totalExpected;
                    overallReceived += data.totalReceived;
                    overallDiscrepancies += data.mismatches.length;
                    
                    summaryData.push([
                        datasetName,
                        data.mismatches.length,
                        '$' + data.totalExpected.toFixed(2),
                        '$' + data.totalReceived.toFixed(2),
                        (data.totalDifference < 0 ? '-' : '+') + '$' + Math.abs(data.totalDifference).toFixed(2)
                    ]);
                });
                
                // Add total row
                summaryData.push([
                    'TOTAL',
                    overallDiscrepancies,
                    '$' + overallExpected.toFixed(2),
                    '$' + overallReceived.toFixed(2),
                    (overallReceived - overallExpected < 0 ? '-' : '+') + '$' + Math.abs(overallReceived - overallExpected).toFixed(2)
                ]);
                
                doc.autoTable({
                    startY: 30,
                    head: [['Dataset', 'Count', 'Expected', 'Received', 'Difference']],
                    body: summaryData,
                    theme: 'grid',
                    headStyles: {
                        fillColor: [30, 60, 114],
                        textColor: [255, 255, 255],
                        fontStyle: 'bold'
                    },
                    columnStyles: {
                        1: { halign: 'center' },
                        2: { halign: 'right' },
                        3: { halign: 'right' },
                        4: { halign: 'right' }
                    },
                    didParseCell: function(data) {
                        // Highlight total row
                        if (data.row.index === summaryData.length - 1) {
                            data.cell.styles.fillColor = [30, 60, 114];
                            data.cell.styles.textColor = [255, 255, 255];
                            data.cell.styles.fontStyle = 'bold';
                        }
                    }
                });
                
                // Add notes section
                yPosition = doc.lastAutoTable.finalY + 15;
                doc.setFontSize(12);
                doc.setTextColor(30, 60, 114);
                doc.text('Notes:', 14, yPosition);
                
                doc.setFontSize(10);
                doc.setTextColor(80, 80, 80);
                yPosition += 8;
                doc.text('‚Ä¢ Expected amount is 25% of what NYC was paid', 14, yPosition);
                yPosition += 6;
                doc.text('‚Ä¢ Positive difference = You received MORE than expected', 14, yPosition);
                yPosition += 6;
                doc.text('‚Ä¢ Negative difference = You received LESS than expected', 14, yPosition);
                yPosition += 6;
                doc.text('‚Ä¢ Only discrepancies greater than $0.50 are shown', 14, yPosition);
            }
            
            // Save the PDF
            const fileName = `Payment_Mismatches_Report_${new Date().toISOString().split('T')[0]}.pdf`;
            doc.save(fileName);
        }

        function showEmailExportModal(dataset) {
            const modal = document.getElementById('emailModal');
            const modalBody = document.getElementById('emailModalBody');
            
            // Get new money data for this dataset
            const newMoneyData = getNewMoneyData(dataset);
            
            if (newMoneyData.length === 0) {
                alert('No new money summonses found for this dataset.');
                return;
            }

            // Get vendor info based on dataset
            const vendorInfo = getVendorInfo(dataset);
            
            // Group summonses in groups of 8
            const groups = [];
            for (let i = 0; i < newMoneyData.length; i += 8) {
                groups.push(newMoneyData.slice(i, i + 8));
            }
            
            // Get today's date in MM/DD/YYYY format
            const today = new Date();
            const dateString = `${today.getMonth() + 1}/${today.getDate()}/${today.getFullYear()}`;
            
            // Build modal content
            let html = '';
            groups.forEach((group, index) => {
                const summonsList = group.map(item => item['Summons Number'] || item.summons).join('\n');
                // Create search string with OR between quoted exact matches
                const searchString = group.map(item => `"${item['Summons Number'] || item.summons}"`).join(' OR ');
                
                // Create email subject
                const emailSubject = `Complaint Payment ${dateString} #${index + 1}`;
                
                // Create spreadsheet data (tab-separated for easy paste into Google Sheets)
                // Add sequence number if there are multiple groups
                const sequenceSuffix = groups.length > 1 ? ` - #${index + 1}` : '';
                const spreadsheetData = group.map(item => {
                    const summonsNum = item['Summons Number'] || item.summons;
                    return `${summonsNum}\t${dateString}${sequenceSuffix}`;
                }).join('\n');
                
                // Determine email body based on dataset
                let emailBody;
                if (dataset === 'mbt') {
                    // For MBT, body format (not subject)
                    emailBody = `Hello, I am the citizen who submitted the complaint for the following paid summons through the Citizens Air Complaint Program:

Vendor Code: ${vendorInfo.code}
${vendorInfo.name}
Mailing address: ${vendorInfo.address}

${summonsList}`;
                } else {
                    // For AT and AT-NYC
                    emailBody = `Hello, I am the citizen who submitted the complaint for the following paid summons through the Citizens Air Complaint Program:

Vendor Code: ${vendorInfo.code}
${vendorInfo.name}
Mailing address: ${vendorInfo.address}

${summonsList}`;
                }
                
                html += `
                    <div class="email-group">
                        <h3>Group ${index + 1} (${group.length} summonses)</h3>
                        
                        <div class="copy-section">
                            <label>Email Subject:</label>
                            <textarea id="email-subject-${index}" rows="1" readonly>${emailSubject}</textarea>
                            <button class="copy-btn" onclick="copyToClipboard('email-subject-${index}', this)">üìã Copy</button>
                        </div>
                        
                        <div class="copy-section">
                            <label>Email Body:</label>
                            <textarea id="email-body-${index}" rows="10" readonly>${emailBody}</textarea>
                            <button class="copy-btn" onclick="copyToClipboard('email-body-${index}', this)">üìã Copy</button>
                        </div>
                        
                        <div class="copy-section">
                            <label>Gmail Search String:</label>
                            <textarea id="search-string-${index}" rows="2" readonly>${searchString}</textarea>
                            <button class="copy-btn" onclick="copyToClipboard('search-string-${index}', this)">üìã Copy</button>
                        </div>
                        
                        <div class="copy-section">
                            <label>Spreadsheet Data (Paste into Google Sheets):</label>
                            <textarea id="spreadsheet-data-${index}" rows="6" readonly>${spreadsheetData}</textarea>
                            <button class="copy-btn" onclick="copyToClipboard('spreadsheet-data-${index}', this)">üìã Copy</button>
                        </div>
                    </div>
                `;
            });
            
            modalBody.innerHTML = html;
            modal.style.display = 'block';
        }

        function getVendorInfo(dataset) {
            switch(dataset) {
                case 'at':
                    return {
                        code: 'VS00083313',
                        name: 'Alexander Traynor',
                        address: '374 Monaco Ln, Glastonbury, CT 06033'
                    };
                case 'at-nyc':
                    return {
                        code: 'VS00083313',
                        name: 'Alexander Traynor',
                        address: '374 Monaco Ln, Glastonbury, CT 06033'
                    };
                case 'mbt':
                    return {
                        code: 'VS00099981',
                        name: 'Mary Beth Brown-Traynor ',
                        address: '97 Ledgewood Dr, Glastonbury, CT 06033'
                    };
                default:
                    return {
                        code: 'UNKNOWN',
                        name: 'UNKNOWN',
                        address: 'UNKNOWN'
                    };
            }
        }

        function getNewMoneyData(dataset) {
            // Get merged data
            const data = appData[dataset].merged || [];
            
            // Filter for "Paid in Full" status but not yet collected
            // This matches the logic in renderNewMoney()
            const newMoney = data.filter(row => {
                const hearingStatus = (row['Hearing Status'] || '').toLowerCase();
                const paymentStatus = (row['Payment Status'] || '').trim();
                return hearingStatus === 'paid in full' && !paymentStatus;
            });
            
            return newMoney;
        }

        function closeEmailModal() {
            document.getElementById('emailModal').style.display = 'none';
        }

        function copyToClipboard(elementId, button) {
            const textarea = document.getElementById(elementId);
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                document.execCommand('copy');
                button.textContent = '‚úÖ Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = 'üìã Copy';
                    button.classList.remove('copied');
                }, 2000);
            } catch (err) {
                alert('Failed to copy. Please copy manually.');
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('emailModal');
            if (event.target == modal) {
                closeEmailModal();
            }
        }

        // Data Converter Functions
        function convertOATHData() {
            const rawData = document.getElementById('raw-data-input').value.trim();
            const paymentDate = document.getElementById('payment-date-input').value;
            
            if (!rawData) {
                alert('Please paste raw OATH data.');
                return;
            }
            
            if (!paymentDate) {
                alert('Please select a payment date.');
                return;
            }
            
            // Parse the raw data
            // Format: "Office of Administrative Trials and HearingsBP00861922Z87.5087.50Additional Details"
            const pattern = /BP(\d{8}[A-Z])/g;
            const matches = [...rawData.matchAll(pattern)];
            
            if (matches.length === 0) {
                alert('No valid summons numbers found in the format BP########L');
                return;
            }
            
            // Extract summons numbers and convert
            const summonses = matches.map(match => {
                const summonsNum = match[1]; // Get the captured group (digits + letter)
                return '0' + summonsNum; // Replace BP with single 0 (so 0 + 00###### = 000######)
            });
            
            // Format date as MM/DD/YYYY
            const dateObj = new Date(paymentDate);
            const formattedDate = `${String(dateObj.getMonth() + 1).padStart(2, '0')}/${String(dateObj.getDate()).padStart(2, '0')}/${dateObj.getFullYear()}`;
            
            // Create table format with tabs (for spreadsheet paste)
            let tableData = '';
            summonses.forEach(summons => {
                tableData += `${summons}\t87.5\t${formattedDate}\n`;
            });
            
            // Display result
            document.getElementById('converted-data-output').value = tableData;
            document.getElementById('converted-output').style.display = 'block';
        }

        function copyConvertedData() {
            const textarea = document.getElementById('converted-data-output');
            if (textarea.value) {
                textarea.select();
                textarea.setSelectionRange(0, 99999);
                
                try {
                    document.execCommand('copy');
                    alert('Converted data copied to clipboard!');
                } catch (err) {
                    alert('Failed to copy. Please copy manually.');
                }
            } else {
                alert('No converted data to copy. Please convert data first.');
            }
        }

        function clearConverter() {
            document.getElementById('raw-data-input').value = '';
            document.getElementById('payment-date-input').value = '';
            document.getElementById('converted-data-output').value = '';
            document.getElementById('converted-output').style.display = 'none';
        }

        function saveToStorage() {
            try {
                const saveData = {};
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    saveData[tab] = {
                        master: appData[tab].master,
                        paid: appData[tab].paid,
                        requests: appData[tab].requests,
                        merged: appData[tab].merged,
                        lastRefreshSheets: appData[tab].lastRefreshSheets,
                        lastRefreshNYC: appData[tab].lastRefreshNYC
                    };
                });
                localStorage.setItem('truckDataManager', JSON.stringify(saveData));
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem('truckDataManager');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    Object.keys(parsed).forEach(tab => {
                        if (appData[tab] && parsed[tab]) {
                            appData[tab].master = parsed[tab].master || [];
                            appData[tab].paid = parsed[tab].paid || [];
                            appData[tab].requests = parsed[tab].requests || [];
                            appData[tab].merged = parsed[tab].merged || [];
                            appData[tab].lastRefreshSheets = parsed[tab].lastRefreshSheets || null;
                            appData[tab].lastRefreshNYC = parsed[tab].lastRefreshNYC || null;
                        }
                    });
                    
                    // Load walking data for all dates in the cached data
                    const allDates = new Set();
                    ['at', 'at-nyc', 'mbt'].forEach(tab => {
                        if (appData[tab].merged.length > 0) {
                            appData[tab].merged.forEach(row => {
                                const date = row['Violation Date'];
                                if (date) {
                                    const normalized = normalizeDate(date);
                                    if (normalized) {
                                        allDates.add(normalized);
                                    }
                                }
                            });
                        }
                    });
                    
                    // Load walking data async and re-merge when done
                    if (allDates.size > 0) {
                        console.log('Loading walking data for', allDates.size, 'cached dates');
                        loadWalkingDataForDates(Array.from(allDates)).then(() => {
                            console.log('Walking data loaded from storage, re-merging...');
                            ['at', 'at-nyc', 'mbt'].forEach(tab => {
                                if (appData[tab].master.length > 0) {
                                    mergeData(tab);
                                    applyFilters(tab);
                                    populateFilterDropdowns(tab);
                                }
                            });
                            
                            // RENDER ALL TABS after loading from storage
                            console.log('=== RENDERING ALL TABS AFTER STORAGE LOAD ===');
                            renderNewMoney();
                            renderPendingPayments();
                            renderChangesView();
                            updateInsightsDatasetInfo();
                            populateWalkingInsights();
                            populateViolationTypes();
                            populateBestDayOfWeek();
                            console.log('=== ALL TABS RENDERED ===');
                        }).catch(err => {
                            console.error('Error loading walking data:', err);
                        });
                    } else {
                        // No walking data needed, just apply filters
                        ['at', 'at-nyc', 'mbt'].forEach(tab => {
                            if (appData[tab].merged.length > 0) {
                                applyFilters(tab);
                                populateFilterDropdowns(tab);
                            }
                        });
                        
                        // RENDER ALL TABS after loading from storage
                        console.log('=== RENDERING ALL TABS AFTER STORAGE LOAD (no walking data) ===');
                        renderNewMoney();
                        renderPendingPayments();
                        renderChangesView();
                        updateInsightsDatasetInfo();
                        populateWalkingInsights();
                        populateViolationTypes();
                        populateBestDayOfWeek();
                        console.log('=== ALL TABS RENDERED ===');
                    }
                }
            } catch (e) {
                console.error('Error loading from localStorage:', e);
            }
        }

        async function diagnoseCSVColumns() {
            const tabs = ['at', 'at-nyc', 'mbt'];
            let report = 'üîç CSV COLUMN DIAGNOSTIC REPORT\n';
            report += '='.repeat(60) + '\n\n';
            
            for (const tab of tabs) {
                report += `üìã ${tab.toUpperCase()} MASTER SHEET:\n`;
                report += '-'.repeat(60) + '\n';
                
                try {
                    const url = sheetURLs[tab].master;
                    if (!url) {
                        report += `‚ùå No URL configured\n\n`;
                        continue;
                    }
                    
                    report += `URL: ${url}\n\n`;
                    
                    // Fetch the CSV
                    const csvUrl = convertToCSVUrl(url);
                    const text = await fetchWithCORS(csvUrl);
                    
                    // Parse just the first line (headers)
                    const lines = text.split('\n');
                    const headerLine = lines[0];
                    
                    // Simple CSV header parsing
                    const headers = headerLine.split(',').map(h => h.trim().replace(/^"|"$/g, ''));
                    
                    report += `Column Count: ${headers.length}\n`;
                    report += `Columns Found:\n`;
                    headers.forEach((col, idx) => {
                        const hasDisq = col.toLowerCase().includes('disq') || col.toLowerCase().includes('reason');
                        const marker = hasDisq ? ' ‚≠ê' : '';
                        report += `  ${idx + 1}. "${col}"${marker}\n`;
                    });
                    
                    // Check for Disqualification Reason specifically
                    const hasExactMatch = headers.includes('Disqualification Reason');
                    const similarMatches = headers.filter(h => 
                        h.toLowerCase().includes('disq') || h.toLowerCase().includes('reason')
                    );
                    
                    report += `\n‚úì Has "Disqualification Reason" (exact): ${hasExactMatch ? 'YES ‚úÖ' : 'NO ‚ùå'}\n`;
                    if (similarMatches.length > 0 && !hasExactMatch) {
                        report += `‚ö†Ô∏è  Similar columns found: ${similarMatches.join(', ')}\n`;
                    }
                    
                    // Show raw first line
                    report += `\nüìÑ Raw CSV First Line:\n${headerLine.substring(0, 200)}${headerLine.length > 200 ? '...' : ''}\n`;
                    
                } catch (error) {
                    report += `‚ùå Error fetching: ${error.message}\n`;
                }
                
                report += '\n' + '='.repeat(60) + '\n\n';
            }
            
            // Show in alert and console
            console.log(report);
            alert(report);
        }

        function clearCacheAndReload() {
            if (confirm('This will clear all cached data and reload from Google Sheets. Continue?')) {
                // Clear localStorage
                localStorage.removeItem('truckDataManager');
                
                // Clear appData
                ['at', 'at-nyc', 'mbt'].forEach(tab => {
                    appData[tab].master = [];
                    appData[tab].paid = [];
                    appData[tab].requests = [];
                    appData[tab].merged = [];
                    appData[tab].filtered = [];
                });
                
                // Reload all data
                loadAllData();
            }
        }
    </script>
</body>
</html>
